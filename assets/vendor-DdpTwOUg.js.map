{"version":3,"mappings":"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","names":["makeMap","str","map","Object","create","key","split","val","EMPTY_OBJ","EMPTY_ARR","NOOP","NO","isOn","charCodeAt","isModelListener","startsWith","extend","assign","remove","arr","el","i","indexOf","splice","hasOwnProperty","prototype","hasOwn","call","isArray","Array","isMap","toTypeString","isSet","isFunction","isString","isSymbol","isObject","isPromise","then","catch","objectToString","toString","value","isPlainObject","isIntegerKey","parseInt","isReservedProp","cacheStringFunction","fn","cache","camelizeRE","camelize","replace","c","slice","toUpperCase","hyphenateRE","hyphenate","toLowerCase","capitalize","charAt","toHandlerKey","hasChanged","oldValue","is","invokeArrayFns","fns","arg","length","def","obj","writable","defineProperty","configurable","enumerable","looseToNumber","n","parseFloat","isNaN","_globalThis","getGlobalThis","globalThis","self","window","global","normalizeStyle","res","item","normalized","parseStringStyle","listDelimiterRE","propertyDelimiterRE","styleCommentRE","cssText","ret","forEach","tmp","trim","normalizeClass","name","isSpecialBooleanAttr","includeBooleanAttr","isRef","toDisplayString","JSON","stringify","replacer","String","_key","size","entries","reduce","val2","stringifySymbol","values","v","_a","description","activeEffectScope","activeSub","EffectScope","constructor","detached","this","_active","_on","effects","cleanups","_isPaused","parent","index","scopes","push","active","pause","l","resume","run","currentEffectScope","on","prevScope","off","stop","fromParent","last","pop","pausedQueueEffects","WeakSet","ReactiveEffect","deps","depsTail","flags","next","cleanup","scheduler","has","delete","trigger","notify","batch","cleanupEffect","prepareDeps","prevEffect","prevShouldTrack","shouldTrack","cleanupDeps","link","nextDep","removeSub","onStop","add","runIfDirty","isDirty","dirty","batchedSub","batchedComputed","batchDepth","sub","isComputed","startBatch","endBatch","e","error","err","version","prevActiveLink","dep","activeLink","head","tail","prev","prevDep","removeDep","computed","refreshComputed","_dirty","globalVersion","isSSR","prevSub","_value","soft","nextSub","subs","sc","trackStack","pauseTracking","resetTracking","Link","Dep","__v_skip","track","debugInfo","addSub","currentTail","targetMap","WeakMap","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ARRAY_ITERATE_KEY","target","type","depsMap","get","set","Map","newValue","oldTarget","targetIsArray","isArrayIndex","newLength","Number","key2","reactiveReadArray","array","raw","toRaw","isShallow","toReactive","shallowReadArray","arrayInstrumentations","__proto__","iterator","concat","args","x","every","thisArg","apply","arguments","filter","find","findIndex","findLast","findLastIndex","includes","searchProxy","join","separator","lastIndexOf","noTracking","reduceRight","shift","some","toReversed","toSorted","comparer","toSpliced","unshift","method","wrapValue","iter","_next","result","done","arrayProto","wrappedRetFn","needsWrap","methodFn","result2","wrappedFn","acc","isProxy","isNonTrackableKeys","builtInSymbols","Set","getOwnPropertyNames","BaseReactiveHandler","_isReadonly","_isShallow","receiver","isReadonly2","isShallow2","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","getPrototypeOf","Reflect","readonly","reactive","MutableReactiveHandler","super","isOldValueReadonly","isReadonly","hadKey","deleteProperty","ownKeys","ReadonlyReactiveHandler","mutableHandlers","readonlyHandlers","shallowReactiveHandlers","toShallow","getProto","createReadonlyMethod","createInstrumentations","shallow","instrumentations","rawTarget","rawKey","wrap","toReadonly","callback","observed","clear","hadItems","targetIsMap","isPair","isKeyOnly","innerIterator","createIterableMethod","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","getTargetType","isExtensible","rawType","targetTypeMap","toRawType","createReactiveObject","shallowReactive","baseHandlers","collectionHandlers","proxyMap","targetType","existingProxy","proxy","Proxy","isReactive","r","ref","createRef","shallowRef","rawValue","RefImpl","_rawValue","useDirectValue","unref","ref2","shallowUnwrapHandlers","proxyRefs","objectWithRefs","ComputedRefImpl","setter","__v_isRef","effect","INITIAL_WATCHER_VALUE","cleanupMap","activeWatcher","watch","source","cb","options","immediate","deep","once","augmentJob","reactiveGetter","source2","traverse","getter","boundCleanup","forceTrigger","isMultiSource","s","currentEffect","baseGetter","depth","Infinity","scope","watchHandle","_cb","fill","job","immediateFirstRun","currentWatcher","effect2","cleanupFn","failSilently","owner","onWatcherCleanup","cleanup2","bind","seen","getOwnPropertySymbols","propertyIsEnumerable","callWithErrorHandling","instance","handleError","callWithAsyncErrorHandling","throwInDev","vnode","errorHandler","throwUnhandledErrorInProduction","appContext","config","cur","exposedInstance","errorInfo","errorCapturedHooks","ec","contextVNode","throwInProd","logError","queue","flushIndex","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","resolvedPromise","resolve","currentFlushPromise","nextTick","p","queueJob","jobId","getId","lastJob","id","start","end","middle","middleJob","middleJobId","findInsertionIndex","queueFlush","flushJobs","flushPreFlushCbs","uid","flushPostFlushCbs","deduped","sort","a","b","currentRenderingInstance","currentScopeId","setCurrentRenderingInstance","__scopeId","withCtx","ctx","isNonScopedSlot","_n","renderFnWithContext","_d","setBlockTracking","prevInstance","_c","invokeDirectiveHook","prevVNode","bindings","dirs","oldBindings","binding","hook","dir","TeleportEndKey","isTeleportDisabled","props","disabled","isTeleportDeferred","defer","isTargetSVG","SVGElement","isTargetMathML","MathMLElement","resolveTarget","select","targetSelector","to","TeleportImpl","__isTeleport","process","n1","n2","container","anchor","parentComponent","parentSuspense","namespace","slotScopeIds","optimized","internals","mc","mountChildren","pc","patchChildren","pbc","patchBlockChildren","o","insert","querySelector","createText","createComment","shapeFlag","children","dynamicChildren","placeholder","mainAnchor","mount","container2","anchor2","mountToTarget","targetAnchor","prepareAnchor","isCE","ce","_teleportTargets","updateCssVars","__isMounted","queuePostRenderEffect","targetStart","wasDisabled","currentContainer","currentAnchor","traverseStaticChildren","moveTeleport","nextTarget","um","unmount","hostRemove","doRemove","shouldRemove","child","move","hydrate","node","nextSibling","parentNode","hydrateChildren","hydrateDisabledTeleport","node2","vnode2","targetNode","_lpa","firstChild","nodeType","data","parentAnchor","m","moveType","isReorder","Teleport","isDisabled","ut","setAttribute","leaveCbKey","setTransitionHooks","hooks","component","transition","subTree","ssContent","clone","ssFallback","defineComponent","extraOptions","setup","markAsyncBoundary","ids","pendingSetRefMap","setRef","rawRef","oldRawRef","isUnmount","isAsyncWrapper","__asyncResolved","refValue","getComponentPublicInstance","oldRef","refs","setupState","rawSetupState","canSetSetupRef","invalidatePendingSetRef","oldRawRefAtom","k","_isString","_isRef","doSet","f","existing","newVal","pendingSetRef","isComment","requestIdleCallback","cancelIdleCallback","__asyncLoader","defineAsyncComponent","loader","loadingComponent","errorComponent","delay","hydrateStrategy","timeout","suspensible","onError","userOnError","resolvedComp","pendingRequest","retries","load","thisRequest","Error","Promise","reject","comp","__esModule","toStringTag","default","__asyncHydrate","patched","bu","performHydrate","doHydrate","teardown","forEachElement","bum","isUnmounted","currentInstance","createInnerComp","suspense","isInSSRComponentSetup","createVNode","loaded","delayed","setTimeout","isKeepAlive","update","__isKeepAlive","onActivated","registerKeepAliveHook","onDeactivated","wrappedHook","__wdc","current","isDeactivated","injectHook","injectToKeepAliveRoot","keepAliveRoot","injected","onUnmounted","prepend","__weh","reset","setCurrentInstance","createHook","lifecycle","onBeforeMount","onMounted","onBeforeUpdate","onUpdated","onBeforeUnmount","onServerPrefetch","onRenderTriggered","onRenderTracked","onErrorCaptured","COMPONENTS","resolveComponent","maybeSelfReference","resolveAsset","NULL_DYNAMIC_COMPONENT","for","resolveDynamicComponent","warnMissing","Component","selfName","getComponentName","registry","renderList","renderItem","cached","sourceIsArray","isReadonlySource","from","keys","renderSlot","slots","fallback","noSlotted","hasProps","openBlock","createBlock","Fragment","slot","validSlotContent","ensureValidVNode","slotKey","rendered","_","scopeId","vnodes","isVNode","Comment","getPublicInstance","isStatefulComponent","publicPropertiesMap","$","$el","$data","$props","$attrs","attrs","$slots","$refs","$parent","$root","root","$host","$emit","emit","$options","resolveMergedOptions","$forceUpdate","$nextTick","$watch","instanceWatch","hasSetupBinding","state","__isScriptSetup","PublicInstanceProxyHandlers","accessCache","normalizedProps","propsOptions","shouldCacheAccess","publicGetter","cssModule","globalProperties","__cssModules","cssModules","descriptor","normalizePropsOrEmits","applyOptions","publicThis","beforeCreate","callHook","dataOptions","computedOptions","methods","watchOptions","provide","provideOptions","inject","injectOptions","created","beforeMount","mounted","beforeUpdate","updated","activated","deactivated","beforeDestroy","beforeUnmount","destroyed","unmounted","render","renderTracked","renderTriggered","errorCaptured","serverPrefetch","expose","inheritAttrs","components","directives","filters","normalizeInject","opt","resolveInjections","methodHandler","createWatcher","provides","registerLifecycleHook","register","_hook","exposed","h","createPathGetter","handler","base","mixins","extends","extendsOptions","globalMixins","optionsCache","optionMergeStrategies","resolved","mergeOptions","mergeOptions$1","strats","asMixin","strat","internalOptionMergeStrats","mergeDataFn","mergeEmitsOrPropsOptions","emits","mergeObjectOptions","mergeAsArray","merged","createAppContext","app","isNativeTag","performance","warnHandler","compilerOptions","propsCache","emitsCache","uid$1","createAppAPI","rootComponent","rootProps","context","installedPlugins","pluginCleanupFns","isMounted","_uid","_component","_props","_container","_context","_instance","use","plugin","install","mixin","directive","rootContainer","isHydrate","_ceVNode","__vue_app__","onUnmount","runWithContext","lastApp","currentApp","parentProvides","defaultValue","treatDefaultAsFactory","getCurrentInstance","internalObjectProto","createInternalObject","isInternalObject","setFullProps","rawProps","needCastKeys","rawCastValues","hasAttrsChanged","camelKey","isEmitListener","emitsOptions","rawCurrentProps","castValues","resolvePropValue","isAbsent","hasDefault","Function","skipFactory","propsDefaults","_setProp","mixinPropsCache","normalizePropsOptions","hasExtends","extendProps","raw2","normalizedKey","validatePropName","prop","propType","shouldCast","shouldCastTrue","typeName","isInternalKey","normalizeSlotValue","normalizeVNode","normalizeSlot","rawSlot","normalizeObjectSlots","rawSlots","_ctx","normalizeVNodeSlots","assignSlots","pendingBranch","createRenderer","__VUE__","hostInsert","patchProp","hostPatchProp","createElement","hostCreateElement","hostCreateText","hostCreateComment","setText","hostSetText","setElementText","hostSetElementText","hostParentNode","hostNextSibling","setScopeId","hostSetScopeId","insertStaticContent","hostInsertStaticContent","patch","isSameVNodeType","getNextHostNode","patchFlag","Text","processText","processCommentNode","Static","mountStaticNode","processFragment","processElement","processComponent","moveStaticNode","removeStaticNode","mountElement","customElement","_isVueCE","_beginPatch","patchElement","_endPatch","vnodeHook","resolveChildrenNamespace","onVnodeBeforeMount","invokeVNodeHook","needCallTransitionHooks","persisted","needTransition","beforeEnter","onVnodeMounted","enter","isSuspense","parentVNode","cloneIfMounted","oldProps","newProps","toggleRecurse","onVnodeBeforeUpdate","innerHTML","textContent","patchProps","class","style","propsToUpdate","dynamicProps","onVnodeUpdated","oldChildren","newChildren","fallbackContainer","oldVNode","newVNode","fragmentStartAnchor","fragmentEndAnchor","fragmentSlotScopeIds","activate","mountComponent","updateComponent","initialVNode","emptyAppContext","exposeProxy","withProxy","renderCache","normalizeEmitsOptions","emitted","setupContext","suspenseId","pendingId","asyncDep","asyncResolved","bc","bm","u","da","rtg","rtc","sp","createComponentInstance","renderer","setInSSRSetupState","isStateful","initProps","initSlots","setupResult","attrsProxyHandlers","createSetupContext","isAsyncSetup","unsetCurrentInstance","resolvedResult","handleSetupResult","finishComponentSetup","setupStatefulComponent","setupComponent","registerDep","setupRenderEffect","nextVNode","prevProps","prevChildren","nextProps","nextChildren","$stable","hasPropsChanged","shouldUpdateComponent","updateComponentPreRender","componentUpdateFn","nonHydratedAsyncRoot","locateNonHydratedAsyncRoot","originNext","nextTree","renderComponentRoot","prevTree","activeBranch","updateHOCHostEl","isAsyncWrapperVNode","_def","shadowRoot","_injectChildStyle","scopedInitialVNode","rawPrevProps","kebabKey","camelizedKey","updateProps","needDeletionCheck","deletionComparisonTarget","updateSlots","c1","prevShapeFlag","c2","patchKeyedChildren","patchUnkeyedChildren","unmountChildren","oldLength","commonLength","Math","min","nextChild","l2","e1","e2","nextPos","s1","s2","keyToNewIndexMap","j","toBePatched","moved","maxNewIndexSoFar","newIndexToOldIndexMap","prevChild","newIndex","increasingNewIndexSequence","len","arrI","getSequence","nextIndex","anchorVNode","leave","delayLeave","afterLeave","remove2","performLeave","_isLeaving","remove22","cacheIndex","deactivate","shouldInvokeDirs","shouldInvokeVnodeHook","onVnodeBeforeUnmount","unmountComponent","hasOnce","onVnodeUnmounted","removeFragment","performRemove","invalidateMount","teleportEnd","isFlushing","_vnode","mt","createApp","baseCreateRenderer","currentNamespace","encoding","allowed","ch1","ch2","subComponent","ssrContextKey","useSSRContext","doWatch","flush","baseWatchOptions","runsImmediately","ssrCleanup","__watcherHandles","watchStopHandle","isPre","isFirstRun","watch$1","path","segments","getModelModifiers","modelName","modelModifiers","event","rawArgs","modifiers","handlerName","number","onceHandler","mixinEmitsCache","extendEmits","normalizedFromExtend","fallthroughAttrs","proxyToUse","thisProxy","render2","getFunctionalFallthrough","blockStack","filterModelListeners","cloneVNode","nextKeys","__isSuspense","currentBlock","disableTracking","isBlockTreeEnabled","inVOnce","setupBlock","createElementBlock","createBaseVNode","__v_isVNode","normalizeKey","normalizeRef","ref_key","ref_for","isBlockNode","needFullChildrenNormalization","staticCount","normalizeChildren","normalize","cloned","__vccOpts","guardReactiveProps","klass","isTeleport","extraProps","mergeRef","cloneTransition","mergedProps","toMerge","incoming","mergeProps","createTextVNode","text","flag","createCommentVNode","asBlock","memo","slotFlag","internalSetCurrentInstance","g","registerGlobalSetter","setters","__ssrInlineRender","ssrRender","skipOptions","includeInferred","displayName","__name","getterOrOptions","debugOptions","computed$1","propsOrChildren","policy","tt","trustedTypes","createPolicy","createHTML","unsafeToTrustedHTML","doc","document","templateContainer","nodeOps","insertBefore","removeChild","tag","createElementNS","multiple","createTextNode","nodeValue","selector","content","before","previousSibling","lastChild","cloneNode","template","wrapper","appendChild","vtcKey","vShowOriginalDisplay","vShowHidden","CSS_VAR_TEXT","displayRE","importantRE","setStyle","setProperty","prefixed","rawName","prefixCache","prefixes","autoPrefix","test","xlinkNS","patchAttr","isSVG","isBoolean","removeAttributeNS","setAttributeNS","removeAttribute","patchDOMProp","attrName","tagName","getAttribute","needRemove","veiKey","patchEvent","prevValue","nextValue","invokers","existingInvoker","optionsModifierRE","match","parseName","invoker","initialValue","_vts","attached","Date","now","originalStop","stopImmediatePropagation","_stopped","patchStopImmediatePropagation","getNow","createInvoker","addEventListener","addEventListener$1","removeEventListener","cachedNow","isNativeOn","systemModifiers","modifierGuards","stopPropagation","prevent","preventDefault","currentTarget","ctrl","ctrlKey","shiftKey","alt","altKey","meta","metaKey","left","button","right","exact","withModifiers","_withMods","cacheKey","guard","keyNames","esc","space","up","down","withKeys","_withKeys","eventKey","rendererOptions","transitionClasses","className","patchClass","isCssString","hasControlledDisplay","prevStyle","cssVarText","display","patchStyle","shouldSetAsProp","_trueValue","_falseValue","camelize$1","containerOrSelector","normalizeContainer","resolveRootNamespace","Element","ConsoleApiName","log","debug","info","warn","globalConsole","console","originalConsoleMethods","PREFIX","DOCS_ORIGIN","DOCS_TROUBLESHOOTING","MORE_DETAILS","catchUserErrors","errorMsg","performDraw","threshold","random","round","num","decimals","toFixed","isNumber","ONE_SECOND","ONE_MINUTE","ONE_YEAR","relativeToClocks","relative","timeStamp","getCorrectedTimeStamp","relativeTime","correctedOrigin","dateNow","getNavigationStart","addDuration","getTimeStamp","toServerDuration","duration","getTime","timeStampNow","relativeNow","clocksNow","clocksOrigin","elapsed","getRelativeTime","timestamp","navigationStart","timing","ONE_KIBI_BYTE","HAS_MULTI_BYTES_CHARACTERS","computeBytesCount","candidate","TextEncoder","encode","Blob","shallowClone","object","objectHasValue","isEmptyObject","getGlobalObject","globalObject","_dd_temp_","getZoneJsOriginalValue","browserWindow","original","Zone","__symbol__","onMonitorErrorCollected","debugMode","setDebugMode","newDebugMode","monitor","callMonitored","monitorError","displayIfDebugEnabled","clearTimeout","timeoutId","setInterval","clearInterval","Observable","onFirstSubscribe","observers","subscribe","onLastUnsubscribe","unsubscribe","other","observer","mergeObservables","observables","globalObservable","subscriptions","observable","subscription","throttle","wait","needLeadingExecution","leading","needTrailingExecution","trailing","pendingExecutionWithParameters","pendingTimeoutId","inWaitPeriod","throttled","parameters","cancel","noop","generateUUID","COMMA_SEPARATED_KEY_VALUE","findCommaSeparatedValue","rawString","lastIndex","exec","safeTruncate","suffix","lastChar","correctedLength","browserCache","initCookieParsed","getCurrentSiteCache","detectBrowserCached","userAgent","navigator","chrome","vendor","detectBrowser","setCookie","expireDelay","date","setTime","expires","toUTCString","sameSite","crossSite","domain","secure","partitioned","cookie","getCookie","getInitCookie","findCommaSeparatedValues","deleteCookie","SESSION_STORE_KEY","objectValues","objectEntries","SESSION_TIME_OUT_DELAY","SESSION_EXPIRATION_DELAY","SESSION_COOKIE_EXPIRATION_DELAY","SessionPersistence","SESSION_ENTRY_REGEXP","getExpiredSessionState","previousSessionState","configuration","expiredSessionState","isExpired","trackAnonymousUser","anonymousId","isSessionInNotStartedState","session","isSessionStarted","isSessionInExpiredState","sessionState","expire","expandSessionState","toSessionString","toSessionState","sessionString","isValidSessionString","entry","matches","selectCookieStrategy","initConfiguration","cookieOptions","useSecureSessionCookie","usePartitionedCrossSiteSessionCookie","trackSessionAcrossSubdomains","testCookieName","testCookieValue","domainLevels","location","hostname","candidateDomain","getCurrentSite","buildCookieOptions","isCookieCorrectlySet","areCookiesAuthorized","initCookieStrategy","cookieStore","isLockEnabled","persistSession","retrieveSession","retrieveSessionCookie","expireSession","expireSessionCookie","cookieStoreStrategy","oldSessionId","oldRumType","oldLogsType","tryOldCookiesMigration","selectLocalStorageStrategy","testKey","localStorage","setItem","retrievedId","getItem","removeItem","initLocalStorageStrategy","persistInLocalStorage","retrieveSessionFromLocalStorage","expireSessionFromLocalStorage","bufferedOperations","ongoingOperations","processSessionStoreOperations","operations","sessionStoreStrategy","numberOfRetries","persistWithLock","lock","currentLock","retrieveStore","currentStore","retryLater","processedSession","after","sessionStore","currentNumberOfRetries","nextOperations","STORAGE_POLL_DELAY","selectSessionStoreStrategyType","sessionPersistence","sessionStoreStrategyType","allowFallbackToLocalStorage","startSessionStore","productKey","computeSessionState","renewObservable","expireObservable","sessionStateUpdateObservable","watchSessionTimeoutId","synchronizeSession","sessionCache","startSession","throttledExpandOrRenewSession","cancelExpandOrRenewSession","synchronizedSession","trackingType","isTracked","expandOrRenewSessionState","hasSessionInCache","renewSessionInCache","isSessionInCacheOutdated","previousState","newState","expandOrRenewSession","expandSession","getSession","restartSession","updateSessionState","partialSessionState","TrackingConsent","GRANTED","NOT_GRANTED","jsonStringify","restoreObjectPrototypeToJson","detachToJsonMethod","restoreArrayPrototypeToJson","restoreValuePrototypeToJson","restoreValueToJson","objectToJson","toJSON","normalizeUrl","url","buildUrl","href","supportedURL","isURLSupported","originalURL","getSupportedUrl","anchorElement","implementation","createHTMLDocument","baseElement","body","URL","INTAKE_SITE_STAGING","INTAKE_SITE_US1","INTAKE_SITE_EU1","INTAKE_URL_PARAMETERS","createEndpointBuilder","trackType","configurationTags","buildUrlWithParameters","normalizedProxyUrl","encodeURIComponent","host","buildEndpointHost","createEndpointUrlWithParametersBuilder","build","api","payload","clientToken","internalAnalyticsSubdomain","retry","tags","count","lastFailureStatus","reverse","buildEndpointParameters","urlPrefix","site","usePciIntake","domainParts","extension","buildTag","valueSizeLimit","RegExp","supportUnicodePropertyEscapes","hasForbiddenCharacters","computeTransportConfiguration","env","service","datacenter","buildTags","endpointBuilders","logsEndpointBuilder","rumEndpointBuilder","sessionReplayEndpointBuilder","computeEndpointBuilders","replicaConfiguration","replica","replicaEndpointBuilders","applicationId","computeReplicaConfiguration","DefaultPrivacyLevel","ALLOW","MASK","MASK_USER_INPUT","TraceContextInjection","ALL","SAMPLED","isSampleRate","sampleRate","validateAndBuildConfiguration","_b","_e","_f","sessionSampleRate","telemetrySampleRate","telemetryConfigurationSampleRate","telemetryUsageSampleRate","trackingConsent","beforeSend","silentMultipleInit","allowUntrustedEvents","storeContextsAcrossPages","batchBytesLimit","eventRateLimiterThreshold","maxTelemetryEventsPerPage","flushTimeout","batchMessagesLimit","messageBytesLimit","ExperimentalFeature","enabledExperimentalFeatures","initFeatureFlags","enableExperimentalFeatures","isExperimentalFeatureEnabled","featureName","getExperimentalFeatures","UNKNOWN_FUNCTION","computeStackTrace","ex","stack","stackProperty","tryToGetString","exString","line","stackFrame","parts","CHROME_LINE_RE","isNative","isEval","submatch","CHROME_EVAL_RE","column","func","parseChromeLine","CHROME_ANONYMOUS_FUNCTION_RE","parseChromeAnonymousLine","WINJS_LINE_RE","parseWinLine","GECKO_LINE_RE","GECKO_EVAL_RE","parseGeckoLine","message","fileUrl","filePosition","property","computeStackTraceFromOnErrorMessage","messageObj","ERROR_TYPES_RE","tryToParseMessage","createHandlingStack","formattedStack","stackTrace","toStackTraceString","formatErrorMessage","frame","instrumentMethod","targetPrototype","onPreCall","computeHandlingStack","stopped","instrumentation","postCallCallback","onPostCall","handlingStack","instrumentSetter","originalDescriptor","getOwnPropertyDescriptor","stoppedInstrumentation","instrumentationWrapper","sanitize","maxCharacterCount","containerQueue","visitedObjectsWithPath","sanitizedData","sanitizeProcessor","serializedSanitizedData","accumulatedCharacterCount","containerToProcess","separatorLength","targetData","warnOverCharacterLimit","parentPath","sourceToSanitize","tryToApplyToJSON","sanitizePrimitivesAndFunctions","sanitizedSource","sanitizeObjects","sourceAsObject","currentPath","Event","isTrusted","changeType","NO_ERROR_STACK_PRESENT_MESSAGE","computeRawError","originalError","componentStack","startClocks","nonErrorPrefix","handling","isErrorInstance","isError","computeMessage","hasUsableStack","causes","flattenErrorCauses","fingerprint","tryToGetFingerprint","tryToGetErrorContext","dd_fingerprint","dd_context","parentSource","currentError","cause","ErrorSource","trackRuntimeError","errorObservable","handleRuntimeError","rawError","stopInstrumentingOnError","errorObj","stopInstrumentingOnUnhandledRejection","reason","instrumentUnhandledRejection","displayAlreadyInitializedError","sdkName","eventTarget","eventName","listener","addEventListeners","eventNames","capture","passive","listenerWithMonitor","__ddIsTrusted","listenerTarget","EventTarget","RawReportType","initReportObservable","apis","blockedURI","effectiveDirective","buildRawReportError","csp","disposition","buildStack","originalPolicy","sourceFile","lineNumber","columnNumber","buildRawReportErrorFromCspViolation","createCspViolationReportObservable","reportTypes","ReportingObserver","handleReports","reports","report","buildRawReportErrorFromReport","types","buffered","observe","disconnect","createReportObservable","partial","sendToExtension","__ddBrowserSdkExtensionCallback","getType","mergeInto","destination","circularReferenceChecker","hasAlreadyBeenSeen","createCircularReferenceChecker","ignoreCase","multiline","sticky","unicode","deepClone","combine","sources","getConnectivity","status","onLine","interfaces","connection","effective_type","effectiveType","createBoundedBuffer","buffer","drain","TelemetryType","ALLOWED_FRAME_URLS","TELEMETRY_EXCLUDED_SITES","preStartTelemetryBuffer","onRawTelemetryEventCollected","startTelemetry","telemetryService","contextProvider","alreadySentEvents","telemetryEnabled","telemetryEnabledPerType","TelemetryType_log","TelemetryType_configuration","TelemetryType_usage","runtimeEnvInfo","is_local_file","protocol","is_worker","rawEvent","stringifiedEvent","_dd","format_version","telemetry","runtime_env","connectivity","sdk_setup","experimental_features","toTelemetryEvent","addTelemetryError","setContextProvider","provider","enabled","addTelemetryDebug","formatError","addTelemetryUsage","usage","kind","scrubCustomerFrames","allowedFrameUrl","END_OF_TIMES","cleanupHistoriesInterval","cleanupTasks","createValueHistory","maxEntries","deletedEntries","task","clearExpiredValues","oldTimeThreshold","endTime","startTime","close","returnInactive","closeActive","latestEntry","findAll","getAllEntries","getDeletedEntries","VISIBILITY_CHECK_DELAY","SESSION_CONTEXT_TIMEOUT_DELAY","startSessionManager","trackingConsentState","sessionContextHistory","buildSessionContext","isReplayForced","forcedReplay","isGranted","trackActivity","expandSessionWhenVisible","visibilityState","trackVisibility","trackResume","findSession","MAX_QUEUE_BYTES_COUNT","INITIAL_BACKOFF_TIME","sendWithRetryStrategy","sendStrategy","reportError","transportStatus","queuedPayloads","bandwidthMonitor","canHandle","send$1","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","first","dequeue","currentBackoffTime","send","response","shouldRetryRequest","ongoingRequestCount","isFull","queueFullReported","previousQueue","newPayloadQueue","bytesCount","createHttpRequest","endpointBuilder","bytesLimit","retryState","ongoingByteCount","sendStrategyForRetry","onResponse","canUseKeepAlive","Request","isKeepAliveSupported","fetchUrl","fetch","keepalive","mode","sendXHR","fetchKeepAliveStrategy","sendOnExit","canUseBeacon","sendBeacon","beaconUrl","hasReportedBeaconError","reportBeaconError","xhrUrl","sendBeaconStrategy","request","XMLHttpRequest","open","setRequestHeader","getEventBridge","eventBridgeGlobal","DatadogEventBridge","getCapabilities","parse","getPrivacyLevel","getAllowedWebViewHosts","eventType","viewId","view","bridgeSupports","capability","bridge","canUseEventBridge","currentHost","allowedHost","endsWith","PageExitReason","HIDDEN","UNLOADING","PAGEHIDE","FROZEN","isPageExitReason","createBatch","encoder","flushController","upsertBuffer","flushSubscription","flushObservable","upsertMessages","isPageExit","isAsync","encoderResult","finishSync","outputBytesCount","formatPayloadFromEncoder","pendingMessages","pendingData","Boolean","write","isEmpty","finish","addOrUpdate","serializedMessage","estimatedMessageBytesCount","estimateEncodedBytesCount","hasMessageFor","removedMessage","messageBytesCount","notifyAfterRemoveMessage","notifyBeforeAddMessage","notifyAfterAddMessage","realMessageBytesCount","upsert","output","createFlushController","messagesLimit","durationLimit","pageExitObservable","sessionExpireObservable","pageExitSubscription","sessionExpireSubscription","durationLimitTimeoutId","currentBytesCount","currentMessagesCount","flushReason","messagesCount","cancelDurationLimitTimeout","messageBytesCountDiff","createIdentityEncoder","additionalEncodedBytesCount","rawBytesCount","createEventRateLimiter","limit","onLimitReached","eventCount","allowNextEvent","isLimitReached","runOnReadyState","expectedReadyState","readyState","asyncRunOnReadyState","xhrObservable","xhrContexts","initXhrObservable","stopInstrumentingStart","openXhr","stopInstrumentingSend","xhr","startContext","isAborted","hasBeenReported","stopInstrumentingOnReadyStateChange","DONE","onEnd","unsubscribeLoadEndListener","completeContext","sendXhr","stopInstrumentingAbort","abortXhr","createXhrObservable","fetchObservable","initFetchObservable","input","init","methodFromParams","responsePromise","reportFetch","partialContext","responseType","signal","aborted","DOMException","code","ABORT_ERR","afterSend","opts","didTimeout","timeRemaining","max","MAX_TASK_TIME","requestIdleCallbackShim","consoleObservablesByApi","initConsoleObservable","originalConsoleApi","params","param","formatConsoleParameters","firstErrorParam","buildConsoleLog","createConsoleObservable","ensureProperties","propertiesConfig","newContext","required","createContextManager","customerDataTracker","changeObservable","contextManager","getContext","setContext","maybeContext","isValid","checkContext","clearContext","updateCustomerData","setContextProperty","removeContextProperty","resetCustomerData","CONTEXT_STORE_KEY_PREFIX","storageListeners","storeContextManager","customerDataType","storageKey","buildStorageKey","getFromStorage","rawContext","createCustomerDataTrackerManager","compressionStatus","customerDataTrackers","alreadyWarned","checkCustomerDataLimit","initialBytesCount","bytesCountLimit","tracker","getBytesCount","displayCustomerDataLimitReachedWarning","createDetachedTracker","createCustomerDataTracker","getOrCreateTracker","setCompressionStatus","newCompressionStatus","getCompressionStatus","bytesCountCache","computeBytesCountThrottled","cancelComputeBytesCount","resetBytesCount","willSyntheticsInjectRum","_DATADOG_SYNTHETICS_INJECTS_RUM","isMatchOption","itemType","matchList","list","useStartsWith","startVitalCollection","lifeCycle","pageStateHistory","customVitalsState","addDurationVital","vital","wasInPageStateDuringPeriod","rawRumEvent","computed_value","customerContext","domainContext","processVital","startDurationVital","stopDurationVital","nameOrRef","vitalsByName","vitalsByReference","reference","__dd_vital_reference","stopCallback","vitalStart","stopOptions","stopClocks","buildDurationVital","callPluginsMethod","plugins","methodName","parameter","createSpanIdentifier","createIdentifier","bits","crypto","getRandomValues","Uint32Array","radix","high","low","mod","floor","toPaddedHexadecimalString","padStart","sampleDecisionCache","isTraceSampled","sessionId","CONSISTENT_TRACE_SAMPLING","decision","BigInt","identifier","knuthFactor","twoPow64","sampleUsingKnuthFactor","clearTracingIfNeeded","traceId","spanId","traceSampled","injectHeadersIfTracingAllowed","sessionManager","findTrackedSession","tracingOption","allowedTracingUrls","traceSampleRate","traceContextInjection","propagatorTypes","tracingHeaders","propagatorType","traceparent","tracestate","b3","makeTracingHeaders","DEFAULT_PROPAGATOR_TYPES","validateAndBuildRumConfiguration","trackFeatureFlagsForEvents","sessionReplaySampleRate","excludedActivityUrls","tracingOptions","option","expectedItem","isTracingOption","validateAndBuildTracingOptions","baseConfiguration","actionNameAttribute","startSessionReplayRecordingManually","rulePsr","workerUrl","compressIntakeRequests","trackUserInteractions","trackViewsManually","trackResources","trackLongTasks","subdomain","defaultPrivacyLevel","enablePrivacyForActionName","customerDataTelemetrySampleRate","getSelectedTracingPropagators","usedTracingPropagators","fetchAndApplyRemoteConfiguration","remoteConfiguration","responseText","rum","displayRemoteConfigurationFetchingError","remoteConfigurationId","buildEndpoint","fetchRemoteConfiguration","remoteInitConfiguration","applyRemoteConfiguration","createPreStartStrategy","ignoreInitIfSyntheticsWillInjectRum","startDeflateWorker","getCommonContext","doStartRum","bufferApiCalls","firstStartViewCall","deflateWorker","cachedInitConfiguration","cachedConfiguration","trackingConsentStateSubscription","tryStartRum","emptyContext","initialViewOptions","startRumResult","doInit","eventBridgeAvailable","overrideInitConfigurationForBridge","addTelemetryConfiguration","baseSerializedConfiguration","session_sample_rate","telemetry_sample_rate","telemetry_configuration_sample_rate","telemetry_usage_sample_rate","use_before_send","use_partitioned_cross_site_session_cookie","use_secure_session_cookie","use_proxy","silent_multiple_init","track_session_across_subdomains","track_anonymous_user","session_persistence","allow_fallback_to_local_storage","store_contexts_across_pages","allow_untrusted_events","tracking_consent","session_replay_sample_rate","start_session_replay_recording_manually","trace_sample_rate","trace_context_injection","action_name_attribute","use_allowed_tracing_urls","selected_tracing_propagators","default_privacy_level","enable_privacy_for_action_name","use_excluded_activity_urls","use_worker_url","compress_intake_requests","track_views_manually","track_user_interactions","track_resources","track_long_task","getConfigurationTelemetry","track_feature_flags_for_events","serializeRumConfiguration","tryToInit","publicApi","getInternalContext","stopSession","addTiming","time","startView","setViewName","setViewContext","setViewContextProperty","getViewContext","addAction","action","commonContext","addError","providedError","addFeatureFlagEvaluation","RUM_STORAGE_KEY","getMutationObserverConstructor","MutationObserver","originalInstance","limitModification","modifiableFieldPaths","modifier","fieldPath","fieldType","setValueAtPath","pathSegments","field","restPathSegments","isValidObject","newType","setNestedValue","VIEW_MODIFIABLE_FIELD_PATHS","USER_CUSTOMIZABLE_FIELD_PATHS","ROOT_MODIFIABLE_FIELD_PATHS","modifiableFieldPathsByEvent","startRumAssembly","viewHistory","urlContexts","displayContext","resource","WRITABLE_RESOURCE_GRAPHQL","long_task","eventRateLimiters","savedCommonContext","viewHistoryEntry","findView","urlContext","findUrl","MISSING_URL_CONTEXT_TELEMETRY","urlEntries","urlDeletedEntries","viewEntries","viewDeletedEntries","serverRumEvent","drift","browser_sdk_version","application","triggerHook","has_replay","hasReplay","sampled_for_replay","sessionReplay","user","anonymous_id","usr","account","rateLimitReached","shouldSend","LifeCycle","callbacks","eventCallbacks","VIEW_CONTEXT_TIME_OUT_DELAY","FAKE_INITIAL_DOCUMENT","RESOURCE_TYPES","initiatorType","computeResourceEntryType","isValidUrl","pathname","getPathName","isType","areInOrder","numbers","isResourceEntryRequestType","computeResourceEntryDuration","responseEnd","computeResourceEntryDetails","hasValidResourceEntryTimings","fetchStart","workerStart","redirectStart","redirectEnd","domainLookupStart","domainLookupEnd","connectStart","secureConnectionStart","connectEnd","requestStart","responseStart","details","download","formatTiming","first_byte","worker","connect","ssl","dns","redirect","hasValidResourceEntryDuration","areCommonTimingsInOrder","areRedirectionTimingsInOrder","hasRedirection","origin","computeResourceEntryProtocol","nextHopProtocol","computeResourceEntryDeliveryType","deliveryType","computeResourceEntrySize","encodedBodySize","decodedBodySize","transferSize","encoded_body_size","decoded_body_size","transfer_size","isAllowedRequestUrl","isIntakeUrl","DATA_URL_REGEX","isLongDataUrl","substring","sanitizeDataUrl","nextRequestIndex","startRequestCollection","tracer","traceFetch","headers","append","Headers","header","traceXhr","startTracer","requestIndex","getNextRequestIndex","trackXhr","clonedResponse","tryToClone","stream","reader","getReader","readBytesCount","onDone","bytes","limitExceeded","readMore","read","readBytesFromStream","POSITIVE_INFINITY","waitForResponseToComplete","trackFetch","discardNegativeDuration","trackEventCounts","isChildEvent","onChange","eventCounts","errorCount","longTaskCount","resourceCount","actionCount","frustrationCount","frustration","discarded","retrieveFirstInputTiming","startTimeStamp","timingSent","removeEventListeners","evt","cancelable","entryType","processingStart","processingEnd","sendTiming","sendTimingIfPointerIsNotCancelled","RumPerformanceEntryType","createPerformanceObservable","PerformanceObserver","handlePerformanceEntries","rumPerformanceEntries","RESOURCE","isForbiddenResource","filterRumPerformanceEntries","isObserverInitializing","getEntries","NAVIGATION","LONG_TASK","PAINT","getEntriesByType","entryTypes","stopFirstInputTiming","resourceTimingBufferFullListener","clearResourceTimings","manageResourceTimingBufferFull","supportPerformanceTimingEvent","FIRST_INPUT","supportedEntryTypes","PAGE_ACTIVITY_VALIDATION_DELAY","waitPageActivityEnd","domMutationObservable","windowOpenObservable","pageActivityEndCallback","maxDuration","pageActivityObservable","firstRequestIndex","pendingRequestsCount","notifyPageActivity","isExcludedUrl","startEvent","isBusy","createPageActivityObservable","pageActivityEndTimeoutId","hasCompleted","validationTimeoutId","complete","hadActivity","maxDurationTimeoutId","pageActivitySubscription","lastChangeTime","doWaitPageActivityEnd","requestUrl","isTextNode","Node","TEXT_NODE","isElementNode","ELEMENT_NODE","isNodeShadowHost","isNodeShadowRoot","DOCUMENT_FRAGMENT_NODE","forEachChildNodes","getParentNode","NodePrivacyLevel","IGNORE","PRIVACY_ATTR_NAME","PRIVACY_ATTR_VALUE_HIDDEN","CENSORED_STRING_MARK","CENSORED_IMG_MARK","FORM_PRIVATE_TAG_NAMES","INPUT","OUTPUT","TEXTAREA","SELECT","OPTION","DATALIST","OPTGROUP","getNodePrivacyLevel","parentNodePrivacyLevel","nodePrivacyLevel","reducePrivacyLevel","getNodeSelfPrivacyLevel","childPrivacyLevel","inputElement","autocomplete","getPrivacySelector","element","nodeName","relAttribute","getLowerCaseAttribute","nameAttribute","propertyAttribute","hasAttribute","shouldIgnoreElement","shouldMaskNode","privacyLevel","isFormElement","getTextContent","textNode","ignoreWhiteSpace","parentTagName","parentElement","DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE","getActionNameFromElementProgrammatically","targetElement","programmaticAttribute","elementWithAttribute","closest","truncate","normalizeWhitespace","priorityStrategies","userProgrammaticAttribute","labels","getActionNameFromTextualContent","nameSource","privacyEnabledActionName","getActionNameFromStandardAttribute","labelledByAttribute","refElement","ownerDocument","getElementById","label","getTextualContent","fallbackStrategies","MAX_PARENTS_TO_CONSIDER","getActionNameFromElementForStrategies","strategies","recursionCounter","strategy","actionName","trimmedName","attribute","isContentEditable","innerText","removeTextFromElements","query","querySelectorAll","textToReplace","STABLE_ATTRIBUTES","GLOBALLY_UNIQUE_SELECTOR_GETTERS","getStableAttributeSelector","isGeneratedValue","CSS","escape","UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS","classList","getSelectorFromElement","isConnected","targetElementSelector","currentElement","globallyUniqueSelector","findSelector","isSelectorUniqueGlobally","isSelectorUniqueAmongSiblings","combineSelector","getPositionSelector","getAttributeSelector","attributeName","sibling","firstElementChild","elementIndex","nextElementSibling","selectorGetters","predicate","childSelector","selectorGetter","elementSelector","currentElementSelector","isSiblingMatching","scopedSelector","MAX_DURATION_BETWEEN_CLICKS","createClickChain","firstClick","onFinalize","bufferedClicks","maxDurationBetweenClicksTimeoutId","appendClick","click","stopObservable","tryFinalize","dontAcceptMoreClick","isStopped","tryAppend","second","sqrt","pow","clientX","clientY","isSelectionEmpty","selection","getSelection","isCollapsed","isValidPointerEvent","isPrimary","computeFrustration","clicks","rageClick","getUserActivity","scroll","isRage","addFrustration","isDead","hasError","hasSelectionChanged","DEAD_CLICK_EXCLUDE_SELECTOR","hasPageActivity","CLICK_ACTION_MAX_DURATION","interactionSelectorCache","updateInteractionSelector","relativeTimestamp","trackClickActions","history","currentClickChain","stopClickChain","stopActionEventsListener","onPointerDown","onPointerUp","selectionEmptyAtPointerDown","clickContext","userActivity","listeners","localUserActivity","listenActionEvents","pointerDownEvent","clickActionBase","rect","getBoundingClientRect","defaultActionName","getActionNameFromElement","width","height","position","y","top","computeClickActionBase","hadActivityOnPointerDown","pageActivityEndEvent","processPointerDown","appendClickToClickChain","newClick","stopWaitPageActivityEnd","discard","viewEndedSubscription","endClocks","stopSubscription","startClickAction","actionContexts","findActionId","validate","finalizeClicks","historyEntry","eventCountsSubscription","activityEndTime","frustrationTypes","newActivityEndTime","frustrationType","domEvents","clickAction","counts","events","processAction","autoActionProperties","isAutoAction","loading_time","name_source","actionEvent","in_foreground","wasInPageStateAt","startErrorCollection","consoleLog","trackConsoleError","trackReportError","processError","doStartErrorCollection","handling_stack","component_stack","source_type","alreadyMatchedEntries","matchRequestResourceEntry","sameNameEntries","getEntriesByName","candidates","errorMargin","isBetween","getDocumentTraceId","traceIdMeta","traceTimeMeta","createDocumentTraceData","getDocumentTraceDataFromMeta","comment","childNodes","getTraceCommentFromNode","findTraceComment","getDocumentTraceDataFromComment","traceTime","rawTraceTime","COMMENT_NODE","isCommentNode","getNavigationEntry","navigationEntry","timings","numberKey","timingElement","computeTimingsFromDeprecatedPerformanceTiming","loadEventEnd","retrieveInitialDocumentResourceTiming","getNavigationEntryImpl","startResourceCollection","taskQueue","pendingTasks","deadline","executionTimeRemaining","scheduleNextRun","createTaskQueue","retrieveInitialDocumentResourceTimingImpl","handleResource","matchingTiming","tracingInfo","hasBeenTraced","span_id","trace_id","rule_psr","computeRequestTracingInfo","correspondingTimingOverrides","computeResourceEntryMetrics","computeRequestDuration","resourceEvent","status_code","delivery_type","performanceEntry","requestInput","requestInit","processRequest","performanceResourceSubscription","processResourceEntry","computeRawEvent","computeResourceEntryTracingInfo","entryMetrics","statusCode","responseStatus","renderBlockingStatus","render_blocking_status","trackNavigationTimings","stopOnReadyState","waitAfterLoadEvent","isIncompleteNavigation","domComplete","domContentLoaded","domContentLoadedEventEnd","domInteractive","loadEvent","firstByte","processNavigationEntry","trackFirstHidden","stopListeners","trackInitialViewMetrics","setLoadEvent","scheduleViewUpdate","initialViewMetrics","stopNavigationTracking","navigationTimings","firstHidden","stopFCPTracking","fcpEntry","trackFirstContentfulPaint","firstContentfulPaint","stopLCPTracking","firstInteractionTimestamp","stopEventListener","biggestLcpSize","performanceLcpSubscription","LARGEST_CONTENTFUL_PAINT","lcpEntry","lcpTargetSelector","resourceUrl","trackLargestContentfulPaint","largestContentfulPaint","stopFIDTracking","performanceFirstInputSubscription","firstInputEntry","firstInputDelay","firstInputTargetSelector","trackFirstInput","firstInput","trackCumulativeLayoutShift","viewStart","LAYOUT_SHIFT","biggestShift","maxClsValue","cumulatedValue","maxValue","isMaxValue","MAX_UPDATE_GAP","MAX_WINDOW_DURATION","slidingSessionWindow","performanceSubscription","hadRecentInput","attribution","WeakRef","previousRect","currentRect","deref","asRumRect","interactionCountEstimate","minKnownInteractionId","maxKnownInteractionId","getInteractionCount","interactionCount","trackInteractionToNextPaint","viewLoadingType","EVENT","PerformanceEventTiming","getInteractionToNextPaint","setViewEnd","getViewInteractionCount","stopViewInteractionCount","interactionId","durationThreshold","previousInteractionCount","computeViewInteractionCount","trackViewInteractionCount","viewEnd","longestInteractions","sortAndTrimLongestInteractions","interactionIndex","interaction","minLongestInteraction","estimateP98Interaction","trackLongestInteractions","interactionToNextPaintTargetSelector","interactionToNextPaintStartTime","interactionToNextPaint","handleEntries","newInteraction","getInteractionSelector","firstInputSubscription","eventSubscription","viewEndTime","getScrollX","scrollX","visual","visualViewport","pageLeft","offsetLeft","pageXOffset","getScrollY","scrollY","pageTop","offsetTop","pageYOffset","viewportObservable","initViewportObservable","updateDimension","getViewportDimension","createViewportObservable","scale","innerWidth","innerHeight","trackScrollMetrics","scrollValues","throttleDuration","THROTTLE_SCROLL_DURATION","scrollTop","scrollHeight","scrollingElement","documentElement","scrollDepth","computeScrollValues","ResizeObserver","throttledNotify","observerTarget","resizeObserver","eventListener","createScrollValuesObservable","maxScrollDepth","maxScrollHeight","maxScrollHeightTime","shouldUpdate","maxDepth","maxDepthScrollTop","trackCommonViewMetrics","loadingType","commonViewMetrics","stopLoadingTimeTracking","loadType","isWaitingForLoadEvent","isWaitingForActivityLoadingTime","loadingTimeCandidates","invokeCallbackIfAllCandidatesAreReceived","loadingTime","trackLoadingTime","newLoadingTime","stopScrollMetricsTracking","newScrollMetrics","stopCLSTracking","cumulativeLayoutShift","stopINPTracking","getCommonViewMetrics","SESSION_KEEP_ALIVE_INTERVAL","KEEP_TRACKING_AFTER_VIEW_DELAY","trackViews","locationChangeObservable","areViewsTrackedAutomatically","activeViews","locationChangeSubscription","currentView","startNewView","viewOptions","newlyCreatedView","initialLocation","customTimings","documentVersion","sessionIsActive","viewCreatedEvent","cancelScheduleViewUpdate","triggerViewUpdate","stopCommonViewMetricsTracking","stopInitialViewMetricsTracking","stopEventCountsTracking","trackViewEventCounts","keepAliveIntervalId","triggerBeforeViewUpdate","currentEnd","isActive","looksLikeRelativeTime","sanitized","sanitizeTiming","updatedName","newView","pageExitEvent","oldLocation","newLocation","currentLocation","otherLocation","hash","correspondingId","isHashAnAnchor","getPathFromHash","startViewCollection","pageOpenObservable","recorderApi","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","replayStats","getReplayStats","pageStates","viewEvent","document_version","replay_stats","page_states","cumulative_layout_shift","cumulative_layout_shift_time","cumulative_layout_shift_target_selector","dom_complete","dom_content_loaded","dom_interactive","first_contentful_paint","first_input_delay","first_input_time","first_input_target_selector","interaction_to_next_paint","interaction_to_next_paint_time","interaction_to_next_paint_target_selector","is_active","largest_contentful_paint","largest_contentful_paint_target_selector","load_event","loading_type","computeViewPerformanceData","time_spent","max_depth","max_depth_scroll_top","max_scroll_height","max_scroll_height_time","privacy","replay_level","custom_timings","newObject","mapValues","processViewUpdate","cls","score","target_selector","previous_rect","current_rect","fcp","fid","inp","lcp","resource_url","startRumSessionManager","rawTrackingType","hasValidRumSession","isTypeTracked","sessionEntity","setForcedReplay","rumSessionType","startRumBatch","telemetryEventObservable","createEncoder","primary","batchFactoryImp","primaryBatch","createBatchFromConfig","replicaBatch","endpoint","replicated","transformMessage","startBatchWithReplica","isTelemetryReplicationAllowed","URL_CONTEXT_TIME_OUT_DELAY","createLocationChangeObservable","stopHistoryTracking","onHistoryChange","stopInstrumentingPushState","getHistoryInstrumentationTarget","stopInstrumentingReplaceState","removeListener","trackHistory","onLocationChange","stopHashTracking","onHashChange","trackHash","History","FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY","currentPeriodMeasures","currentBatchMeasures","batchHasRumEvent","sendCurrentPeriodMeasures","batchCount","initCurrentPeriodMeasures","updateMeasure","measure","sum","mergeMeasure","batchBytesCount","batchMessagesCount","globalContextBytes","userContextBytes","featureFlagBytes","initCurrentBatchMeasures","PAGE_STATE_CONTEXT_TIME_OUT_DELAY","startPageStateHistory","maxPageStateEntriesSelectable","pageStateEntryHistory","currentPageState","addPageState","getPageState","stopEventListeners","computePageState","nextPageState","eventStartTime","pageStateEntries","pageStateServerEntries","pageState","relativeStartTime","hasFocus","createCookieObservable","cookieName","detectCookieChangeStrategy","changeEvent","changed","deleted","listenToCookieStoreChange","watchCookieFallback","WATCH_COOKIE_INTERVAL_DELAY","previousCookieValue","watchCookieIntervalId","cookieValue","CI_VISIBILITY_TEST_ID_COOKIE_NAME","startSyntheticsContext","testId","_DATADOG_SYNTHETICS_PUBLIC_ID","getSyntheticsTestId","resultId","_DATADOG_SYNTHETICS_RESULT_ID","getSyntheticsResultId","synthetics","test_id","result_id","getSessionReplayUrl","viewContext","errorType","rumConfiguration","getSiteDefaultSubdomain","getDatadogSiteUrl","statsPerView","getSegmentsCount","getOrCreateReplayStats","segments_count","records_count","segments_total_raw_size","toDelete","deleteOldestStats","createDeflateEncoder","streamId","compressedDataTrailer","compressedData","nextWriteActionId","pendingWriteActions","removeMessageListener","workerResponse","additionalBytesCount","trailer","nextPendingAction","writeCallback","byteLength","finishCallback","consumeResult","Uint8Array","buffers","total","offset","concatBuffers","sendResetIfNeeded","postMessage","pendingWriteAction","createDeflateWorker","Worker","createObjectURL","onInitializationFailure","createDeflateWorkerImpl","removeErrorListener","initializationFailureCallbacks","onTimeout","doStartDeflateWorker","getDeflateWorkerStatus","baseMessage","worker_version","stream_id","isBrowserSupported","CSSSupportsRule","NodeList","getSessionReplayLink","isRecordingStarted","getErrorType","createPostStartStrategy","loadRecorder","getOrCreateDeflateEncoder","stopRecording","doStart","async","startRecordingImpl","all","deflateEncoder","force","canStartRecording","isRecordingInProgress","shouldForceReplay","isRecording","datadogRum","startRumImpl","customerDataTrackerManager","globalContextManager","userContextManager","email","accountContextManager","currentConsent","createTrackingConsentState","buildCommonContext","onRumStart","preStartStrategy","sanitizedOptions","feature","rumPublicApi","stub","onReady","makePublicApi","setTrackingConsent","setGlobalContext","getGlobalContext","setGlobalContextProperty","removeGlobalContextProperty","clearGlobalContext","getInitConfiguration","setUser","newUser","getUser","setUserProperty","removeUserProperty","clearUser","setAccount","getAccount","setAccountProperty","removeAccountProperty","clearAccount","startSessionReplayRecording","stopSessionReplayRecording","makeRumPublicApi","hookName","unregister","createHooks","startRumTelemetry","stopBeforeUnloadListener","createPageExitObservable","startRumSessionManagerStub","startRumEventBridge","batchFlushObservable","startCustomerDataTelemetry","attributes","characterData","childList","subtree","createDOMMutationObservable","viewValueHistory","buildViewHistoryEntry","viewUpdate","startViewHistory","urlContextHistory","previousViewUrl","viewUrl","buildUrlContext","referrer","changeTime","startUrlContexts","featureFlagContexts","featureFlagContext","feature_flags","currentContext","startFeatureFlagContexts","stopWindowOpen","createWindowOpenObservable","stopRumEventCollection","actionCollection","actionId","startActionCollection","viewport","animationFrameId","requestAnimationFrame","unsubscribeViewport","viewportDimension","cancelAnimationFrame","startDisplayContext","ciVisibilityContext","cookieObservable","testExecutionId","Cypress","cookieObservableSubscription","ci_test","test_execution_id","startCiVisibilityContext","startRumEventCollection","stopViewCollection","stopResourceCollection","LONG_ANIMATION_FRAME","stopLongAnimationFrameCollection","entry_type","blocking_duration","blockingDuration","first_ui_event_timestamp","firstUIEventTimestamp","render_start","renderStart","style_and_layout_start","styleAndLayoutStart","start_time","scripts","script","pause_duration","pauseDuration","forced_style_and_layout_duration","forcedStyleAndLayoutDuration","execution_start","executionStart","source_url","sourceURL","source_function_name","sourceFunctionName","source_char_position","sourceCharPosition","invoker_type","invokerType","window_attribution","windowAttribution","startLongAnimationFrameCollection","performanceLongTaskSubscription","startLongTaskCollection","vitalCollection","internalContext","application_id","session_id","user_action","startInternalContext","shouldStartImmediately","cachedDeflateEncoder","getReplayStatsImpl","makeRecorderApi","startRecording$1","__VITE_PRELOAD__","startRecording","existingGlobalVariable","q","defineGlobal","isBrowser","isRouteComponent","applyToParams","newParams","defaults","partialOptions","HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","IM_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","commonEncode","encodeURI","encodeQueryValue","encodeParam","encodePath","decode","decodeURIComponent","TRAILING_SLASH_RE","parseURL","parseQuery$1","searchString","hashPos","searchPos","fromSegments","toSegments","lastToSegment","toPosition","segment","resolveRelativePath","fullPath","stripBase","isSameRouteRecord","aliasOf","isSameRouteLocationParams","isSameRouteLocationParamsValue","isEquivalentArray","START_LOCATION_NORMALIZED","matched","redirectedFrom","NavigationType","NavigationType$1","NavigationDirection","NavigationDirection$1","normalizeBase","baseEl","BEFORE_HASH_RE","createHref","computeScrollPosition","scrollToPosition","scrollToOptions","positionEl","isIdSelector","docRect","elRect","behavior","getElementPosition","scrollTo","getScrollKey","delta","scrollPositions","isRouteName","ErrorTypes","ErrorTypes$1","NavigationFailureSymbol","createRouterError","isNavigationFailure","MATCHER_NOT_FOUND","NAVIGATION_GUARD_REDIRECT","NAVIGATION_ABORTED","NAVIGATION_CANCELLED","NAVIGATION_DUPLICATED","parseQuery","search","searchParams","searchParam","eqPos","currentValue","stringifyQuery","value$1","normalizeQuery","normalizedQuery","matchedRouteKey","viewDepthKey","routerKey","routeLocationKey","routerViewLocationKey","useCallbacks","handlers","guardToPromiseFn","record","enterCallbackArray","enterCallbacks","valid","route","guardReturn","instances","guardCall","extractComponentsGuards","guardType","guards","rawComponent","componentPromise","resolvedComponent","mods","createCurrentLocation","location$1","slicePos","pathFromHash","buildState","back","forward","replaced","computeScroll","useHistoryStateNavigation","history$1","historyState","changeLocation","replace$1","hashIndex","currentState","createWebHistory","historyNavigation","historyListeners","teardowns","pauseState","popStateHandler","fromState","direction","unknown","beforeUnloadListener","replaceState","pauseListeners","listen","destroy","useHistoryListeners","routerHistory","go","triggerListeners","TokenType","TokenType$1","TokenizerState","TokenizerState$1","ROOT_TOKEN","VALID_PARAM_RE","BASE_PARAM_PATTERN","BASE_PATH_PARSER_OPTIONS","sensitive","strict","PathScore","PathScore$1","REGEX_CHARS_RE","compareScoreArray","diff","Segment","comparePathParserScore","aScore","bScore","abs","isLastScoreNegative","PATH_PARSER_OPTIONS_DEFAULTS","createRouteRecordMatcher","parser","pattern","segmentScores","Root","tokenIndex","token","subSegmentScore","BonusCaseSensitive","Param","repeatable","optional","regexp","re$1","BonusCustomRegExp","subPattern","Dynamic","BonusOptional","BonusRepeatable","BonusWildcard","BonusStrict","re","avoidDuplicatedSlash","tokensToParser","crash","tokens","finalizeSegment","char","customRe","consumeBuffer","ParamRegExp","ParamRegExpEnd","addCharToBuffer","EscapeNext","tokenizePath","matcher","alias","createRouterMatcher","routes","globalOptions","matchers","matcherMap","addRoute","originalRecord","isRootAdd","mainNormalizedRecord","normalizeRouteRecord","normalizedRecords","aliases","originalMatcher","normalizedRecord","connectingSlash","isAliasRecord","removeRoute","isMatchable","insertMatcher","matcherRef","lower","upper","mid","insertionAncestor","ancestor","getInsertionAncestor","pickParams","parentMatcher","mergeMetaFields","clearRoutes","getRoutes","getRecordMatcher","normalizeRecordProps","leaveGuards","updateGuards","propsObject","useLink","router","currentRoute","activeRecordIndex","routeMatched","currentMatched","parentRecordPath","getOriginalPath","outer","inner","innerValue","outerValue","includesParams","isExactActive","navigate","defaultPrevented","guardEvent","viewTransition","startViewTransition","RouterLink","compatConfig","MODE","activeClass","exactActiveClass","custom","ariaCurrentValue","elClass","getLinkClass","linkActiveClass","linkExactActiveClass","onClick","propClass","globalClass","defaultClass","slotContent","RouterView","injectedRoute","routeToDisplay","injectedDepth","initialDepth","matchedRoute","matchedRouteRef","viewRef","oldInstance","oldName","currentName","ViewComponent","routePropsOption","routeProps","createRouter","stringifyQuery$1","beforeGuards","beforeResolveGuards","afterGuards","pendingLocation","scrollBehavior","scrollRestoration","normalizeParams","paramValue","encodeParams","decodeParams","rawLocation","locationNormalized","matchedRoute$1","href$1","matcherLocation","targetParams","stringifyURL","locationAsObject","checkCanceledNavigation","pushWithRedirect","handleRedirectRecord","lastMatched","newTargetLocation","targetLocation","shouldRedirect","toLocation","failure","aLastIndex","bLastIndex","isSameRouteLocation","handleScroll","markAsReady","triggerError","failure$1","finalizeNavigation","triggerAfterEach","checkCanceledNavigationAndReject","installedApps","leavingRecords","updatingRecords","enteringRecords","recordFrom","recordTo","extractChangingRecords","canceledNavigationCheck","runGuardQueue","isPush","isFirstNavigation","removeHistoryListener","setupListeners","_from","listening","scrollPosition","ready","readyHandlers","errorListeners","resolve$1","getSavedScrollPosition","started","parentOrRoute","recordMatcher","hasRoute","routeMatcher","beforeEach","beforeResolve","afterEach","isReady","$router","reactiveRoute","unmountApp","promise","useRouter","useRoute","_name","matchIconName","stringToIcon","allowSimpleName","colonSeparated","name2","prefix","validateIconName","dashSeparated","icon","defaultIconDimensions","freeze","defaultIconTransformations","rotate","vFlip","hFlip","defaultIconProps","defaultExtendedIconProps","hidden","mergeIconData","obj1","obj2","mergeIconTransformations","internalGetIconData","tree","icons","currentProps","parseIconSet","names","not_found","getIconsTree","optionalPropertyDefaults","checkOptionalProps","quicklyValidateIconSet","dataStorage","getStorage","providerStorage","missing","newStorage","addIconSet","storage","simpleNames","allowSimpleNames","allow","addCollection","added","addIconToStorage","addIcon","defaultIconSizeCustomisations","defaultIconCustomisations","unitsSplit","unitsTest","calculateSize","ratio","precision","ceil","oldParts","newParts","regex","randomPrefix","counter","getAPIModule","createAPIConfig","resources","maxURL","dataAfterTimeout","configStorage","fallBackAPISources","fallBackAPI","addAPIProvider","customConfig","getAPIConfig","fetchModule","detectFetch","fetchAPIModule","prepare","results","maxLength","maxHostLength","calculateMaxLength","getPath","iconsList","URLSearchParams","uri","defaultError","json","shouldAbort","removeCallback","storages","items","loaderCallbacks","row","idCounter","defaultConfig","sendQuery","resourcesCount","startIndex","lastError","queriesSent","timer","doneCallbacks","resetTimer","abort","overwrite","failQuery","clearQueue","execNext","status2","queued","moduleResponse","queriesPending","initRedundancy","cfg","queries","queryCallback","doneCallback","query2","setIndex","getIndex","emptyCallback$1","redundancyCache","sendAPIQuery","redundancy","cachedReundancy","getRedundancyCache","emptyCallback","loadedNewIcons","iconsLoaderFlag","pendingCallbacksFlag","hasPending","pending","updateCallbacks","parseLoaderResponse","checkMissing","pendingIcons","parsePossiblyAsyncResponse","loadNewIcons","iconsToLoad","iconsQueueFlag","icons2","customIconLoader","loadIcon","loadIcons","invalid","checkIconNamesForAPI","sortedIcons","localeCompare","lastIcon","sortIcons","listToIcons","callCallback","newIcons","lastProvider","lastPrefix","providerNewIcons","pendingQueue","pendingSources","storeCallback","flipFromString","flip","rotateFromString","units","value2","defaultExtendedIconCustomisations","inline","svgDefaults","xmlns","role","commonProps","monotoneProps","backgroundColor","coloredProps","propsToAdd","Image","Repeat","Size","propsToAddTo","webkitMask","mask","background","customisationAliases","fixSize","attr","customisations","valueType","mergeCustomisations","componentProps","propsStyle","customStyle","color","fullIcon","fullCustomisations","box","transformations","tempValue","rotation","defs","endEnd","splitSVGDefs","wrapSVGContent","customisationsWidth","customisationsHeight","boxWidth","boxHeight","setAttr","isUnsetKeyword","viewBox","iconToSVG","renderAttribs","verticalAlign","localCounter","newID","escapedID","replaceIDs","useMask","html","renderAttribsHTML","iconToHTML","svg","encodeSVGforURL","svgToData","_window","IconifyPreload","preload","IconifyProviders","providers","emptyIcon","Icon","abortLoading","rendering","ssr","lastRenderedIconName","iconData","getIcon","iconName","getIconData","oldState","updateIconData","customise","customised","classes","serializedNodeIds","hasSerializedNode","getSerializedNodeId","getElementInputValue","URL_IN_CSS_REF","ABSOLUTE_URL","DATA_URI","switchToAbsoluteUrl","cssHref","matchingSubstring","singleQuote","urlWrappedInSingleQuotes","doubleQuote","urlWrappedInDoubleQuotes","urlNotWrappedInQuotes","quote","baseUrl","makeUrlAbsolute","TAG_NAME_REGEX","getValidTagName","processedTagName","censoredImageForSize","RecordType","NodeType","IncrementalSource","MouseInteractionType","MediaInteractionType","serializeStyleSheets","cssStyleSheets","cssStyleSheet","rules","cssRules","cssRule","media","serializeAttribute","attributeValue","image","naturalWidth","naturalHeight","getCssRulesString","getCssRuleStringForSafari","getCssRuleString","rule","isCSSStyleRule","selectorText","escapeColon","isCSSImportRule","styleSheet","serializeNodeWithId","serializedNode","DOCUMENT_NODE","serializeChildNodes","adoptedStyleSheets","serializeDocumentNode","isShadowRoot","serializationContext","shadowRootsController","addShadowRoot","serializeDocumentFragmentNode","DOCUMENT_TYPE_NODE","documentType","publicId","systemId","rr_width","rr_height","safeAttrs","formValue","optionElement","selected","stylesheet","styleSheets","_cssText","sheet","checked","mediaElement","rr_mediaState","paused","scrollLeft","elementsScrollPositions","rr_scrollLeft","rr_scrollTop","serializeAttributes","hasChildNodes","childNodesSerializationOptions","serializeElementNode","serializeTextNode","CDATA_SECTION_NODE","serializeNode","_nextId","serializedNodeWithId","serializeNodeId","setSerializedNodeId","childNode","serializedChildNode","serializeDocument","isTouchEvent","changedTouches","getEventTarget","composed","composedPath","convertMouseEventToLayoutCoordinates","layoutViewportX","layoutViewportY","visualViewportX","visualViewportY","isVisualViewportFactoredIn","getVisualViewport","assembleIncrementalSnapshot","trackMove","moveCb","updatePosition","cancelThrottle","coordinates","tryToComputeCoordinates","timeOffset","positions","isFinite","eventTypeToMouseInteraction","pointerup","mousedown","contextmenu","dblclick","focus","blur","touchstart","touchend","trackMouseInteraction","mouseInteractionCb","recordIds","getIdForEvent","trackScroll","scrollCb","trackViewportResize","viewportResizeCb","viewportResizeSubscription","trackVisualViewportResize","visualViewportResizeCb","trackMediaInteraction","mediaInteractionCb","trackStyleSheet","styleSheetCb","checkStyleSheetAndCallback","ownerNode","instrumentationStoppers","CSSStyleSheet","adds","removes","instrumentGroupingCSSRuleClass","parentStyleSheet","getPathToNestedCSSRule","CSSGroupingRule","CSSMediaRule","stopper","currentRule","parentRule","trackFocus","focusCb","has_focus","trackFrustration","frustrationCb","frustrationSubscription","trackViewEnd","viewEndCb","viewEndSubscription","trackInput","inputCb","lastInputStateMap","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","onElementChange","stopPropertySetterInstrumentation","inputState","isChecked","cbWithDedup","lastInputState","trackMutation","mutationCallback","mutationBatch","processMutationBatch","cancelScheduledFlush","pendingMutations","throttledFlush","addMutations","mutations","createMutationBatch","nodePrivacyLevelCache","mutation","removedNodes","removedNode","traverseRemovedShadowDom","removeShadowRoot","filteredMutations","nodeAndAncestorsHaveSerializedNode","hasBeenSerialized","addedAndMovedNodes","addedNodes","sortedAddedAndMovedNodes","nodes","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","addedNodeMutations","nextId","getNextSibling","parentId","removedNodeMutations","processChildListMutations","texts","textMutations","handledNodes","processCharacterDataMutations","attributeMutations","handledElements","handledAttributes","emittedMutations","transformedValue","inputValue","emittedMutation","processAttributesMutations","processMutations","takeRecords","attributeOldValue","characterDataOldValue","shadowDomRemovedCallback","emitAndComputeStats","scrollPositionsByElement","createElementsScrollPositions","controllerByShadowRoot","mutationTracker","inputTracker","scrollTracker","initShadowRootsController","stopFullSnapshots","flushMutations","fullSnapshotCallback","takeFullSnapshot","records","initialOffset","startFullSnapshots","initRecordIds","trackers","viewEndRecord","createSegment","creationReason","encodedBytesCount","metadata","creation_reason","has_full_snapshot","index_in_view","replayStats.getSegmentsCount","replayStats.addSegment","addRecord","replayStats.addWroteData","SEGMENT_BYTES_LIMIT","startSegmentCollection","httpRequest","getSegmentContext","nextSegmentCreationReason","unsubscribeViewCreated","flushSegment","unsubscribePageExited","rawSegmentBytesCount","formData","FormData","metadataAndSegmentSizes","raw_segment_size","compressed_segment_size","serializedMetadataAndSegmentSizes","buildReplayPayload","expirationTimeoutId","doStartSegmentCollection","computeSegmentContext","replayRequest","startRecordBridge","segmentCollection"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203],"sources":["../../node_modules/@vue/shared/dist/shared.esm-bundler.js","../../node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","../../node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js","../../node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js","../../node_modules/@datadog/browser-core/esm/tools/display.js","../../node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js","../../node_modules/@datadog/browser-core/esm/tools/utils/numberUtils.js","../../node_modules/@datadog/browser-core/esm/tools/utils/timeUtils.js","../../node_modules/@datadog/browser-core/esm/tools/utils/byteUtils.js","../../node_modules/@datadog/browser-core/esm/tools/utils/objectUtils.js","../../node_modules/@datadog/browser-core/esm/tools/getGlobalObject.js","../../node_modules/@datadog/browser-core/esm/tools/getZoneJsOriginalValue.js","../../node_modules/@datadog/browser-core/esm/tools/monitor.js","../../node_modules/@datadog/browser-core/esm/tools/timer.js","../../node_modules/@datadog/browser-core/esm/tools/observable.js","../../node_modules/@datadog/browser-core/esm/tools/utils/functionUtils.js","../../node_modules/@datadog/browser-core/esm/tools/utils/stringUtils.js","../../node_modules/@datadog/browser-core/esm/tools/utils/browserDetection.js","../../node_modules/@datadog/browser-core/esm/browser/cookie.js","../../node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionStoreStrategy.js","../../node_modules/@datadog/browser-core/esm/tools/utils/polyfills.js","../../node_modules/@datadog/browser-core/esm/domain/session/sessionConstants.js","../../node_modules/@datadog/browser-core/esm/domain/session/sessionStateValidation.js","../../node_modules/@datadog/browser-core/esm/domain/session/sessionState.js","../../node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionInCookie.js","../../node_modules/@datadog/browser-core/esm/domain/session/oldCookiesMigration.js","../../node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionInLocalStorage.js","../../node_modules/@datadog/browser-core/esm/domain/session/sessionStoreOperations.js","../../node_modules/@datadog/browser-core/esm/domain/session/sessionStore.js","../../node_modules/@datadog/browser-core/esm/domain/trackingConsent.js","../../node_modules/@datadog/browser-core/esm/tools/serialisation/jsonStringify.js","../../node_modules/@datadog/browser-core/esm/tools/utils/urlPolyfill.js","../../node_modules/@datadog/browser-core/esm/domain/configuration/intakeSites.js","../../node_modules/@datadog/browser-core/esm/domain/configuration/endpointBuilder.js","../../node_modules/@datadog/browser-core/esm/domain/configuration/tags.js","../../node_modules/@datadog/browser-core/esm/domain/configuration/transportConfiguration.js","../../node_modules/@datadog/browser-core/esm/domain/configuration/configuration.js","../../node_modules/@datadog/browser-core/esm/tools/experimentalFeatures.js","../../node_modules/@datadog/browser-core/esm/tools/stackTrace/computeStackTrace.js","../../node_modules/@datadog/browser-core/esm/tools/stackTrace/handlingStack.js","../../node_modules/@datadog/browser-core/esm/tools/instrumentMethod.js","../../node_modules/@datadog/browser-core/esm/tools/serialisation/sanitize.js","../../node_modules/@datadog/browser-core/esm/domain/error/error.js","../../node_modules/@datadog/browser-core/esm/domain/error/error.types.js","../../node_modules/@datadog/browser-core/esm/domain/error/trackRuntimeError.js","../../node_modules/@datadog/browser-core/esm/boot/displayAlreadyInitializedError.js","../../node_modules/@datadog/browser-core/esm/browser/addEventListener.js","../../node_modules/@datadog/browser-core/esm/domain/report/reportObservable.js","../../node_modules/@datadog/browser-core/esm/tools/sendToExtension.js","../../node_modules/@datadog/browser-core/esm/tools/utils/typeUtils.js","../../node_modules/@datadog/browser-core/esm/tools/mergeInto.js","../../node_modules/@datadog/browser-core/esm/domain/connectivity/connectivity.js","../../node_modules/@datadog/browser-core/esm/tools/utils/arrayUtils.js","../../node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js","../../node_modules/@datadog/browser-core/esm/domain/telemetry/rawTelemetryEvent.types.js","../../node_modules/@datadog/browser-core/esm/domain/telemetry/telemetry.js","../../node_modules/@datadog/browser-core/esm/tools/valueHistory.js","../../node_modules/@datadog/browser-core/esm/domain/session/sessionManager.js","../../node_modules/@datadog/browser-core/esm/transport/sendWithRetryStrategy.js","../../node_modules/@datadog/browser-core/esm/tools/utils/responseUtils.js","../../node_modules/@datadog/browser-core/esm/transport/httpRequest.js","../../node_modules/@datadog/browser-core/esm/transport/eventBridge.js","../../node_modules/@datadog/browser-core/esm/browser/pageExitObservable.js","../../node_modules/@datadog/browser-core/esm/transport/batch.js","../../node_modules/@datadog/browser-core/esm/transport/flushController.js","../../node_modules/@datadog/browser-core/esm/tools/encoder.js","../../node_modules/@datadog/browser-core/esm/domain/eventRateLimiter/createEventRateLimiter.js","../../node_modules/@datadog/browser-core/esm/browser/runOnReadyState.js","../../node_modules/@datadog/browser-core/esm/browser/xhrObservable.js","../../node_modules/@datadog/browser-core/esm/browser/fetchObservable.js","../../node_modules/@datadog/browser-core/esm/tools/requestIdleCallback.js","../../node_modules/@datadog/browser-core/esm/domain/console/consoleObservable.js","../../node_modules/@datadog/browser-core/esm/domain/context/contextManager.js","../../node_modules/@datadog/browser-core/esm/domain/context/contextUtils.js","../../node_modules/@datadog/browser-core/esm/domain/context/storeContextManager.js","../../node_modules/@datadog/browser-core/esm/domain/context/customerDataTracker.js","../../node_modules/@datadog/browser-core/esm/domain/synthetics/syntheticsWorkerValues.js","../../node_modules/@datadog/browser-core/esm/tools/matchOption.js","../../node_modules/@datadog/browser-rum-core/esm/domain/vital/vitalCollection.js","../../node_modules/@datadog/browser-rum-core/esm/domain/plugins.js","../../node_modules/@datadog/browser-rum-core/esm/domain/tracing/identifier.js","../../node_modules/@datadog/browser-rum-core/esm/domain/tracing/sampler.js","../../node_modules/@datadog/browser-rum-core/esm/domain/tracing/tracer.js","../../node_modules/@datadog/browser-rum-core/esm/domain/configuration/configuration.js","../../node_modules/@datadog/browser-rum-core/esm/domain/configuration/remoteConfiguration.js","../../node_modules/@datadog/browser-rum-core/esm/boot/preStartRum.js","../../node_modules/@datadog/browser-rum-core/esm/boot/rumPublicApi.js","../../node_modules/@datadog/browser-rum-core/esm/browser/domMutationObservable.js","../../node_modules/@datadog/browser-rum-core/esm/domain/limitModification.js","../../node_modules/@datadog/browser-rum-core/esm/domain/assembly.js","../../node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js","../../node_modules/@datadog/browser-core/esm/tools/abstractLifeCycle.js","../../node_modules/@datadog/browser-rum-core/esm/domain/contexts/viewHistory.js","../../node_modules/@datadog/browser-rum-core/esm/domain/resource/resourceUtils.js","../../node_modules/@datadog/browser-rum-core/esm/domain/requestCollection.js","../../node_modules/@datadog/browser-core/esm/tools/readBytesFromStream.js","../../node_modules/@datadog/browser-rum-core/esm/domain/discardNegativeDuration.js","../../node_modules/@datadog/browser-rum-core/esm/domain/trackEventCounts.js","../../node_modules/@datadog/browser-rum-core/esm/browser/firstInputPolyfill.js","../../node_modules/@datadog/browser-rum-core/esm/browser/performanceObservable.js","../../node_modules/@datadog/browser-rum-core/esm/domain/waitPageActivityEnd.js","../../node_modules/@datadog/browser-rum-core/esm/browser/htmlDomUtils.js","../../node_modules/@datadog/browser-rum-core/esm/domain/privacy.js","../../node_modules/@datadog/browser-rum-core/esm/domain/action/getActionNameFromElement.js","../../node_modules/@datadog/browser-rum-core/esm/domain/getSelectorFromElement.js","../../node_modules/@datadog/browser-rum-core/esm/domain/action/clickChain.js","../../node_modules/@datadog/browser-rum-core/esm/domain/action/listenActionEvents.js","../../node_modules/@datadog/browser-rum-core/esm/domain/action/computeFrustration.js","../../node_modules/@datadog/browser-rum-core/esm/domain/action/interactionSelectorCache.js","../../node_modules/@datadog/browser-rum-core/esm/domain/action/trackClickActions.js","../../node_modules/@datadog/browser-rum-core/esm/domain/action/actionCollection.js","../../node_modules/@datadog/browser-rum-core/esm/domain/error/errorCollection.js","../../node_modules/@datadog/browser-rum-core/esm/domain/error/trackConsoleError.js","../../node_modules/@datadog/browser-rum-core/esm/domain/error/trackReportError.js","../../node_modules/@datadog/browser-rum-core/esm/domain/resource/matchRequestResourceEntry.js","../../node_modules/@datadog/browser-rum-core/esm/domain/tracing/getDocumentTraceId.js","../../node_modules/@datadog/browser-rum-core/esm/browser/performanceUtils.js","../../node_modules/@datadog/browser-rum-core/esm/domain/resource/retrieveInitialDocumentResourceTiming.js","../../node_modules/@datadog/browser-rum-core/esm/domain/resource/resourceCollection.js","../../node_modules/@datadog/browser-core/esm/tools/taskQueue.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackNavigationTimings.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackFirstHidden.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackInitialViewMetrics.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackFirstContentfulPaint.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackLargestContentfulPaint.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackFirstInput.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackCumulativeLayoutShift.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/interactionCountPolyfill.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackInteractionToNextPaint.js","../../node_modules/@datadog/browser-rum-core/esm/browser/scroll.js","../../node_modules/@datadog/browser-rum-core/esm/browser/viewportObservable.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackScrollMetrics.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackCommonViewMetrics.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewMetrics/trackLoadingTime.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/trackViews.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/trackViewEventCounts.js","../../node_modules/@datadog/browser-rum-core/esm/domain/view/viewCollection.js","../../node_modules/@datadog/browser-rum-core/esm/domain/rumSessionManager.js","../../node_modules/@datadog/browser-rum-core/esm/transport/startRumBatch.js","../../node_modules/@datadog/browser-core/esm/transport/startBatchWithReplica.js","../../node_modules/@datadog/browser-rum-core/esm/domain/contexts/urlContexts.js","../../node_modules/@datadog/browser-rum-core/esm/browser/locationChangeObservable.js","../../node_modules/@datadog/browser-rum-core/esm/domain/contexts/featureFlagContext.js","../../node_modules/@datadog/browser-rum-core/esm/domain/startCustomerDataTelemetry.js","../../node_modules/@datadog/browser-rum-core/esm/domain/contexts/pageStateHistory.js","../../node_modules/@datadog/browser-rum-core/esm/browser/cookieObservable.js","../../node_modules/@datadog/browser-rum-core/esm/domain/contexts/ciVisibilityContext.js","../../node_modules/@datadog/browser-rum-core/esm/domain/contexts/syntheticsContext.js","../../node_modules/@datadog/browser-rum-core/esm/domain/getSessionReplayUrl.js","../../node_modules/@datadog/browser-rum/esm/domain/replayStats.js","../../node_modules/@datadog/browser-rum/esm/domain/deflate/deflateEncoder.js","../../node_modules/@datadog/browser-rum/esm/domain/deflate/deflateWorker.js","../../node_modules/@datadog/browser-rum/esm/boot/isBrowserSupported.js","../../node_modules/@datadog/browser-rum/esm/domain/getSessionReplayLink.js","../../node_modules/@datadog/browser-rum/esm/boot/postStartStrategy.js","../../node_modules/@datadog/browser-rum/esm/entries/main.js","../../node_modules/@datadog/browser-rum-core/esm/domain/contexts/commonContext.js","../../node_modules/@datadog/browser-core/esm/boot/init.js","../../node_modules/@datadog/browser-rum-core/esm/boot/startRum.js","../../node_modules/@datadog/browser-rum-core/esm/hooks.js","../../node_modules/@datadog/browser-rum-core/esm/transport/startRumEventBridge.js","../../node_modules/@datadog/browser-rum-core/esm/browser/windowOpenObservable.js","../../node_modules/@datadog/browser-rum-core/esm/domain/contexts/displayContext.js","../../node_modules/@datadog/browser-rum-core/esm/domain/longAnimationFrame/longAnimationFrameCollection.js","../../node_modules/@datadog/browser-rum-core/esm/domain/longTask/longTaskCollection.js","../../node_modules/@datadog/browser-rum-core/esm/domain/contexts/internalContext.js","../../node_modules/@datadog/browser-rum/esm/boot/recorderApi.js","../../node_modules/@datadog/browser-rum/esm/boot/preStartStrategy.js","../../node_modules/@datadog/browser-rum/esm/boot/lazyLoadRecorder.js","../../node_modules/vue-router/dist/devtools-BLCumUwL.mjs","../../node_modules/vue-router/dist/vue-router.mjs","../../node_modules/@iconify/vue/dist/iconify.mjs","../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializationUtils.js","../../node_modules/@datadog/browser-rum/esm/types/sessionReplayConstants.js","../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeStyleSheets.js","../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttribute.js","../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttributes.js","../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeNode.js","../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeDocument.js","../../node_modules/@datadog/browser-rum/esm/domain/record/eventsUtils.js","../../node_modules/@datadog/browser-rum/esm/domain/record/viewports.js","../../node_modules/@datadog/browser-rum/esm/domain/record/assembly.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMove.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMouseInteraction.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackScroll.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewportResize.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMediaInteraction.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackStyleSheet.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFocus.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFrustration.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewEnd.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackInput.js","../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMutation.js","../../node_modules/@datadog/browser-rum/esm/domain/record/mutationBatch.js","../../node_modules/@datadog/browser-rum/esm/domain/record/record.js","../../node_modules/@datadog/browser-rum/esm/domain/record/elementsScrollPositions.js","../../node_modules/@datadog/browser-rum/esm/domain/record/shadowRootsController.js","../../node_modules/@datadog/browser-rum/esm/domain/record/startFullSnapshots.js","../../node_modules/@datadog/browser-rum/esm/domain/record/recordIds.js","../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segment.js","../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segmentCollection.js","../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/buildReplayPayload.js","../../node_modules/@datadog/browser-rum/esm/boot/startRecording.js","../../node_modules/@datadog/browser-rum/esm/domain/startRecordBridge.js"],"sourcesContent":["/**\n* @vue/shared v3.5.24\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const key of str.split(\",\")) map[key] = 1;\n  return (val) => val in map;\n}\n\nconst EMPTY_OBJ = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze({}) : {};\nconst EMPTY_ARR = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze([]) : [];\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter\n(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return ((str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  });\n};\nconst camelizeRE = /-\\w/g;\nconst camelize = cacheStringFunction(\n  (str) => {\n    return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());\n  }\n);\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction(\n  (str) => {\n    const s = str ? `on${capitalize(str)}` : ``;\n    return s;\n  }\n);\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, ...arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](...arg);\n  }\n};\nconst def = (obj, key, value, writable = false) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\nfunction genCacheKey(source, options) {\n  return source + JSON.stringify(\n    options,\n    (_, val) => typeof val === \"function\" ? val.toString() : val\n  );\n}\n\nconst PatchFlags = {\n  \"TEXT\": 1,\n  \"1\": \"TEXT\",\n  \"CLASS\": 2,\n  \"2\": \"CLASS\",\n  \"STYLE\": 4,\n  \"4\": \"STYLE\",\n  \"PROPS\": 8,\n  \"8\": \"PROPS\",\n  \"FULL_PROPS\": 16,\n  \"16\": \"FULL_PROPS\",\n  \"NEED_HYDRATION\": 32,\n  \"32\": \"NEED_HYDRATION\",\n  \"STABLE_FRAGMENT\": 64,\n  \"64\": \"STABLE_FRAGMENT\",\n  \"KEYED_FRAGMENT\": 128,\n  \"128\": \"KEYED_FRAGMENT\",\n  \"UNKEYED_FRAGMENT\": 256,\n  \"256\": \"UNKEYED_FRAGMENT\",\n  \"NEED_PATCH\": 512,\n  \"512\": \"NEED_PATCH\",\n  \"DYNAMIC_SLOTS\": 1024,\n  \"1024\": \"DYNAMIC_SLOTS\",\n  \"DEV_ROOT_FRAGMENT\": 2048,\n  \"2048\": \"DEV_ROOT_FRAGMENT\",\n  \"CACHED\": -1,\n  \"-1\": \"CACHED\",\n  \"BAIL\": -2,\n  \"-2\": \"BAIL\"\n};\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `CACHED`,\n  [-2]: `BAIL`\n};\n\nconst ShapeFlags = {\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"FUNCTIONAL_COMPONENT\": 2,\n  \"2\": \"FUNCTIONAL_COMPONENT\",\n  \"STATEFUL_COMPONENT\": 4,\n  \"4\": \"STATEFUL_COMPONENT\",\n  \"TEXT_CHILDREN\": 8,\n  \"8\": \"TEXT_CHILDREN\",\n  \"ARRAY_CHILDREN\": 16,\n  \"16\": \"ARRAY_CHILDREN\",\n  \"SLOTS_CHILDREN\": 32,\n  \"32\": \"SLOTS_CHILDREN\",\n  \"TELEPORT\": 64,\n  \"64\": \"TELEPORT\",\n  \"SUSPENSE\": 128,\n  \"128\": \"SUSPENSE\",\n  \"COMPONENT_SHOULD_KEEP_ALIVE\": 256,\n  \"256\": \"COMPONENT_SHOULD_KEEP_ALIVE\",\n  \"COMPONENT_KEPT_ALIVE\": 512,\n  \"512\": \"COMPONENT_KEPT_ALIVE\",\n  \"COMPONENT\": 6,\n  \"6\": \"COMPONENT\"\n};\n\nconst SlotFlags = {\n  \"STABLE\": 1,\n  \"1\": \"STABLE\",\n  \"DYNAMIC\": 2,\n  \"2\": \"DYNAMIC\",\n  \"FORWARDED\": 3,\n  \"3\": \"FORWARDED\"\n};\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol\";\nconst isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  start = Math.max(0, Math.min(start, source.length));\n  end = Math.max(0, Math.min(end, source.length));\n  if (start > end) return \"\";\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  if (!styles) return \"\";\n  if (isString(styles)) return styles;\n  let ret = \"\";\n  for (const key in styles) {\n    const value = styles[key];\n    if (isString(value) || typeof value === \"number\") {\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst MATH_TAGS = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\nconst isKnownMathMLAttr = /* @__PURE__ */ makeMap(\n  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`\n);\nfunction isRenderableAttrValue(value) {\n  if (value == null) {\n    return false;\n  }\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"boolean\";\n}\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\nconst cssVarNameEscapeSymbolsRE = /[ !\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~]/g;\nfunction getEscapedCssVarName(key, doubleEscape) {\n  return key.replace(\n    cssVarNameEscapeSymbolsRE,\n    (s) => doubleEscape ? s === '\"' ? '\\\\\\\\\\\\\"' : `\\\\\\\\${s}` : `\\\\${s}`\n  );\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst isRef = (val) => {\n  return !!(val && val[\"__v_isRef\"] === true);\n};\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (isRef(val)) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce(\n        (entries, [key, val2], i) => {\n          entries[stringifySymbol(key, i) + \" =>\"] = val2;\n          return entries;\n        },\n        {}\n      )\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))\n    };\n  } else if (isSymbol(val)) {\n    return stringifySymbol(val);\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst stringifySymbol = (v, i = \"\") => {\n  var _a;\n  return (\n    // Symbol.description in es2019+ so we need to cast here to pass\n    // the lib: es2016 check\n    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v\n  );\n};\n\nfunction normalizeCssVarValue(value) {\n  if (value == null) {\n    return \"initial\";\n  }\n  if (typeof value === \"string\") {\n    return value === \"\" ? \" \" : value;\n  }\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      console.warn(\n        \"[Vue warn] Invalid value used for CSS binding. Expected a string or a finite number but received:\",\n        value\n      );\n    }\n  }\n  return String(value);\n}\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, PatchFlags, ShapeFlags, SlotFlags, camelize, capitalize, cssVarNameEscapeSymbolsRE, def, escapeHtml, escapeHtmlComment, extend, genCacheKey, genPropsAccessExp, generateCodeFrame, getEscapedCssVarName, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyAllowed, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownMathMLAttr, isKnownSvgAttr, isMap, isMathMLTag, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isRenderableAttrValue, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeCssVarValue, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","/**\n* @vue/reactivity v3.5.24\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { extend, hasChanged, isArray, isIntegerKey, isSymbol, isMap, hasOwn, makeMap, isObject, capitalize, toRawType, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, remove, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal track `on` calls, allow `on` call multiple times\n     */\n    this._on = 0;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    if (++this._on === 1) {\n      this.prevScope = activeEffectScope;\n      activeEffectScope = this;\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    if (this._on > 0 && --this._on === 0) {\n      activeEffectScope = this.prevScope;\n      this.prevScope = void 0;\n    }\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\",\n  \"EVALUATED\": 128,\n  \"128\": \"EVALUATED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= -65;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= -3;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= -2;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= -17;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {\n    return;\n  }\n  computed.flags |= 2;\n  const dep = computed.dep;\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed.flags |= 128;\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= -3;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= -5;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  // TODO isolatedDeclarations \"__v_skip\"\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    /**\n     * @internal\n     */\n    this.__v_skip = true;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(\n        extend(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\"\n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\"\n);\nconst ARRAY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\"\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimization required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (!result.done) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      const value = targetIsArray && isIntegerKey(key) ? res : res.value;\n      return isReadonly2 && isObject(value) ? readonly(value) : value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn(\n              `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n              target[key]\n            );\n          }\n          return true;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return target.size;\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(\n    instrumentations,\n    readonly ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : void 0;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, void 0, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            void 0,\n            void 0,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\n\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          oldValue = newValue;\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Map();\n  if ((seen.get(value) || 0) >= depth) {\n    return value;\n  }\n  seen.set(value, depth);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };\n","/**\n* @vue/runtime-core v3.5.24\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { pauseTracking, resetTracking, isRef, toRaw, traverse, shallowRef, readonly, isReactive, ref, isShallow, isReadonly, shallowReadArray, toReadonly, toReactive, shallowReadonly, track, reactive, shallowReactive, trigger, ReactiveEffect, watch as watch$1, customRef, isProxy, proxyRefs, markRaw, EffectScope, computed as computed$1 } from '@vue/reactivity';\nexport { EffectScope, ReactiveEffect, TrackOpTypes, TriggerOpTypes, customRef, effect, effectScope, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, onWatcherCleanup, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, triggerRef, unref } from '@vue/reactivity';\nimport { isString, isFunction, EMPTY_OBJ, isPromise, isArray, NOOP, getGlobalThis, extend, isBuiltInDirective, NO, hasOwn, remove, def, isOn, isReservedProp, normalizeClass, stringifyStyle, normalizeStyle, isKnownSvgAttr, isBooleanAttr, isKnownHtmlAttr, includeBooleanAttr, isRenderableAttrValue, normalizeCssVarValue, getEscapedCssVarName, isObject, isRegExp, invokeArrayFns, toHandlerKey, camelize, capitalize, isSymbol, isGloballyAllowed, EMPTY_ARR, hyphenate, makeMap, toRawType, hasChanged, looseToNumber, isModelListener, toNumber } from '@vue/shared';\nexport { camelize, capitalize, normalizeClass, normalizeProps, normalizeStyle, toDisplayString, toHandlerKey } from '@vue/shared';\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n  stack.push(vnode);\n}\nfunction popWarningContext() {\n  stack.pop();\n}\nlet isWarning = false;\nfunction warn$1(msg, ...args) {\n  if (isWarning) return;\n  isWarning = true;\n  pauseTracking();\n  const instance = stack.length ? stack[stack.length - 1].component : null;\n  const appWarnHandler = instance && instance.appContext.config.warnHandler;\n  const trace = getComponentTrace();\n  if (appWarnHandler) {\n    callWithErrorHandling(\n      appWarnHandler,\n      instance,\n      11,\n      [\n        // eslint-disable-next-line no-restricted-syntax\n        msg + args.map((a) => {\n          var _a, _b;\n          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);\n        }).join(\"\"),\n        instance && instance.proxy,\n        trace.map(\n          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`\n        ).join(\"\\n\"),\n        trace\n      ]\n    );\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n    if (trace.length && // avoid spamming console during tests\n    true) {\n      warnArgs.push(`\n`, ...formatTrace(trace));\n    }\n    console.warn(...warnArgs);\n  }\n  resetTracking();\n  isWarning = false;\n}\nfunction getComponentTrace() {\n  let currentVNode = stack[stack.length - 1];\n  if (!currentVNode) {\n    return [];\n  }\n  const normalizedStack = [];\n  while (currentVNode) {\n    const last = normalizedStack[0];\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++;\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode,\n        recurseCount: 0\n      });\n    }\n    const parentInstance = currentVNode.component && currentVNode.component.parent;\n    currentVNode = parentInstance && parentInstance.vnode;\n  }\n  return normalizedStack;\n}\nfunction formatTrace(trace) {\n  const logs = [];\n  trace.forEach((entry, i) => {\n    logs.push(...i === 0 ? [] : [`\n`], ...formatTraceEntry(entry));\n  });\n  return logs;\n}\nfunction formatTraceEntry({ vnode, recurseCount }) {\n  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n  const isRoot = vnode.component ? vnode.component.parent == null : false;\n  const open = ` at <${formatComponentName(\n    vnode.component,\n    vnode.type,\n    isRoot\n  )}`;\n  const close = `>` + postfix;\n  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];\n}\nfunction formatProps(props) {\n  const res = [];\n  const keys = Object.keys(props);\n  keys.slice(0, 3).forEach((key) => {\n    res.push(...formatProp(key, props[key]));\n  });\n  if (keys.length > 3) {\n    res.push(` ...`);\n  }\n  return res;\n}\nfunction formatProp(key, value, raw) {\n  if (isString(value)) {\n    value = JSON.stringify(value);\n    return raw ? value : [`${key}=${value}`];\n  } else if (typeof value === \"number\" || typeof value === \"boolean\" || value == null) {\n    return raw ? value : [`${key}=${value}`];\n  } else if (isRef(value)) {\n    value = formatProp(key, toRaw(value.value), true);\n    return raw ? value : [`${key}=Ref<`, value, `>`];\n  } else if (isFunction(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n  } else {\n    value = toRaw(value);\n    return raw ? value : [`${key}=`, value];\n  }\n}\nfunction assertNumber(val, type) {\n  if (!!!(process.env.NODE_ENV !== \"production\")) return;\n  if (val === void 0) {\n    return;\n  } else if (typeof val !== \"number\") {\n    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);\n  } else if (isNaN(val)) {\n    warn$1(`${type} is NaN - the duration expression might be incorrect.`);\n  }\n}\n\nconst ErrorCodes = {\n  \"SETUP_FUNCTION\": 0,\n  \"0\": \"SETUP_FUNCTION\",\n  \"RENDER_FUNCTION\": 1,\n  \"1\": \"RENDER_FUNCTION\",\n  \"NATIVE_EVENT_HANDLER\": 5,\n  \"5\": \"NATIVE_EVENT_HANDLER\",\n  \"COMPONENT_EVENT_HANDLER\": 6,\n  \"6\": \"COMPONENT_EVENT_HANDLER\",\n  \"VNODE_HOOK\": 7,\n  \"7\": \"VNODE_HOOK\",\n  \"DIRECTIVE_HOOK\": 8,\n  \"8\": \"DIRECTIVE_HOOK\",\n  \"TRANSITION_HOOK\": 9,\n  \"9\": \"TRANSITION_HOOK\",\n  \"APP_ERROR_HANDLER\": 10,\n  \"10\": \"APP_ERROR_HANDLER\",\n  \"APP_WARN_HANDLER\": 11,\n  \"11\": \"APP_WARN_HANDLER\",\n  \"FUNCTION_REF\": 12,\n  \"12\": \"FUNCTION_REF\",\n  \"ASYNC_COMPONENT_LOADER\": 13,\n  \"13\": \"ASYNC_COMPONENT_LOADER\",\n  \"SCHEDULER\": 14,\n  \"14\": \"SCHEDULER\",\n  \"COMPONENT_UPDATE\": 15,\n  \"15\": \"COMPONENT_UPDATE\",\n  \"APP_UNMOUNT_CLEANUP\": 16,\n  \"16\": \"APP_UNMOUNT_CLEANUP\"\n};\nconst ErrorTypeStrings$1 = {\n  [\"sp\"]: \"serverPrefetch hook\",\n  [\"bc\"]: \"beforeCreate hook\",\n  [\"c\"]: \"created hook\",\n  [\"bm\"]: \"beforeMount hook\",\n  [\"m\"]: \"mounted hook\",\n  [\"bu\"]: \"beforeUpdate hook\",\n  [\"u\"]: \"updated\",\n  [\"bum\"]: \"beforeUnmount hook\",\n  [\"um\"]: \"unmounted hook\",\n  [\"a\"]: \"activated hook\",\n  [\"da\"]: \"deactivated hook\",\n  [\"ec\"]: \"errorCaptured hook\",\n  [\"rtc\"]: \"renderTracked hook\",\n  [\"rtg\"]: \"renderTriggered hook\",\n  [0]: \"setup function\",\n  [1]: \"render function\",\n  [2]: \"watcher getter\",\n  [3]: \"watcher callback\",\n  [4]: \"watcher cleanup function\",\n  [5]: \"native event handler\",\n  [6]: \"component event handler\",\n  [7]: \"vnode hook\",\n  [8]: \"directive hook\",\n  [9]: \"transition hook\",\n  [10]: \"app errorHandler\",\n  [11]: \"app warnHandler\",\n  [12]: \"ref function\",\n  [13]: \"async component loader\",\n  [14]: \"scheduler flush\",\n  [15]: \"component update\",\n  [16]: \"app unmount cleanup function\"\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n  try {\n    return args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n}\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n    if (res && isPromise(res)) {\n      res.catch((err) => {\n        handleError(err, instance, type);\n      });\n    }\n    return res;\n  }\n  if (isArray(fn)) {\n    const values = [];\n    for (let i = 0; i < fn.length; i++) {\n      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n    }\n    return values;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(\n      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`\n    );\n  }\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;\n  if (instance) {\n    let cur = instance.parent;\n    const exposedInstance = instance.proxy;\n    const errorInfo = !!(process.env.NODE_ENV !== \"production\") ? ErrorTypeStrings$1[type] : `https://vuejs.org/error-reference/#runtime-${type}`;\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n      cur = cur.parent;\n    }\n    if (errorHandler) {\n      pauseTracking();\n      callWithErrorHandling(errorHandler, null, 10, [\n        err,\n        exposedInstance,\n        errorInfo\n      ]);\n      resetTracking();\n      return;\n    }\n  }\n  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);\n}\nfunction logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const info = ErrorTypeStrings$1[type];\n    if (contextVNode) {\n      pushWarningContext(contextVNode);\n    }\n    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n    if (contextVNode) {\n      popWarningContext();\n    }\n    if (throwInDev) {\n      throw err;\n    } else {\n      console.error(err);\n    }\n  } else if (throwInProd) {\n    throw err;\n  } else {\n    console.error(err);\n  }\n}\n\nconst queue = [];\nlet flushIndex = -1;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /* @__PURE__ */ Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\nfunction findInsertionIndex(id) {\n  let start = flushIndex + 1;\n  let end = queue.length;\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJob = queue[middle];\n    const middleJobId = getId(middleJob);\n    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {\n      start = middle + 1;\n    } else {\n      end = middle;\n    }\n  }\n  return start;\n}\nfunction queueJob(job) {\n  if (!(job.flags & 1)) {\n    const jobId = getId(job);\n    const lastJob = queue[queue.length - 1];\n    if (!lastJob || // fast path when the job id is larger than the tail\n    !(job.flags & 2) && jobId >= getId(lastJob)) {\n      queue.push(job);\n    } else {\n      queue.splice(findInsertionIndex(jobId), 0, job);\n    }\n    job.flags |= 1;\n    queueFlush();\n  }\n}\nfunction queueFlush() {\n  if (!currentFlushPromise) {\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\nfunction queuePostFlushCb(cb) {\n  if (!isArray(cb)) {\n    if (activePostFlushCbs && cb.id === -1) {\n      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);\n    } else if (!(cb.flags & 1)) {\n      pendingPostFlushCbs.push(cb);\n      cb.flags |= 1;\n    }\n  } else {\n    pendingPostFlushCbs.push(...cb);\n  }\n  queueFlush();\n}\nfunction flushPreFlushCbs(instance, seen, i = flushIndex + 1) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    seen = seen || /* @__PURE__ */ new Map();\n  }\n  for (; i < queue.length; i++) {\n    const cb = queue[i];\n    if (cb && cb.flags & 2) {\n      if (instance && cb.id !== instance.uid) {\n        continue;\n      }\n      if (!!(process.env.NODE_ENV !== \"production\") && checkRecursiveUpdates(seen, cb)) {\n        continue;\n      }\n      queue.splice(i, 1);\n      i--;\n      if (cb.flags & 4) {\n        cb.flags &= -2;\n      }\n      cb();\n      if (!(cb.flags & 4)) {\n        cb.flags &= -2;\n      }\n    }\n  }\n}\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)].sort(\n      (a, b) => getId(a) - getId(b)\n    );\n    pendingPostFlushCbs.length = 0;\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n    activePostFlushCbs = deduped;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      seen = seen || /* @__PURE__ */ new Map();\n    }\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      const cb = activePostFlushCbs[postFlushIndex];\n      if (!!(process.env.NODE_ENV !== \"production\") && checkRecursiveUpdates(seen, cb)) {\n        continue;\n      }\n      if (cb.flags & 4) {\n        cb.flags &= -2;\n      }\n      if (!(cb.flags & 8)) cb();\n      cb.flags &= -2;\n    }\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\nconst getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;\nfunction flushJobs(seen) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    seen = seen || /* @__PURE__ */ new Map();\n  }\n  const check = !!(process.env.NODE_ENV !== \"production\") ? (job) => checkRecursiveUpdates(seen, job) : NOOP;\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job && !(job.flags & 8)) {\n        if (!!(process.env.NODE_ENV !== \"production\") && check(job)) {\n          continue;\n        }\n        if (job.flags & 4) {\n          job.flags &= ~1;\n        }\n        callWithErrorHandling(\n          job,\n          job.i,\n          job.i ? 15 : 14\n        );\n        if (!(job.flags & 4)) {\n          job.flags &= ~1;\n        }\n      }\n    }\n  } finally {\n    for (; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job) {\n        job.flags &= -2;\n      }\n    }\n    flushIndex = -1;\n    queue.length = 0;\n    flushPostFlushCbs(seen);\n    currentFlushPromise = null;\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n  const count = seen.get(fn) || 0;\n  if (count > RECURSION_LIMIT) {\n    const instance = fn.i;\n    const componentName = instance && getComponentName(instance.type);\n    handleError(\n      `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,\n      null,\n      10\n    );\n    return true;\n  }\n  seen.set(fn, count + 1);\n  return false;\n}\n\nlet isHmrUpdating = false;\nconst hmrDirtyComponents = /* @__PURE__ */ new Map();\nif (!!(process.env.NODE_ENV !== \"production\")) {\n  getGlobalThis().__VUE_HMR_RUNTIME__ = {\n    createRecord: tryWrap(createRecord),\n    rerender: tryWrap(rerender),\n    reload: tryWrap(reload)\n  };\n}\nconst map = /* @__PURE__ */ new Map();\nfunction registerHMR(instance) {\n  const id = instance.type.__hmrId;\n  let record = map.get(id);\n  if (!record) {\n    createRecord(id, instance.type);\n    record = map.get(id);\n  }\n  record.instances.add(instance);\n}\nfunction unregisterHMR(instance) {\n  map.get(instance.type.__hmrId).instances.delete(instance);\n}\nfunction createRecord(id, initialDef) {\n  if (map.has(id)) {\n    return false;\n  }\n  map.set(id, {\n    initialDef: normalizeClassComponent(initialDef),\n    instances: /* @__PURE__ */ new Set()\n  });\n  return true;\n}\nfunction normalizeClassComponent(component) {\n  return isClassComponent(component) ? component.__vccOpts : component;\n}\nfunction rerender(id, newRender) {\n  const record = map.get(id);\n  if (!record) {\n    return;\n  }\n  record.initialDef.render = newRender;\n  [...record.instances].forEach((instance) => {\n    if (newRender) {\n      instance.render = newRender;\n      normalizeClassComponent(instance.type).render = newRender;\n    }\n    instance.renderCache = [];\n    isHmrUpdating = true;\n    if (!(instance.job.flags & 8)) {\n      instance.update();\n    }\n    isHmrUpdating = false;\n  });\n}\nfunction reload(id, newComp) {\n  const record = map.get(id);\n  if (!record) return;\n  newComp = normalizeClassComponent(newComp);\n  updateComponentDef(record.initialDef, newComp);\n  const instances = [...record.instances];\n  for (let i = 0; i < instances.length; i++) {\n    const instance = instances[i];\n    const oldComp = normalizeClassComponent(instance.type);\n    let dirtyInstances = hmrDirtyComponents.get(oldComp);\n    if (!dirtyInstances) {\n      if (oldComp !== record.initialDef) {\n        updateComponentDef(oldComp, newComp);\n      }\n      hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());\n    }\n    dirtyInstances.add(instance);\n    instance.appContext.propsCache.delete(instance.type);\n    instance.appContext.emitsCache.delete(instance.type);\n    instance.appContext.optionsCache.delete(instance.type);\n    if (instance.ceReload) {\n      dirtyInstances.add(instance);\n      instance.ceReload(newComp.styles);\n      dirtyInstances.delete(instance);\n    } else if (instance.parent) {\n      queueJob(() => {\n        if (!(instance.job.flags & 8)) {\n          isHmrUpdating = true;\n          instance.parent.update();\n          isHmrUpdating = false;\n          dirtyInstances.delete(instance);\n        }\n      });\n    } else if (instance.appContext.reload) {\n      instance.appContext.reload();\n    } else if (typeof window !== \"undefined\") {\n      window.location.reload();\n    } else {\n      console.warn(\n        \"[HMR] Root or manually mounted instance modified. Full reload required.\"\n      );\n    }\n    if (instance.root.ce && instance !== instance.root) {\n      instance.root.ce._removeChildStyle(oldComp);\n    }\n  }\n  queuePostFlushCb(() => {\n    hmrDirtyComponents.clear();\n  });\n}\nfunction updateComponentDef(oldComp, newComp) {\n  extend(oldComp, newComp);\n  for (const key in oldComp) {\n    if (key !== \"__file\" && !(key in newComp)) {\n      delete oldComp[key];\n    }\n  }\n}\nfunction tryWrap(fn) {\n  return (id, arg) => {\n    try {\n      return fn(id, arg);\n    } catch (e) {\n      console.error(e);\n      console.warn(\n        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`\n      );\n    }\n  };\n}\n\nlet devtools$1;\nlet buffer = [];\nlet devtoolsNotInstalled = false;\nfunction emit$1(event, ...args) {\n  if (devtools$1) {\n    devtools$1.emit(event, ...args);\n  } else if (!devtoolsNotInstalled) {\n    buffer.push({ event, args });\n  }\n}\nfunction setDevtoolsHook$1(hook, target) {\n  var _a, _b;\n  devtools$1 = hook;\n  if (devtools$1) {\n    devtools$1.enabled = true;\n    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));\n    buffer = [];\n  } else if (\n    // handle late devtools injection - only do this if we are in an actual\n    // browser environment to avoid the timer handle stalling test runner exit\n    // (#4815)\n    typeof window !== \"undefined\" && // some envs mock window but not fully\n    window.HTMLElement && // also exclude jsdom\n    // eslint-disable-next-line no-restricted-syntax\n    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes(\"jsdom\"))\n  ) {\n    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];\n    replay.push((newHook) => {\n      setDevtoolsHook$1(newHook, target);\n    });\n    setTimeout(() => {\n      if (!devtools$1) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n        devtoolsNotInstalled = true;\n        buffer = [];\n      }\n    }, 3e3);\n  } else {\n    devtoolsNotInstalled = true;\n    buffer = [];\n  }\n}\nfunction devtoolsInitApp(app, version) {\n  emit$1(\"app:init\" /* APP_INIT */, app, version, {\n    Fragment,\n    Text,\n    Comment,\n    Static\n  });\n}\nfunction devtoolsUnmountApp(app) {\n  emit$1(\"app:unmount\" /* APP_UNMOUNT */, app);\n}\nconst devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(\"component:added\" /* COMPONENT_ADDED */);\nconst devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(\"component:updated\" /* COMPONENT_UPDATED */);\nconst _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(\n  \"component:removed\" /* COMPONENT_REMOVED */\n);\nconst devtoolsComponentRemoved = (component) => {\n  if (devtools$1 && typeof devtools$1.cleanupBuffer === \"function\" && // remove the component if it wasn't buffered\n  !devtools$1.cleanupBuffer(component)) {\n    _devtoolsComponentRemoved(component);\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction createDevtoolsComponentHook(hook) {\n  return (component) => {\n    emit$1(\n      hook,\n      component.appContext.app,\n      component.uid,\n      component.parent ? component.parent.uid : void 0,\n      component\n    );\n  };\n}\nconst devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(\"perf:start\" /* PERFORMANCE_START */);\nconst devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(\"perf:end\" /* PERFORMANCE_END */);\nfunction createDevtoolsPerformanceHook(hook) {\n  return (component, type, time) => {\n    emit$1(hook, component.appContext.app, component.uid, component, type, time);\n  };\n}\nfunction devtoolsComponentEmit(component, event, params) {\n  emit$1(\n    \"component:emit\" /* COMPONENT_EMIT */,\n    component.appContext.app,\n    component,\n    event,\n    params\n  );\n}\n\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\nfunction setCurrentRenderingInstance(instance) {\n  const prev = currentRenderingInstance;\n  currentRenderingInstance = instance;\n  currentScopeId = instance && instance.type.__scopeId || null;\n  return prev;\n}\nfunction pushScopeId(id) {\n  currentScopeId = id;\n}\nfunction popScopeId() {\n  currentScopeId = null;\n}\nconst withScopeId = (_id) => withCtx;\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {\n  if (!ctx) return fn;\n  if (fn._n) {\n    return fn;\n  }\n  const renderFnWithContext = (...args) => {\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1);\n    }\n    const prevInstance = setCurrentRenderingInstance(ctx);\n    let res;\n    try {\n      res = fn(...args);\n    } finally {\n      setCurrentRenderingInstance(prevInstance);\n      if (renderFnWithContext._d) {\n        setBlockTracking(1);\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      devtoolsComponentUpdated(ctx);\n    }\n    return res;\n  };\n  renderFnWithContext._n = true;\n  renderFnWithContext._c = true;\n  renderFnWithContext._d = true;\n  return renderFnWithContext;\n}\n\nfunction validateDirectiveName(name) {\n  if (isBuiltInDirective(name)) {\n    warn$1(\"Do not use built-in directive ids as custom directive id: \" + name);\n  }\n}\nfunction withDirectives(vnode, directives) {\n  if (currentRenderingInstance === null) {\n    !!(process.env.NODE_ENV !== \"production\") && warn$1(`withDirectives can only be used inside render functions.`);\n    return vnode;\n  }\n  const instance = getComponentPublicInstance(currentRenderingInstance);\n  const bindings = vnode.dirs || (vnode.dirs = []);\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];\n    if (dir) {\n      if (isFunction(dir)) {\n        dir = {\n          mounted: dir,\n          updated: dir\n        };\n      }\n      if (dir.deep) {\n        traverse(value);\n      }\n      bindings.push({\n        dir,\n        instance,\n        value,\n        oldValue: void 0,\n        arg,\n        modifiers\n      });\n    }\n  }\n  return vnode;\n}\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n  const bindings = vnode.dirs;\n  const oldBindings = prevVNode && prevVNode.dirs;\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n    let hook = binding.dir[name];\n    if (hook) {\n      pauseTracking();\n      callWithAsyncErrorHandling(hook, instance, 8, [\n        vnode.el,\n        binding,\n        vnode,\n        prevVNode\n      ]);\n      resetTracking();\n    }\n  }\n}\n\nconst TeleportEndKey = Symbol(\"_vte\");\nconst isTeleport = (type) => type.__isTeleport;\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === \"\");\nconst isTeleportDeferred = (props) => props && (props.defer || props.defer === \"\");\nconst isTargetSVG = (target) => typeof SVGElement !== \"undefined\" && target instanceof SVGElement;\nconst isTargetMathML = (target) => typeof MathMLElement === \"function\" && target instanceof MathMLElement;\nconst resolveTarget = (props, select) => {\n  const targetSelector = props && props.to;\n  if (isString(targetSelector)) {\n    if (!select) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(\n        `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`\n      );\n      return null;\n    } else {\n      const target = select(targetSelector);\n      if (!!(process.env.NODE_ENV !== \"production\") && !target && !isTeleportDisabled(props)) {\n        warn$1(\n          `Failed to locate Teleport target with selector \"${targetSelector}\". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`\n        );\n      }\n      return target;\n    }\n  } else {\n    if (!!(process.env.NODE_ENV !== \"production\") && !targetSelector && !isTeleportDisabled(props)) {\n      warn$1(`Invalid Teleport target: ${targetSelector}`);\n    }\n    return targetSelector;\n  }\n};\nconst TeleportImpl = {\n  name: \"Teleport\",\n  __isTeleport: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: { insert, querySelector, createText, createComment }\n    } = internals;\n    const disabled = isTeleportDisabled(n2.props);\n    let { shapeFlag, children, dynamicChildren } = n2;\n    if (!!(process.env.NODE_ENV !== \"production\") && isHmrUpdating) {\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (n1 == null) {\n      const placeholder = n2.el = !!(process.env.NODE_ENV !== \"production\") ? createComment(\"teleport start\") : createText(\"\");\n      const mainAnchor = n2.anchor = !!(process.env.NODE_ENV !== \"production\") ? createComment(\"teleport end\") : createText(\"\");\n      insert(placeholder, container, anchor);\n      insert(mainAnchor, container, anchor);\n      const mount = (container2, anchor2) => {\n        if (shapeFlag & 16) {\n          mountChildren(\n            children,\n            container2,\n            anchor2,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        }\n      };\n      const mountToTarget = () => {\n        const target = n2.target = resolveTarget(n2.props, querySelector);\n        const targetAnchor = prepareAnchor(target, n2, createText, insert);\n        if (target) {\n          if (namespace !== \"svg\" && isTargetSVG(target)) {\n            namespace = \"svg\";\n          } else if (namespace !== \"mathml\" && isTargetMathML(target)) {\n            namespace = \"mathml\";\n          }\n          if (parentComponent && parentComponent.isCE) {\n            (parentComponent.ce._teleportTargets || (parentComponent.ce._teleportTargets = /* @__PURE__ */ new Set())).add(target);\n          }\n          if (!disabled) {\n            mount(target, targetAnchor);\n            updateCssVars(n2, false);\n          }\n        } else if (!!(process.env.NODE_ENV !== \"production\") && !disabled) {\n          warn$1(\n            \"Invalid Teleport target on mount:\",\n            target,\n            `(${typeof target})`\n          );\n        }\n      };\n      if (disabled) {\n        mount(container, mainAnchor);\n        updateCssVars(n2, true);\n      }\n      if (isTeleportDeferred(n2.props)) {\n        n2.el.__isMounted = false;\n        queuePostRenderEffect(() => {\n          mountToTarget();\n          delete n2.el.__isMounted;\n        }, parentSuspense);\n      } else {\n        mountToTarget();\n      }\n    } else {\n      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {\n        queuePostRenderEffect(() => {\n          TeleportImpl.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n        }, parentSuspense);\n        return;\n      }\n      n2.el = n1.el;\n      n2.targetStart = n1.targetStart;\n      const mainAnchor = n2.anchor = n1.anchor;\n      const target = n2.target = n1.target;\n      const targetAnchor = n2.targetAnchor = n1.targetAnchor;\n      const wasDisabled = isTeleportDisabled(n1.props);\n      const currentContainer = wasDisabled ? container : target;\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n      if (namespace === \"svg\" || isTargetSVG(target)) {\n        namespace = \"svg\";\n      } else if (namespace === \"mathml\" || isTargetMathML(target)) {\n        namespace = \"mathml\";\n      }\n      if (dynamicChildren) {\n        patchBlockChildren(\n          n1.dynamicChildren,\n          dynamicChildren,\n          currentContainer,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds\n        );\n        traverseStaticChildren(n1, n2, !!!(process.env.NODE_ENV !== \"production\"));\n      } else if (!optimized) {\n        patchChildren(\n          n1,\n          n2,\n          currentContainer,\n          currentAnchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          false\n        );\n      }\n      if (disabled) {\n        if (!wasDisabled) {\n          moveTeleport(\n            n2,\n            container,\n            mainAnchor,\n            internals,\n            1\n          );\n        } else {\n          if (n2.props && n1.props && n2.props.to !== n1.props.to) {\n            n2.props.to = n1.props.to;\n          }\n        }\n      } else {\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = n2.target = resolveTarget(\n            n2.props,\n            querySelector\n          );\n          if (nextTarget) {\n            moveTeleport(\n              n2,\n              nextTarget,\n              null,\n              internals,\n              0\n            );\n          } else if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn$1(\n              \"Invalid Teleport target on update:\",\n              target,\n              `(${typeof target})`\n            );\n          }\n        } else if (wasDisabled) {\n          moveTeleport(\n            n2,\n            target,\n            targetAnchor,\n            internals,\n            1\n          );\n        }\n      }\n      updateCssVars(n2, disabled);\n    }\n  },\n  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {\n    const {\n      shapeFlag,\n      children,\n      anchor,\n      targetStart,\n      targetAnchor,\n      target,\n      props\n    } = vnode;\n    if (target) {\n      hostRemove(targetStart);\n      hostRemove(targetAnchor);\n    }\n    doRemove && hostRemove(anchor);\n    if (shapeFlag & 16) {\n      const shouldRemove = doRemove || !isTeleportDisabled(props);\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        unmount(\n          child,\n          parentComponent,\n          parentSuspense,\n          shouldRemove,\n          !!child.dynamicChildren\n        );\n      }\n    }\n  },\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n};\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {\n  if (moveType === 0) {\n    insert(vnode.targetAnchor, container, parentAnchor);\n  }\n  const { el, anchor, shapeFlag, children, props } = vnode;\n  const isReorder = moveType === 2;\n  if (isReorder) {\n    insert(el, container, parentAnchor);\n  }\n  if (!isReorder || isTeleportDisabled(props)) {\n    if (shapeFlag & 16) {\n      for (let i = 0; i < children.length; i++) {\n        move(\n          children[i],\n          container,\n          parentAnchor,\n          2\n        );\n      }\n    }\n  }\n  if (isReorder) {\n    insert(anchor, container, parentAnchor);\n  }\n}\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {\n  o: { nextSibling, parentNode, querySelector, insert, createText }\n}, hydrateChildren) {\n  function hydrateDisabledTeleport(node2, vnode2, targetStart, targetAnchor) {\n    vnode2.anchor = hydrateChildren(\n      nextSibling(node2),\n      vnode2,\n      parentNode(node2),\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      optimized\n    );\n    vnode2.targetStart = targetStart;\n    vnode2.targetAnchor = targetAnchor;\n  }\n  const target = vnode.target = resolveTarget(\n    vnode.props,\n    querySelector\n  );\n  const disabled = isTeleportDisabled(vnode.props);\n  if (target) {\n    const targetNode = target._lpa || target.firstChild;\n    if (vnode.shapeFlag & 16) {\n      if (disabled) {\n        hydrateDisabledTeleport(\n          node,\n          vnode,\n          targetNode,\n          targetNode && nextSibling(targetNode)\n        );\n      } else {\n        vnode.anchor = nextSibling(node);\n        let targetAnchor = targetNode;\n        while (targetAnchor) {\n          if (targetAnchor && targetAnchor.nodeType === 8) {\n            if (targetAnchor.data === \"teleport start anchor\") {\n              vnode.targetStart = targetAnchor;\n            } else if (targetAnchor.data === \"teleport anchor\") {\n              vnode.targetAnchor = targetAnchor;\n              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n              break;\n            }\n          }\n          targetAnchor = nextSibling(targetAnchor);\n        }\n        if (!vnode.targetAnchor) {\n          prepareAnchor(target, vnode, createText, insert);\n        }\n        hydrateChildren(\n          targetNode && nextSibling(targetNode),\n          vnode,\n          target,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n      }\n    }\n    updateCssVars(vnode, disabled);\n  } else if (disabled) {\n    if (vnode.shapeFlag & 16) {\n      hydrateDisabledTeleport(node, vnode, node, nextSibling(node));\n    }\n  }\n  return vnode.anchor && nextSibling(vnode.anchor);\n}\nconst Teleport = TeleportImpl;\nfunction updateCssVars(vnode, isDisabled) {\n  const ctx = vnode.ctx;\n  if (ctx && ctx.ut) {\n    let node, anchor;\n    if (isDisabled) {\n      node = vnode.el;\n      anchor = vnode.anchor;\n    } else {\n      node = vnode.targetStart;\n      anchor = vnode.targetAnchor;\n    }\n    while (node && node !== anchor) {\n      if (node.nodeType === 1) node.setAttribute(\"data-v-owner\", ctx.uid);\n      node = node.nextSibling;\n    }\n    ctx.ut();\n  }\n}\nfunction prepareAnchor(target, vnode, createText, insert) {\n  const targetStart = vnode.targetStart = createText(\"\");\n  const targetAnchor = vnode.targetAnchor = createText(\"\");\n  targetStart[TeleportEndKey] = targetAnchor;\n  if (target) {\n    insert(targetStart, target);\n    insert(targetAnchor, target);\n  }\n  return targetAnchor;\n}\n\nconst leaveCbKey = Symbol(\"_leaveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nfunction useTransitionState() {\n  const state = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: /* @__PURE__ */ new Map()\n  };\n  onMounted(() => {\n    state.isMounted = true;\n  });\n  onBeforeUnmount(() => {\n    state.isUnmounting = true;\n  });\n  return state;\n}\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionPropsValidators = {\n  mode: String,\n  appear: Boolean,\n  persisted: Boolean,\n  // enter\n  onBeforeEnter: TransitionHookValidator,\n  onEnter: TransitionHookValidator,\n  onAfterEnter: TransitionHookValidator,\n  onEnterCancelled: TransitionHookValidator,\n  // leave\n  onBeforeLeave: TransitionHookValidator,\n  onLeave: TransitionHookValidator,\n  onAfterLeave: TransitionHookValidator,\n  onLeaveCancelled: TransitionHookValidator,\n  // appear\n  onBeforeAppear: TransitionHookValidator,\n  onAppear: TransitionHookValidator,\n  onAfterAppear: TransitionHookValidator,\n  onAppearCancelled: TransitionHookValidator\n};\nconst recursiveGetSubtree = (instance) => {\n  const subTree = instance.subTree;\n  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;\n};\nconst BaseTransitionImpl = {\n  name: `BaseTransition`,\n  props: BaseTransitionPropsValidators,\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    return () => {\n      const children = slots.default && getTransitionRawChildren(slots.default(), true);\n      if (!children || !children.length) {\n        return;\n      }\n      const child = findNonCommentChild(children);\n      const rawProps = toRaw(props);\n      const { mode } = rawProps;\n      if (!!(process.env.NODE_ENV !== \"production\") && mode && mode !== \"in-out\" && mode !== \"out-in\" && mode !== \"default\") {\n        warn$1(`invalid <transition> mode: ${mode}`);\n      }\n      if (state.isLeaving) {\n        return emptyPlaceholder(child);\n      }\n      const innerChild = getInnerChild$1(child);\n      if (!innerChild) {\n        return emptyPlaceholder(child);\n      }\n      let enterHooks = resolveTransitionHooks(\n        innerChild,\n        rawProps,\n        state,\n        instance,\n        // #11061, ensure enterHooks is fresh after clone\n        (hooks) => enterHooks = hooks\n      );\n      if (innerChild.type !== Comment) {\n        setTransitionHooks(innerChild, enterHooks);\n      }\n      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);\n      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(oldInnerChild, innerChild) && recursiveGetSubtree(instance).type !== Comment) {\n        let leavingHooks = resolveTransitionHooks(\n          oldInnerChild,\n          rawProps,\n          state,\n          instance\n        );\n        setTransitionHooks(oldInnerChild, leavingHooks);\n        if (mode === \"out-in\" && innerChild.type !== Comment) {\n          state.isLeaving = true;\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false;\n            if (!(instance.job.flags & 8)) {\n              instance.update();\n            }\n            delete leavingHooks.afterLeave;\n            oldInnerChild = void 0;\n          };\n          return emptyPlaceholder(child);\n        } else if (mode === \"in-out\" && innerChild.type !== Comment) {\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            const leavingVNodesCache = getLeavingNodesForType(\n              state,\n              oldInnerChild\n            );\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n            el[leaveCbKey] = () => {\n              earlyRemove();\n              el[leaveCbKey] = void 0;\n              delete enterHooks.delayedLeave;\n              oldInnerChild = void 0;\n            };\n            enterHooks.delayedLeave = () => {\n              delayedLeave();\n              delete enterHooks.delayedLeave;\n              oldInnerChild = void 0;\n            };\n          };\n        } else {\n          oldInnerChild = void 0;\n        }\n      } else if (oldInnerChild) {\n        oldInnerChild = void 0;\n      }\n      return child;\n    };\n  }\n};\nfunction findNonCommentChild(children) {\n  let child = children[0];\n  if (children.length > 1) {\n    let hasFound = false;\n    for (const c of children) {\n      if (c.type !== Comment) {\n        if (!!(process.env.NODE_ENV !== \"production\") && hasFound) {\n          warn$1(\n            \"<transition> can only be used on a single element or component. Use <transition-group> for lists.\"\n          );\n          break;\n        }\n        child = c;\n        hasFound = true;\n        if (!!!(process.env.NODE_ENV !== \"production\")) break;\n      }\n    }\n  }\n  return child;\n}\nconst BaseTransition = BaseTransitionImpl;\nfunction getLeavingNodesForType(state, vnode) {\n  const { leavingVNodes } = state;\n  let leavingVNodesCache = leavingVNodes.get(vnode.type);\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = /* @__PURE__ */ Object.create(null);\n    leavingVNodes.set(vnode.type, leavingVNodesCache);\n  }\n  return leavingVNodesCache;\n}\nfunction resolveTransitionHooks(vnode, props, state, instance, postClone) {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props;\n  const key = String(vnode.key);\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n  const callHook = (hook, args) => {\n    hook && callWithAsyncErrorHandling(\n      hook,\n      instance,\n      9,\n      args\n    );\n  };\n  const callAsyncHook = (hook, args) => {\n    const done = args[1];\n    callHook(hook, args);\n    if (isArray(hook)) {\n      if (hook.every((hook2) => hook2.length <= 1)) done();\n    } else if (hook.length <= 1) {\n      done();\n    }\n  };\n  const hooks = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter;\n        } else {\n          return;\n        }\n      }\n      if (el[leaveCbKey]) {\n        el[leaveCbKey](\n          true\n          /* cancelled */\n        );\n      }\n      const leavingVNode = leavingVNodesCache[key];\n      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {\n        leavingVNode.el[leaveCbKey]();\n      }\n      callHook(hook, [el]);\n    },\n    enter(el) {\n      let hook = onEnter;\n      let afterHook = onAfterEnter;\n      let cancelHook = onEnterCancelled;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter;\n          afterHook = onAfterAppear || onAfterEnter;\n          cancelHook = onAppearCancelled || onEnterCancelled;\n        } else {\n          return;\n        }\n      }\n      let called = false;\n      const done = el[enterCbKey] = (cancelled) => {\n        if (called) return;\n        called = true;\n        if (cancelled) {\n          callHook(cancelHook, [el]);\n        } else {\n          callHook(afterHook, [el]);\n        }\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave();\n        }\n        el[enterCbKey] = void 0;\n      };\n      if (hook) {\n        callAsyncHook(hook, [el, done]);\n      } else {\n        done();\n      }\n    },\n    leave(el, remove) {\n      const key2 = String(vnode.key);\n      if (el[enterCbKey]) {\n        el[enterCbKey](\n          true\n          /* cancelled */\n        );\n      }\n      if (state.isUnmounting) {\n        return remove();\n      }\n      callHook(onBeforeLeave, [el]);\n      let called = false;\n      const done = el[leaveCbKey] = (cancelled) => {\n        if (called) return;\n        called = true;\n        remove();\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el]);\n        } else {\n          callHook(onAfterLeave, [el]);\n        }\n        el[leaveCbKey] = void 0;\n        if (leavingVNodesCache[key2] === vnode) {\n          delete leavingVNodesCache[key2];\n        }\n      };\n      leavingVNodesCache[key2] = vnode;\n      if (onLeave) {\n        callAsyncHook(onLeave, [el, done]);\n      } else {\n        done();\n      }\n    },\n    clone(vnode2) {\n      const hooks2 = resolveTransitionHooks(\n        vnode2,\n        props,\n        state,\n        instance,\n        postClone\n      );\n      if (postClone) postClone(hooks2);\n      return hooks2;\n    }\n  };\n  return hooks;\n}\nfunction emptyPlaceholder(vnode) {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode);\n    vnode.children = null;\n    return vnode;\n  }\n}\nfunction getInnerChild$1(vnode) {\n  if (!isKeepAlive(vnode)) {\n    if (isTeleport(vnode.type) && vnode.children) {\n      return findNonCommentChild(vnode.children);\n    }\n    return vnode;\n  }\n  if (vnode.component) {\n    return vnode.component.subTree;\n  }\n  const { shapeFlag, children } = vnode;\n  if (children) {\n    if (shapeFlag & 16) {\n      return children[0];\n    }\n    if (shapeFlag & 32 && isFunction(children.default)) {\n      return children.default();\n    }\n  }\n}\nfunction setTransitionHooks(vnode, hooks) {\n  if (vnode.shapeFlag & 6 && vnode.component) {\n    vnode.transition = hooks;\n    setTransitionHooks(vnode.component.subTree, hooks);\n  } else if (vnode.shapeFlag & 128) {\n    vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n  } else {\n    vnode.transition = hooks;\n  }\n}\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\n  let ret = [];\n  let keyedFragmentCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);\n    if (child.type === Fragment) {\n      if (child.patchFlag & 128) keyedFragmentCount++;\n      ret = ret.concat(\n        getTransitionRawChildren(child.children, keepComment, key)\n      );\n    } else if (keepComment || child.type !== Comment) {\n      ret.push(key != null ? cloneVNode(child, { key }) : child);\n    }\n  }\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = -2;\n    }\n  }\n  return ret;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction defineComponent(options, extraOptions) {\n  return isFunction(options) ? (\n    // #8236: extend call and options.name access are considered side-effects\n    // by Rollup, so we have to wrap it in a pure-annotated IIFE.\n    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()\n  ) : options;\n}\n\nfunction useId() {\n  const i = getCurrentInstance();\n  if (i) {\n    return (i.appContext.config.idPrefix || \"v\") + \"-\" + i.ids[0] + i.ids[1]++;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(\n      `useId() is called when there is no active component instance to be associated with.`\n    );\n  }\n  return \"\";\n}\nfunction markAsyncBoundary(instance) {\n  instance.ids = [instance.ids[0] + instance.ids[2]++ + \"-\", 0, 0];\n}\n\nconst knownTemplateRefs = /* @__PURE__ */ new WeakSet();\nfunction useTemplateRef(key) {\n  const i = getCurrentInstance();\n  const r = shallowRef(null);\n  if (i) {\n    const refs = i.refs === EMPTY_OBJ ? i.refs = {} : i.refs;\n    let desc;\n    if (!!(process.env.NODE_ENV !== \"production\") && (desc = Object.getOwnPropertyDescriptor(refs, key)) && !desc.configurable) {\n      warn$1(`useTemplateRef('${key}') already exists.`);\n    } else {\n      Object.defineProperty(refs, key, {\n        enumerable: true,\n        get: () => r.value,\n        set: (val) => r.value = val\n      });\n    }\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(\n      `useTemplateRef() is called when there is no active component instance to be associated with.`\n    );\n  }\n  const ret = !!(process.env.NODE_ENV !== \"production\") ? readonly(r) : r;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    knownTemplateRefs.add(ret);\n  }\n  return ret;\n}\n\nconst pendingSetRefMap = /* @__PURE__ */ new WeakMap();\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\n  if (isArray(rawRef)) {\n    rawRef.forEach(\n      (r, i) => setRef(\n        r,\n        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),\n        parentSuspense,\n        vnode,\n        isUnmount\n      )\n    );\n    return;\n  }\n  if (isAsyncWrapper(vnode) && !isUnmount) {\n    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {\n      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);\n    }\n    return;\n  }\n  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;\n  const value = isUnmount ? null : refValue;\n  const { i: owner, r: ref } = rawRef;\n  if (!!(process.env.NODE_ENV !== \"production\") && !owner) {\n    warn$1(\n      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`\n    );\n    return;\n  }\n  const oldRef = oldRawRef && oldRawRef.r;\n  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;\n  const setupState = owner.setupState;\n  const rawSetupState = toRaw(setupState);\n  const canSetSetupRef = setupState === EMPTY_OBJ ? NO : (key) => {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      if (hasOwn(rawSetupState, key) && !isRef(rawSetupState[key])) {\n        warn$1(\n          `Template ref \"${key}\" used on a non-ref value. It will not work in the production build.`\n        );\n      }\n      if (knownTemplateRefs.has(rawSetupState[key])) {\n        return false;\n      }\n    }\n    return hasOwn(rawSetupState, key);\n  };\n  const canSetRef = (ref2) => {\n    return !!!(process.env.NODE_ENV !== \"production\") || !knownTemplateRefs.has(ref2);\n  };\n  if (oldRef != null && oldRef !== ref) {\n    invalidatePendingSetRef(oldRawRef);\n    if (isString(oldRef)) {\n      refs[oldRef] = null;\n      if (canSetSetupRef(oldRef)) {\n        setupState[oldRef] = null;\n      }\n    } else if (isRef(oldRef)) {\n      if (canSetRef(oldRef)) {\n        oldRef.value = null;\n      }\n      const oldRawRefAtom = oldRawRef;\n      if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;\n    }\n  }\n  if (isFunction(ref)) {\n    callWithErrorHandling(ref, owner, 12, [value, refs]);\n  } else {\n    const _isString = isString(ref);\n    const _isRef = isRef(ref);\n    if (_isString || _isRef) {\n      const doSet = () => {\n        if (rawRef.f) {\n          const existing = _isString ? canSetSetupRef(ref) ? setupState[ref] : refs[ref] : canSetRef(ref) || !rawRef.k ? ref.value : refs[rawRef.k];\n          if (isUnmount) {\n            isArray(existing) && remove(existing, refValue);\n          } else {\n            if (!isArray(existing)) {\n              if (_isString) {\n                refs[ref] = [refValue];\n                if (canSetSetupRef(ref)) {\n                  setupState[ref] = refs[ref];\n                }\n              } else {\n                const newVal = [refValue];\n                if (canSetRef(ref)) {\n                  ref.value = newVal;\n                }\n                if (rawRef.k) refs[rawRef.k] = newVal;\n              }\n            } else if (!existing.includes(refValue)) {\n              existing.push(refValue);\n            }\n          }\n        } else if (_isString) {\n          refs[ref] = value;\n          if (canSetSetupRef(ref)) {\n            setupState[ref] = value;\n          }\n        } else if (_isRef) {\n          if (canSetRef(ref)) {\n            ref.value = value;\n          }\n          if (rawRef.k) refs[rawRef.k] = value;\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\"Invalid template ref type:\", ref, `(${typeof ref})`);\n        }\n      };\n      if (value) {\n        const job = () => {\n          doSet();\n          pendingSetRefMap.delete(rawRef);\n        };\n        job.id = -1;\n        pendingSetRefMap.set(rawRef, job);\n        queuePostRenderEffect(job, parentSuspense);\n      } else {\n        invalidatePendingSetRef(rawRef);\n        doSet();\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(\"Invalid template ref type:\", ref, `(${typeof ref})`);\n    }\n  }\n}\nfunction invalidatePendingSetRef(rawRef) {\n  const pendingSetRef = pendingSetRefMap.get(rawRef);\n  if (pendingSetRef) {\n    pendingSetRef.flags |= 8;\n    pendingSetRefMap.delete(rawRef);\n  }\n}\n\nlet hasLoggedMismatchError = false;\nconst logMismatchError = () => {\n  if (hasLoggedMismatchError) {\n    return;\n  }\n  console.error(\"Hydration completed but contains mismatches.\");\n  hasLoggedMismatchError = true;\n};\nconst isSVGContainer = (container) => container.namespaceURI.includes(\"svg\") && container.tagName !== \"foreignObject\";\nconst isMathMLContainer = (container) => container.namespaceURI.includes(\"MathML\");\nconst getContainerType = (container) => {\n  if (container.nodeType !== 1) return void 0;\n  if (isSVGContainer(container)) return \"svg\";\n  if (isMathMLContainer(container)) return \"mathml\";\n  return void 0;\n};\nconst isComment = (node) => node.nodeType === 8;\nfunction createHydrationFunctions(rendererInternals) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: {\n      patchProp,\n      createText,\n      nextSibling,\n      parentNode,\n      remove,\n      insert,\n      createComment\n    }\n  } = rendererInternals;\n  const hydrate = (vnode, container) => {\n    if (!container.hasChildNodes()) {\n      (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(\n        `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`\n      );\n      patch(null, vnode, container);\n      flushPostFlushCbs();\n      container._vnode = vnode;\n      return;\n    }\n    hydrateNode(container.firstChild, vnode, null, null, null);\n    flushPostFlushCbs();\n    container._vnode = vnode;\n  };\n  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const isFragmentStart = isComment(node) && node.data === \"[\";\n    const onMismatch = () => handleMismatch(\n      node,\n      vnode,\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      isFragmentStart\n    );\n    const { type, ref, shapeFlag, patchFlag } = vnode;\n    let domType = node.nodeType;\n    vnode.el = node;\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      def(node, \"__vnode\", vnode, true);\n      def(node, \"__vueParentComponent\", parentComponent, true);\n    }\n    if (patchFlag === -2) {\n      optimized = false;\n      vnode.dynamicChildren = null;\n    }\n    let nextNode = null;\n    switch (type) {\n      case Text:\n        if (domType !== 3) {\n          if (vnode.children === \"\") {\n            insert(vnode.el = createText(\"\"), parentNode(node), node);\n            nextNode = node;\n          } else {\n            nextNode = onMismatch();\n          }\n        } else {\n          if (node.data !== vnode.children) {\n            (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(\n              `Hydration text mismatch in`,\n              node.parentNode,\n              `\n  - rendered on server: ${JSON.stringify(\n                node.data\n              )}\n  - expected on client: ${JSON.stringify(vnode.children)}`\n            );\n            logMismatchError();\n            node.data = vnode.children;\n          }\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Comment:\n        if (isTemplateNode(node)) {\n          nextNode = nextSibling(node);\n          replaceNode(\n            vnode.el = node.content.firstChild,\n            node,\n            parentComponent\n          );\n        } else if (domType !== 8 || isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Static:\n        if (isFragmentStart) {\n          node = nextSibling(node);\n          domType = node.nodeType;\n        }\n        if (domType === 1 || domType === 3) {\n          nextNode = node;\n          const needToAdoptContent = !vnode.children.length;\n          for (let i = 0; i < vnode.staticCount; i++) {\n            if (needToAdoptContent)\n              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;\n            if (i === vnode.staticCount - 1) {\n              vnode.anchor = nextNode;\n            }\n            nextNode = nextSibling(nextNode);\n          }\n          return isFragmentStart ? nextSibling(nextNode) : nextNode;\n        } else {\n          onMismatch();\n        }\n        break;\n      case Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = hydrateFragment(\n            node,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            slotScopeIds,\n            optimized\n          );\n        }\n        break;\n      default:\n        if (shapeFlag & 1) {\n          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = hydrateElement(\n              node,\n              vnode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized\n            );\n          }\n        } else if (shapeFlag & 6) {\n          vnode.slotScopeIds = slotScopeIds;\n          const container = parentNode(node);\n          if (isFragmentStart) {\n            nextNode = locateClosingAnchor(node);\n          } else if (isComment(node) && node.data === \"teleport start\") {\n            nextNode = locateClosingAnchor(node, node.data, \"teleport end\");\n          } else {\n            nextNode = nextSibling(node);\n          }\n          mountComponent(\n            vnode,\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            getContainerType(container),\n            optimized\n          );\n          if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {\n            let subTree;\n            if (isFragmentStart) {\n              subTree = createVNode(Fragment);\n              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;\n            } else {\n              subTree = node.nodeType === 3 ? createTextVNode(\"\") : createVNode(\"div\");\n            }\n            subTree.el = node;\n            vnode.component.subTree = subTree;\n          }\n        } else if (shapeFlag & 64) {\n          if (domType !== 8) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = vnode.type.hydrate(\n              node,\n              vnode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized,\n              rendererInternals,\n              hydrateChildren\n            );\n          }\n        } else if (shapeFlag & 128) {\n          nextNode = vnode.type.hydrate(\n            node,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            getContainerType(parentNode(node)),\n            slotScopeIds,\n            optimized,\n            rendererInternals,\n            hydrateNode\n          );\n        } else if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) {\n          warn$1(\"Invalid HostVNode type:\", type, `(${typeof type})`);\n        }\n    }\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode);\n    }\n    return nextNode;\n  };\n  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;\n    const forcePatch = type === \"input\" || type === \"option\";\n    if (!!(process.env.NODE_ENV !== \"production\") || forcePatch || patchFlag !== -1) {\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n      }\n      let needCallTransitionHooks = false;\n      if (isTemplateNode(el)) {\n        needCallTransitionHooks = needTransition(\n          null,\n          // no need check parentSuspense in hydration\n          transition\n        ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;\n        const content = el.content.firstChild;\n        if (needCallTransitionHooks) {\n          const cls = content.getAttribute(\"class\");\n          if (cls) content.$cls = cls;\n          transition.beforeEnter(content);\n        }\n        replaceNode(content, el, parentComponent);\n        vnode.el = el = content;\n      }\n      if (shapeFlag & 16 && // skip if element has innerHTML / textContent\n      !(props && (props.innerHTML || props.textContent))) {\n        let next = hydrateChildren(\n          el.firstChild,\n          vnode,\n          el,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n        let hasWarned = false;\n        while (next) {\n          if (!isMismatchAllowed(el, 1 /* CHILDREN */)) {\n            if ((!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && !hasWarned) {\n              warn$1(\n                `Hydration children mismatch on`,\n                el,\n                `\nServer rendered element contains more child nodes than client vdom.`\n              );\n              hasWarned = true;\n            }\n            logMismatchError();\n          }\n          const cur = next;\n          next = next.nextSibling;\n          remove(cur);\n        }\n      } else if (shapeFlag & 8) {\n        let clientText = vnode.children;\n        if (clientText[0] === \"\\n\" && (el.tagName === \"PRE\" || el.tagName === \"TEXTAREA\")) {\n          clientText = clientText.slice(1);\n        }\n        const { textContent } = el;\n        if (textContent !== clientText && // innerHTML normalize \\r\\n or \\r into a single \\n in the DOM\n        textContent !== clientText.replace(/\\r\\n|\\r/g, \"\\n\")) {\n          if (!isMismatchAllowed(el, 0 /* TEXT */)) {\n            (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(\n              `Hydration text content mismatch on`,\n              el,\n              `\n  - rendered on server: ${textContent}\n  - expected on client: ${clientText}`\n            );\n            logMismatchError();\n          }\n          el.textContent = vnode.children;\n        }\n      }\n      if (props) {\n        if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ || forcePatch || !optimized || patchFlag & (16 | 32)) {\n          const isCustomElement = el.tagName.includes(\"-\");\n          for (const key in props) {\n            if ((!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && // #11189 skip if this node has directives that have created hooks\n            // as it could have mutated the DOM in any possible way\n            !(dirs && dirs.some((d) => d.dir.created)) && propHasMismatch(el, key, props[key], vnode, parentComponent)) {\n              logMismatchError();\n            }\n            if (forcePatch && (key.endsWith(\"value\") || key === \"indeterminate\") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers\n            key[0] === \".\" || isCustomElement) {\n              patchProp(el, key, null, props[key], void 0, parentComponent);\n            }\n          }\n        } else if (props.onClick) {\n          patchProp(\n            el,\n            \"onClick\",\n            null,\n            props.onClick,\n            void 0,\n            parentComponent\n          );\n        } else if (patchFlag & 4 && isReactive(props.style)) {\n          for (const key in props.style) props.style[key];\n        }\n      }\n      let vnodeHooks;\n      if (vnodeHooks = props && props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n      }\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n      }\n      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {\n        queueEffectWithSuspense(() => {\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n          needCallTransitionHooks && transition.enter(el);\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n        }, parentSuspense);\n      }\n    }\n    return el.nextSibling;\n  };\n  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!parentVNode.dynamicChildren;\n    const children = parentVNode.children;\n    const l = children.length;\n    let hasWarned = false;\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);\n      const isText = vnode.type === Text;\n      if (node) {\n        if (isText && !optimized) {\n          if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {\n            insert(\n              createText(\n                node.data.slice(vnode.children.length)\n              ),\n              container,\n              nextSibling(node)\n            );\n            node.data = vnode.children;\n          }\n        }\n        node = hydrateNode(\n          node,\n          vnode,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n      } else if (isText && !vnode.children) {\n        insert(vnode.el = createText(\"\"), container);\n      } else {\n        if (!isMismatchAllowed(container, 1 /* CHILDREN */)) {\n          if ((!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && !hasWarned) {\n            warn$1(\n              `Hydration children mismatch on`,\n              container,\n              `\nServer rendered element contains fewer child nodes than client vdom.`\n            );\n            hasWarned = true;\n          }\n          logMismatchError();\n        }\n        patch(\n          null,\n          vnode,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          getContainerType(container),\n          slotScopeIds\n        );\n      }\n    }\n    return node;\n  };\n  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    const { slotScopeIds: fragmentSlotScopeIds } = vnode;\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    const container = parentNode(node);\n    const next = hydrateChildren(\n      nextSibling(node),\n      vnode,\n      container,\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      optimized\n    );\n    if (next && isComment(next) && next.data === \"]\") {\n      return nextSibling(vnode.anchor = next);\n    } else {\n      logMismatchError();\n      insert(vnode.anchor = createComment(`]`), container, next);\n      return next;\n    }\n  };\n  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\n    if (!isMismatchAllowed(node.parentElement, 1 /* CHILDREN */)) {\n      (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(\n        `Hydration node mismatch:\n- rendered on server:`,\n        node,\n        node.nodeType === 3 ? `(text)` : isComment(node) && node.data === \"[\" ? `(start of fragment)` : ``,\n        `\n- expected on client:`,\n        vnode.type\n      );\n      logMismatchError();\n    }\n    vnode.el = null;\n    if (isFragment) {\n      const end = locateClosingAnchor(node);\n      while (true) {\n        const next2 = nextSibling(node);\n        if (next2 && next2 !== end) {\n          remove(next2);\n        } else {\n          break;\n        }\n      }\n    }\n    const next = nextSibling(node);\n    const container = parentNode(node);\n    remove(node);\n    patch(\n      null,\n      vnode,\n      container,\n      next,\n      parentComponent,\n      parentSuspense,\n      getContainerType(container),\n      slotScopeIds\n    );\n    if (parentComponent) {\n      parentComponent.vnode.el = vnode.el;\n      updateHOCHostEl(parentComponent, vnode.el);\n    }\n    return next;\n  };\n  const locateClosingAnchor = (node, open = \"[\", close = \"]\") => {\n    let match = 0;\n    while (node) {\n      node = nextSibling(node);\n      if (node && isComment(node)) {\n        if (node.data === open) match++;\n        if (node.data === close) {\n          if (match === 0) {\n            return nextSibling(node);\n          } else {\n            match--;\n          }\n        }\n      }\n    }\n    return node;\n  };\n  const replaceNode = (newNode, oldNode, parentComponent) => {\n    const parentNode2 = oldNode.parentNode;\n    if (parentNode2) {\n      parentNode2.replaceChild(newNode, oldNode);\n    }\n    let parent = parentComponent;\n    while (parent) {\n      if (parent.vnode.el === oldNode) {\n        parent.vnode.el = parent.subTree.el = newNode;\n      }\n      parent = parent.parent;\n    }\n  };\n  const isTemplateNode = (node) => {\n    return node.nodeType === 1 && node.tagName === \"TEMPLATE\";\n  };\n  return [hydrate, hydrateNode];\n}\nfunction propHasMismatch(el, key, clientValue, vnode, instance) {\n  let mismatchType;\n  let mismatchKey;\n  let actual;\n  let expected;\n  if (key === \"class\") {\n    if (el.$cls) {\n      actual = el.$cls;\n      delete el.$cls;\n    } else {\n      actual = el.getAttribute(\"class\");\n    }\n    expected = normalizeClass(clientValue);\n    if (!isSetEqual(toClassSet(actual || \"\"), toClassSet(expected))) {\n      mismatchType = 2 /* CLASS */;\n      mismatchKey = `class`;\n    }\n  } else if (key === \"style\") {\n    actual = el.getAttribute(\"style\") || \"\";\n    expected = isString(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));\n    const actualMap = toStyleMap(actual);\n    const expectedMap = toStyleMap(expected);\n    if (vnode.dirs) {\n      for (const { dir, value } of vnode.dirs) {\n        if (dir.name === \"show\" && !value) {\n          expectedMap.set(\"display\", \"none\");\n        }\n      }\n    }\n    if (instance) {\n      resolveCssVars(instance, vnode, expectedMap);\n    }\n    if (!isMapEqual(actualMap, expectedMap)) {\n      mismatchType = 3 /* STYLE */;\n      mismatchKey = \"style\";\n    }\n  } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {\n    if (isBooleanAttr(key)) {\n      actual = el.hasAttribute(key);\n      expected = includeBooleanAttr(clientValue);\n    } else if (clientValue == null) {\n      actual = el.hasAttribute(key);\n      expected = false;\n    } else {\n      if (el.hasAttribute(key)) {\n        actual = el.getAttribute(key);\n      } else if (key === \"value\" && el.tagName === \"TEXTAREA\") {\n        actual = el.value;\n      } else {\n        actual = false;\n      }\n      expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;\n    }\n    if (actual !== expected) {\n      mismatchType = 4 /* ATTRIBUTE */;\n      mismatchKey = key;\n    }\n  }\n  if (mismatchType != null && !isMismatchAllowed(el, mismatchType)) {\n    const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}=\"${v}\"`;\n    const preSegment = `Hydration ${MismatchTypeString[mismatchType]} mismatch on`;\n    const postSegment = `\n  - rendered on server: ${format(actual)}\n  - expected on client: ${format(expected)}\n  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.\n  You should fix the source of the mismatch.`;\n    {\n      warn$1(preSegment, el, postSegment);\n    }\n    return true;\n  }\n  return false;\n}\nfunction toClassSet(str) {\n  return new Set(str.trim().split(/\\s+/));\n}\nfunction isSetEqual(a, b) {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const s of a) {\n    if (!b.has(s)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toStyleMap(str) {\n  const styleMap = /* @__PURE__ */ new Map();\n  for (const item of str.split(\";\")) {\n    let [key, value] = item.split(\":\");\n    key = key.trim();\n    value = value && value.trim();\n    if (key && value) {\n      styleMap.set(key, value);\n    }\n  }\n  return styleMap;\n}\nfunction isMapEqual(a, b) {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const [key, value] of a) {\n    if (value !== b.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction resolveCssVars(instance, vnode, expectedMap) {\n  const root = instance.subTree;\n  if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {\n    const cssVars = instance.getCssVars();\n    for (const key in cssVars) {\n      const value = normalizeCssVarValue(cssVars[key]);\n      expectedMap.set(`--${getEscapedCssVarName(key, false)}`, value);\n    }\n  }\n  if (vnode === root && instance.parent) {\n    resolveCssVars(instance.parent, instance.vnode, expectedMap);\n  }\n}\nconst allowMismatchAttr = \"data-allow-mismatch\";\nconst MismatchTypeString = {\n  [0 /* TEXT */]: \"text\",\n  [1 /* CHILDREN */]: \"children\",\n  [2 /* CLASS */]: \"class\",\n  [3 /* STYLE */]: \"style\",\n  [4 /* ATTRIBUTE */]: \"attribute\"\n};\nfunction isMismatchAllowed(el, allowedType) {\n  if (allowedType === 0 /* TEXT */ || allowedType === 1 /* CHILDREN */) {\n    while (el && !el.hasAttribute(allowMismatchAttr)) {\n      el = el.parentElement;\n    }\n  }\n  const allowedAttr = el && el.getAttribute(allowMismatchAttr);\n  if (allowedAttr == null) {\n    return false;\n  } else if (allowedAttr === \"\") {\n    return true;\n  } else {\n    const list = allowedAttr.split(\",\");\n    if (allowedType === 0 /* TEXT */ && list.includes(\"children\")) {\n      return true;\n    }\n    return list.includes(MismatchTypeString[allowedType]);\n  }\n}\n\nconst requestIdleCallback = getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));\nconst cancelIdleCallback = getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));\nconst hydrateOnIdle = (timeout = 1e4) => (hydrate) => {\n  const id = requestIdleCallback(hydrate, { timeout });\n  return () => cancelIdleCallback(id);\n};\nfunction elementIsVisibleInViewport(el) {\n  const { top, left, bottom, right } = el.getBoundingClientRect();\n  const { innerHeight, innerWidth } = window;\n  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);\n}\nconst hydrateOnVisible = (opts) => (hydrate, forEach) => {\n  const ob = new IntersectionObserver((entries) => {\n    for (const e of entries) {\n      if (!e.isIntersecting) continue;\n      ob.disconnect();\n      hydrate();\n      break;\n    }\n  }, opts);\n  forEach((el) => {\n    if (!(el instanceof Element)) return;\n    if (elementIsVisibleInViewport(el)) {\n      hydrate();\n      ob.disconnect();\n      return false;\n    }\n    ob.observe(el);\n  });\n  return () => ob.disconnect();\n};\nconst hydrateOnMediaQuery = (query) => (hydrate) => {\n  if (query) {\n    const mql = matchMedia(query);\n    if (mql.matches) {\n      hydrate();\n    } else {\n      mql.addEventListener(\"change\", hydrate, { once: true });\n      return () => mql.removeEventListener(\"change\", hydrate);\n    }\n  }\n};\nconst hydrateOnInteraction = (interactions = []) => (hydrate, forEach) => {\n  if (isString(interactions)) interactions = [interactions];\n  let hasHydrated = false;\n  const doHydrate = (e) => {\n    if (!hasHydrated) {\n      hasHydrated = true;\n      teardown();\n      hydrate();\n      e.target.dispatchEvent(new e.constructor(e.type, e));\n    }\n  };\n  const teardown = () => {\n    forEach((el) => {\n      for (const i of interactions) {\n        el.removeEventListener(i, doHydrate);\n      }\n    });\n  };\n  forEach((el) => {\n    for (const i of interactions) {\n      el.addEventListener(i, doHydrate, { once: true });\n    }\n  });\n  return teardown;\n};\nfunction forEachElement(node, cb) {\n  if (isComment(node) && node.data === \"[\") {\n    let depth = 1;\n    let next = node.nextSibling;\n    while (next) {\n      if (next.nodeType === 1) {\n        const result = cb(next);\n        if (result === false) {\n          break;\n        }\n      } else if (isComment(next)) {\n        if (next.data === \"]\") {\n          if (--depth === 0) break;\n        } else if (next.data === \"[\") {\n          depth++;\n        }\n      }\n      next = next.nextSibling;\n    }\n  } else {\n    cb(node);\n  }\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\n// @__NO_SIDE_EFFECTS__\nfunction defineAsyncComponent(source) {\n  if (isFunction(source)) {\n    source = { loader: source };\n  }\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    hydrate: hydrateStrategy,\n    timeout,\n    // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source;\n  let pendingRequest = null;\n  let resolvedComp;\n  let retries = 0;\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {\n      err = err instanceof Error ? err : new Error(String(err));\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n          const userFail = () => reject(err);\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then((comp) => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n      if (!!(process.env.NODE_ENV !== \"production\") && !comp) {\n        warn$1(\n          `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`\n        );\n      }\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === \"Module\")) {\n        comp = comp.default;\n      }\n      if (!!(process.env.NODE_ENV !== \"production\") && comp && !isObject(comp) && !isFunction(comp)) {\n        throw new Error(`Invalid async component load result: ${comp}`);\n      }\n      resolvedComp = comp;\n      return comp;\n    }));\n  };\n  return defineComponent({\n    name: \"AsyncComponentWrapper\",\n    __asyncLoader: load,\n    __asyncHydrate(el, instance, hydrate) {\n      let patched = false;\n      (instance.bu || (instance.bu = [])).push(() => patched = true);\n      const performHydrate = () => {\n        if (patched) {\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn$1(\n              `Skipping lazy hydration for component '${getComponentName(resolvedComp) || resolvedComp.__file}': it was updated before lazy hydration performed.`\n            );\n          }\n          return;\n        }\n        hydrate();\n      };\n      const doHydrate = hydrateStrategy ? () => {\n        const teardown = hydrateStrategy(\n          performHydrate,\n          (cb) => forEachElement(el, cb)\n        );\n        if (teardown) {\n          (instance.bum || (instance.bum = [])).push(teardown);\n        }\n      } : performHydrate;\n      if (resolvedComp) {\n        doHydrate();\n      } else {\n        load().then(() => !instance.isUnmounted && doHydrate());\n      }\n    },\n    get __asyncResolved() {\n      return resolvedComp;\n    },\n    setup() {\n      const instance = currentInstance;\n      markAsyncBoundary(instance);\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp, instance);\n      }\n      const onError = (err) => {\n        pendingRequest = null;\n        handleError(\n          err,\n          instance,\n          13,\n          !errorComponent\n        );\n      };\n      if (suspensible && instance.suspense || isInSSRComponentSetup) {\n        return load().then((comp) => {\n          return () => createInnerComp(comp, instance);\n        }).catch((err) => {\n          onError(err);\n          return () => errorComponent ? createVNode(errorComponent, {\n            error: err\n          }) : null;\n        });\n      }\n      const loaded = ref(false);\n      const error = ref();\n      const delayed = ref(!!delay);\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false;\n        }, delay);\n      }\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(\n              `Async component timed out after ${timeout}ms.`\n            );\n            onError(err);\n            error.value = err;\n          }\n        }, timeout);\n      }\n      load().then(() => {\n        loaded.value = true;\n        if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n          instance.parent.update();\n        }\n      }).catch((err) => {\n        onError(err);\n        error.value = err;\n      });\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance);\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent, {\n            error: error.value\n          });\n        } else if (loadingComponent && !delayed.value) {\n          return createInnerComp(\n            loadingComponent,\n            instance\n          );\n        }\n      };\n    }\n  });\n}\nfunction createInnerComp(comp, parent) {\n  const { ref: ref2, props, children, ce } = parent.vnode;\n  const vnode = createVNode(comp, props, children);\n  vnode.ref = ref2;\n  vnode.ce = ce;\n  delete parent.vnode.ce;\n  return vnode;\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\nconst KeepAliveImpl = {\n  name: `KeepAlive`,\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const sharedContext = instance.ctx;\n    if (!sharedContext.renderer) {\n      return () => {\n        const children = slots.default && slots.default();\n        return children && children.length === 1 ? children[0] : children;\n      };\n    }\n    const cache = /* @__PURE__ */ new Map();\n    const keys = /* @__PURE__ */ new Set();\n    let current = null;\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      instance.__v_cache = cache;\n    }\n    const parentSuspense = instance.suspense;\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: { createElement }\n      }\n    } = sharedContext;\n    const storageContainer = createElement(\"div\");\n    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {\n      const instance2 = vnode.component;\n      move(vnode, container, anchor, 0, parentSuspense);\n      patch(\n        instance2.vnode,\n        vnode,\n        container,\n        anchor,\n        instance2,\n        parentSuspense,\n        namespace,\n        vnode.slotScopeIds,\n        optimized\n      );\n      queuePostRenderEffect(() => {\n        instance2.isDeactivated = false;\n        if (instance2.a) {\n          invokeArrayFns(instance2.a);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n      }, parentSuspense);\n      if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n        devtoolsComponentAdded(instance2);\n      }\n    };\n    sharedContext.deactivate = (vnode) => {\n      const instance2 = vnode.component;\n      invalidateMount(instance2.m);\n      invalidateMount(instance2.a);\n      move(vnode, storageContainer, null, 1, parentSuspense);\n      queuePostRenderEffect(() => {\n        if (instance2.da) {\n          invokeArrayFns(instance2.da);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n        instance2.isDeactivated = true;\n      }, parentSuspense);\n      if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n        devtoolsComponentAdded(instance2);\n      }\n      if (!!(process.env.NODE_ENV !== \"production\") && true) {\n        instance2.__keepAliveStorageContainer = storageContainer;\n      }\n    };\n    function unmount(vnode) {\n      resetShapeFlag(vnode);\n      _unmount(vnode, instance, parentSuspense, true);\n    }\n    function pruneCache(filter) {\n      cache.forEach((vnode, key) => {\n        const name = getComponentName(vnode.type);\n        if (name && !filter(name)) {\n          pruneCacheEntry(key);\n        }\n      });\n    }\n    function pruneCacheEntry(key) {\n      const cached = cache.get(key);\n      if (cached && (!current || !isSameVNodeType(cached, current))) {\n        unmount(cached);\n      } else if (current) {\n        resetShapeFlag(current);\n      }\n      cache.delete(key);\n      keys.delete(key);\n    }\n    watch(\n      () => [props.include, props.exclude],\n      ([include, exclude]) => {\n        include && pruneCache((name) => matches(include, name));\n        exclude && pruneCache((name) => !matches(exclude, name));\n      },\n      // prune post-render after `current` has been updated\n      { flush: \"post\", deep: true }\n    );\n    let pendingCacheKey = null;\n    const cacheSubtree = () => {\n      if (pendingCacheKey != null) {\n        if (isSuspense(instance.subTree.type)) {\n          queuePostRenderEffect(() => {\n            cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n          }, instance.subTree.suspense);\n        } else {\n          cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n        }\n      }\n    };\n    onMounted(cacheSubtree);\n    onUpdated(cacheSubtree);\n    onBeforeUnmount(() => {\n      cache.forEach((cached) => {\n        const { subTree, suspense } = instance;\n        const vnode = getInnerChild(subTree);\n        if (cached.type === vnode.type && cached.key === vnode.key) {\n          resetShapeFlag(vnode);\n          const da = vnode.component.da;\n          da && queuePostRenderEffect(da, suspense);\n          return;\n        }\n        unmount(cached);\n      });\n    });\n    return () => {\n      pendingCacheKey = null;\n      if (!slots.default) {\n        return current = null;\n      }\n      const children = slots.default();\n      const rawVNode = children[0];\n      if (children.length > 1) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(`KeepAlive should contain exactly one component child.`);\n        }\n        current = null;\n        return children;\n      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {\n        current = null;\n        return rawVNode;\n      }\n      let vnode = getInnerChild(rawVNode);\n      if (vnode.type === Comment) {\n        current = null;\n        return vnode;\n      }\n      const comp = vnode.type;\n      const name = getComponentName(\n        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp\n      );\n      const { include, exclude, max } = props;\n      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n        vnode.shapeFlag &= -257;\n        current = vnode;\n        return rawVNode;\n      }\n      const key = vnode.key == null ? comp : vnode.key;\n      const cachedVNode = cache.get(key);\n      if (vnode.el) {\n        vnode = cloneVNode(vnode);\n        if (rawVNode.shapeFlag & 128) {\n          rawVNode.ssContent = vnode;\n        }\n      }\n      pendingCacheKey = key;\n      if (cachedVNode) {\n        vnode.el = cachedVNode.el;\n        vnode.component = cachedVNode.component;\n        if (vnode.transition) {\n          setTransitionHooks(vnode, vnode.transition);\n        }\n        vnode.shapeFlag |= 512;\n        keys.delete(key);\n        keys.add(key);\n      } else {\n        keys.add(key);\n        if (max && keys.size > parseInt(max, 10)) {\n          pruneCacheEntry(keys.values().next().value);\n        }\n      }\n      vnode.shapeFlag |= 256;\n      current = vnode;\n      return isSuspense(rawVNode.type) ? rawVNode : vnode;\n    };\n  }\n};\nconst KeepAlive = KeepAliveImpl;\nfunction matches(pattern, name) {\n  if (isArray(pattern)) {\n    return pattern.some((p) => matches(p, name));\n  } else if (isString(pattern)) {\n    return pattern.split(\",\").includes(name);\n  } else if (isRegExp(pattern)) {\n    pattern.lastIndex = 0;\n    return pattern.test(name);\n  }\n  return false;\n}\nfunction onActivated(hook, target) {\n  registerKeepAliveHook(hook, \"a\", target);\n}\nfunction onDeactivated(hook, target) {\n  registerKeepAliveHook(hook, \"da\", target);\n}\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\n  const wrappedHook = hook.__wdc || (hook.__wdc = () => {\n    let current = target;\n    while (current) {\n      if (current.isDeactivated) {\n        return;\n      }\n      current = current.parent;\n    }\n    return hook();\n  });\n  injectHook(type, wrappedHook, target);\n  if (target) {\n    let current = target.parent;\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current);\n      }\n      current = current.parent;\n    }\n  }\n}\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n  const injected = injectHook(\n    type,\n    hook,\n    keepAliveRoot,\n    true\n    /* prepend */\n  );\n  onUnmounted(() => {\n    remove(keepAliveRoot[type], injected);\n  }, target);\n}\nfunction resetShapeFlag(vnode) {\n  vnode.shapeFlag &= -257;\n  vnode.shapeFlag &= -513;\n}\nfunction getInnerChild(vnode) {\n  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\n  if (target) {\n    const hooks = target[type] || (target[type] = []);\n    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {\n      pauseTracking();\n      const reset = setCurrentInstance(target);\n      const res = callWithAsyncErrorHandling(hook, target, type, args);\n      reset();\n      resetTracking();\n      return res;\n    });\n    if (prepend) {\n      hooks.unshift(wrappedHook);\n    } else {\n      hooks.push(wrappedHook);\n    }\n    return wrappedHook;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, \"\"));\n    warn$1(\n      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + (` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.` )\n    );\n  }\n}\nconst createHook = (lifecycle) => (hook, target = currentInstance) => {\n  if (!isInSSRComponentSetup || lifecycle === \"sp\") {\n    injectHook(lifecycle, (...args) => hook(...args), target);\n  }\n};\nconst onBeforeMount = createHook(\"bm\");\nconst onMounted = createHook(\"m\");\nconst onBeforeUpdate = createHook(\n  \"bu\"\n);\nconst onUpdated = createHook(\"u\");\nconst onBeforeUnmount = createHook(\n  \"bum\"\n);\nconst onUnmounted = createHook(\"um\");\nconst onServerPrefetch = createHook(\n  \"sp\"\n);\nconst onRenderTriggered = createHook(\"rtg\");\nconst onRenderTracked = createHook(\"rtc\");\nfunction onErrorCaptured(hook, target = currentInstance) {\n  injectHook(\"ec\", hook, target);\n}\n\nconst COMPONENTS = \"components\";\nconst DIRECTIVES = \"directives\";\nfunction resolveComponent(name, maybeSelfReference) {\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\n}\nconst NULL_DYNAMIC_COMPONENT = Symbol.for(\"v-ndc\");\nfunction resolveDynamicComponent(component) {\n  if (isString(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component;\n  } else {\n    return component || NULL_DYNAMIC_COMPONENT;\n  }\n}\nfunction resolveDirective(name) {\n  return resolveAsset(DIRECTIVES, name);\n}\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\n  const instance = currentRenderingInstance || currentInstance;\n  if (instance) {\n    const Component = instance.type;\n    if (type === COMPONENTS) {\n      const selfName = getComponentName(\n        Component,\n        false\n      );\n      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {\n        return Component;\n      }\n    }\n    const res = (\n      // local registration\n      // check instance[type] first which is resolved for options API\n      resolve(instance[type] || Component[type], name) || // global registration\n      resolve(instance.appContext[type], name)\n    );\n    if (!res && maybeSelfReference) {\n      return Component;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && warnMissing && !res) {\n      const extra = type === COMPONENTS ? `\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;\n      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);\n    }\n    return res;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(\n      `resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`\n    );\n  }\n}\nfunction resolve(registry, name) {\n  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);\n}\n\nfunction renderList(source, renderItem, cache, index) {\n  let ret;\n  const cached = cache && cache[index];\n  const sourceIsArray = isArray(source);\n  if (sourceIsArray || isString(source)) {\n    const sourceIsReactiveArray = sourceIsArray && isReactive(source);\n    let needsWrap = false;\n    let isReadonlySource = false;\n    if (sourceIsReactiveArray) {\n      needsWrap = !isShallow(source);\n      isReadonlySource = isReadonly(source);\n      source = shallowReadArray(source);\n    }\n    ret = new Array(source.length);\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(\n        needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],\n        i,\n        void 0,\n        cached && cached[i]\n      );\n    }\n  } else if (typeof source === \"number\") {\n    if (!!(process.env.NODE_ENV !== \"production\") && !Number.isInteger(source)) {\n      warn$1(`The v-for range expect an integer value but got ${source}.`);\n    }\n    ret = new Array(source);\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);\n    }\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      ret = Array.from(\n        source,\n        (item, i) => renderItem(item, i, void 0, cached && cached[i])\n      );\n    } else {\n      const keys = Object.keys(source);\n      ret = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        ret[i] = renderItem(source[key], key, i, cached && cached[i]);\n      }\n    }\n  } else {\n    ret = [];\n  }\n  if (cache) {\n    cache[index] = ret;\n  }\n  return ret;\n}\n\nfunction createSlots(slots, dynamicSlots) {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i];\n    if (isArray(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn;\n      }\n    } else if (slot) {\n      slots[slot.name] = slot.key ? (...args) => {\n        const res = slot.fn(...args);\n        if (res) res.key = slot.key;\n        return res;\n      } : slot.fn;\n    }\n  }\n  return slots;\n}\n\nfunction renderSlot(slots, name, props = {}, fallback, noSlotted) {\n  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {\n    const hasProps = Object.keys(props).length > 0;\n    if (name !== \"default\") props.name = name;\n    return openBlock(), createBlock(\n      Fragment,\n      null,\n      [createVNode(\"slot\", props, fallback && fallback())],\n      hasProps ? -2 : 64\n    );\n  }\n  let slot = slots[name];\n  if (!!(process.env.NODE_ENV !== \"production\") && slot && slot.length > 1) {\n    warn$1(\n      `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`\n    );\n    slot = () => [];\n  }\n  if (slot && slot._c) {\n    slot._d = false;\n  }\n  openBlock();\n  const validSlotContent = slot && ensureValidVNode(slot(props));\n  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch\n  // key attached in the `createSlots` helper, respect that\n  validSlotContent && validSlotContent.key;\n  const rendered = createBlock(\n    Fragment,\n    {\n      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content\n      (!validSlotContent && fallback ? \"_fb\" : \"\")\n    },\n    validSlotContent || (fallback ? fallback() : []),\n    validSlotContent && slots._ === 1 ? 64 : -2\n  );\n  if (!noSlotted && rendered.scopeId) {\n    rendered.slotScopeIds = [rendered.scopeId + \"-s\"];\n  }\n  if (slot && slot._c) {\n    slot._d = true;\n  }\n  return rendered;\n}\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some((child) => {\n    if (!isVNode(child)) return true;\n    if (child.type === Comment) return false;\n    if (child.type === Fragment && !ensureValidVNode(child.children))\n      return false;\n    return true;\n  }) ? vnodes : null;\n}\n\nfunction toHandlers(obj, preserveCaseIfNecessary) {\n  const ret = {};\n  if (!!(process.env.NODE_ENV !== \"production\") && !isObject(obj)) {\n    warn$1(`v-on with no argument expects an object value.`);\n    return ret;\n  }\n  for (const key in obj) {\n    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];\n  }\n  return ret;\n}\n\nconst getPublicInstance = (i) => {\n  if (!i) return null;\n  if (isStatefulComponent(i)) return getComponentPublicInstance(i);\n  return getPublicInstance(i.parent);\n};\nconst publicPropertiesMap = (\n  // Move PURE marker to new line to workaround compiler discarding it\n  // due to type annotation\n  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {\n    $: (i) => i,\n    $el: (i) => i.vnode.el,\n    $data: (i) => i.data,\n    $props: (i) => !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(i.props) : i.props,\n    $attrs: (i) => !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(i.attrs) : i.attrs,\n    $slots: (i) => !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(i.slots) : i.slots,\n    $refs: (i) => !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(i.refs) : i.refs,\n    $parent: (i) => getPublicInstance(i.parent),\n    $root: (i) => getPublicInstance(i.root),\n    $host: (i) => i.ce,\n    $emit: (i) => i.emit,\n    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,\n    $forceUpdate: (i) => i.f || (i.f = () => {\n      queueJob(i.update);\n    }),\n    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),\n    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP\n  })\n);\nconst isReservedPrefix = (key) => key === \"_\" || key === \"$\";\nconst hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);\nconst PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    if (key === \"__v_skip\") {\n      return true;\n    }\n    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\n    if (!!(process.env.NODE_ENV !== \"production\") && key === \"__isVue\") {\n      return true;\n    }\n    let normalizedProps;\n    if (key[0] !== \"$\") {\n      const n = accessCache[key];\n      if (n !== void 0) {\n        switch (n) {\n          case 1 /* SETUP */:\n            return setupState[key];\n          case 2 /* DATA */:\n            return data[key];\n          case 4 /* CONTEXT */:\n            return ctx[key];\n          case 3 /* PROPS */:\n            return props[key];\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache[key] = 1 /* SETUP */;\n        return setupState[key];\n      } else if (__VUE_OPTIONS_API__ && data !== EMPTY_OBJ && hasOwn(data, key)) {\n        accessCache[key] = 2 /* DATA */;\n        return data[key];\n      } else if (\n        // only cache other properties when instance has declared (thus stable)\n        // props\n        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)\n      ) {\n        accessCache[key] = 3 /* PROPS */;\n        return props[key];\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        accessCache[key] = 4 /* CONTEXT */;\n        return ctx[key];\n      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {\n        accessCache[key] = 0 /* OTHER */;\n      }\n    }\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    if (publicGetter) {\n      if (key === \"$attrs\") {\n        track(instance.attrs, \"get\", \"\");\n        !!(process.env.NODE_ENV !== \"production\") && markAttrsAccessed();\n      } else if (!!(process.env.NODE_ENV !== \"production\") && key === \"$slots\") {\n        track(instance, \"get\", key);\n      }\n      return publicGetter(instance);\n    } else if (\n      // css module (injected by vue-loader)\n      (cssModule = type.__cssModules) && (cssModule = cssModule[key])\n    ) {\n      return cssModule;\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n      accessCache[key] = 4 /* CONTEXT */;\n      return ctx[key];\n    } else if (\n      // global properties\n      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)\n    ) {\n      {\n        return globalProperties[key];\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\") && currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading\n    // to infinite warning loop\n    key.indexOf(\"__v\") !== 0)) {\n      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {\n        warn$1(\n          `Property ${JSON.stringify(\n            key\n          )} must be accessed via $data because it starts with a reserved character (\"$\" or \"_\") and is not proxied on the render context.`\n        );\n      } else if (instance === currentRenderingInstance) {\n        warn$1(\n          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`\n        );\n      }\n    }\n  },\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance;\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value;\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\") && setupState.__isScriptSetup && hasOwn(setupState, key)) {\n      warn$1(`Cannot mutate <script setup> binding \"${key}\" from Options API.`);\n      return false;\n    } else if (__VUE_OPTIONS_API__ && data !== EMPTY_OBJ && hasOwn(data, key)) {\n      data[key] = value;\n      return true;\n    } else if (hasOwn(instance.props, key)) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(`Attempting to mutate prop \"${key}\". Props are readonly.`);\n      return false;\n    }\n    if (key[0] === \"$\" && key.slice(1) in instance) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(\n        `Attempting to mutate public property \"${key}\". Properties starting with $ are reserved and readonly.`\n      );\n      return false;\n    } else {\n      if (!!(process.env.NODE_ENV !== \"production\") && key in instance.appContext.config.globalProperties) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          value\n        });\n      } else {\n        ctx[key] = value;\n      }\n    }\n    return true;\n  },\n  has({\n    _: { data, setupState, accessCache, ctx, appContext, propsOptions, type }\n  }, key) {\n    let normalizedProps, cssModules;\n    return !!(accessCache[key] || __VUE_OPTIONS_API__ && data !== EMPTY_OBJ && key[0] !== \"$\" && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);\n  },\n  defineProperty(target, key, descriptor) {\n    if (descriptor.get != null) {\n      target._.accessCache[key] = 0;\n    } else if (hasOwn(descriptor, \"value\")) {\n      this.set(target, key, descriptor.value, null);\n    }\n    return Reflect.defineProperty(target, key, descriptor);\n  }\n};\nif (!!(process.env.NODE_ENV !== \"production\") && true) {\n  PublicInstanceProxyHandlers.ownKeys = (target) => {\n    warn$1(\n      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`\n    );\n    return Reflect.ownKeys(target);\n  };\n}\nconst RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {\n  get(target, key) {\n    if (key === Symbol.unscopables) {\n      return;\n    }\n    return PublicInstanceProxyHandlers.get(target, key, target);\n  },\n  has(_, key) {\n    const has = key[0] !== \"_\" && !isGloballyAllowed(key);\n    if (!!(process.env.NODE_ENV !== \"production\") && !has && PublicInstanceProxyHandlers.has(_, key)) {\n      warn$1(\n        `Property ${JSON.stringify(\n          key\n        )} should not start with _ which is a reserved prefix for Vue internals.`\n      );\n    }\n    return has;\n  }\n});\nfunction createDevRenderContext(instance) {\n  const target = {};\n  Object.defineProperty(target, `_`, {\n    configurable: true,\n    enumerable: false,\n    get: () => instance\n  });\n  Object.keys(publicPropertiesMap).forEach((key) => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => publicPropertiesMap[key](instance),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: NOOP\n    });\n  });\n  return target;\n}\nfunction exposePropsOnRenderContext(instance) {\n  const {\n    ctx,\n    propsOptions: [propsOptions]\n  } = instance;\n  if (propsOptions) {\n    Object.keys(propsOptions).forEach((key) => {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => instance.props[key],\n        set: NOOP\n      });\n    });\n  }\n}\nfunction exposeSetupStateOnRenderContext(instance) {\n  const { ctx, setupState } = instance;\n  Object.keys(toRaw(setupState)).forEach((key) => {\n    if (!setupState.__isScriptSetup) {\n      if (isReservedPrefix(key[0])) {\n        warn$1(\n          `setup() return property ${JSON.stringify(\n            key\n          )} should not start with \"$\" or \"_\" which are reserved prefixes for Vue internals.`\n        );\n        return;\n      }\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => setupState[key],\n        set: NOOP\n      });\n    }\n  });\n}\n\nconst warnRuntimeUsage = (method) => warn$1(\n  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`\n);\nfunction defineProps() {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineProps`);\n  }\n  return null;\n}\nfunction defineEmits() {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineEmits`);\n  }\n  return null;\n}\nfunction defineExpose(exposed) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineExpose`);\n  }\n}\nfunction defineOptions(options) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineOptions`);\n  }\n}\nfunction defineSlots() {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineSlots`);\n  }\n  return null;\n}\nfunction defineModel() {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(\"defineModel\");\n  }\n}\nfunction withDefaults(props, defaults) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`withDefaults`);\n  }\n  return null;\n}\nfunction useSlots() {\n  return getContext(\"useSlots\").slots;\n}\nfunction useAttrs() {\n  return getContext(\"useAttrs\").attrs;\n}\nfunction getContext(calledFunctionName) {\n  const i = getCurrentInstance();\n  if (!!(process.env.NODE_ENV !== \"production\") && !i) {\n    warn$1(`${calledFunctionName}() called without active instance.`);\n  }\n  return i.setupContext || (i.setupContext = createSetupContext(i));\n}\nfunction normalizePropsOrEmits(props) {\n  return isArray(props) ? props.reduce(\n    (normalized, p) => (normalized[p] = null, normalized),\n    {}\n  ) : props;\n}\nfunction mergeDefaults(raw, defaults) {\n  const props = normalizePropsOrEmits(raw);\n  for (const key in defaults) {\n    if (key.startsWith(\"__skip\")) continue;\n    let opt = props[key];\n    if (opt) {\n      if (isArray(opt) || isFunction(opt)) {\n        opt = props[key] = { type: opt, default: defaults[key] };\n      } else {\n        opt.default = defaults[key];\n      }\n    } else if (opt === null) {\n      opt = props[key] = { default: defaults[key] };\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(`props default key \"${key}\" has no corresponding declaration.`);\n    }\n    if (opt && defaults[`__skip_${key}`]) {\n      opt.skipFactory = true;\n    }\n  }\n  return props;\n}\nfunction mergeModels(a, b) {\n  if (!a || !b) return a || b;\n  if (isArray(a) && isArray(b)) return a.concat(b);\n  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));\n}\nfunction createPropsRestProxy(props, excludedKeys) {\n  const ret = {};\n  for (const key in props) {\n    if (!excludedKeys.includes(key)) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        get: () => props[key]\n      });\n    }\n  }\n  return ret;\n}\nfunction withAsyncContext(getAwaitable) {\n  const ctx = getCurrentInstance();\n  if (!!(process.env.NODE_ENV !== \"production\") && !ctx) {\n    warn$1(\n      `withAsyncContext called without active current instance. This is likely a bug.`\n    );\n  }\n  let awaitable = getAwaitable();\n  unsetCurrentInstance();\n  if (isPromise(awaitable)) {\n    awaitable = awaitable.catch((e) => {\n      setCurrentInstance(ctx);\n      throw e;\n    });\n  }\n  return [awaitable, () => setCurrentInstance(ctx)];\n}\n\nfunction createDuplicateChecker() {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (type, key) => {\n    if (cache[key]) {\n      warn$1(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\n    } else {\n      cache[key] = type;\n    }\n  };\n}\nlet shouldCacheAccess = true;\nfunction applyOptions(instance) {\n  const options = resolveMergedOptions(instance);\n  const publicThis = instance.proxy;\n  const ctx = instance.ctx;\n  shouldCacheAccess = false;\n  if (options.beforeCreate) {\n    callHook(options.beforeCreate, instance, \"bc\");\n  }\n  const {\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // lifecycle\n    created,\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured,\n    serverPrefetch,\n    // public API\n    expose,\n    inheritAttrs,\n    // assets\n    components,\n    directives,\n    filters\n  } = options;\n  const checkDuplicateProperties = !!(process.env.NODE_ENV !== \"production\") ? createDuplicateChecker() : null;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const [propsOptions] = instance.propsOptions;\n    if (propsOptions) {\n      for (const key in propsOptions) {\n        checkDuplicateProperties(\"Props\" /* PROPS */, key);\n      }\n    }\n  }\n  if (injectOptions) {\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties);\n  }\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = methods[key];\n      if (isFunction(methodHandler)) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          Object.defineProperty(ctx, key, {\n            value: methodHandler.bind(publicThis),\n            configurable: true,\n            enumerable: true,\n            writable: true\n          });\n        } else {\n          ctx[key] = methodHandler.bind(publicThis);\n        }\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkDuplicateProperties(\"Methods\" /* METHODS */, key);\n        }\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        warn$1(\n          `Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. Did you reference the function correctly?`\n        );\n      }\n    }\n  }\n  if (dataOptions) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !isFunction(dataOptions)) {\n      warn$1(\n        `The data option must be a function. Plain object usage is no longer supported.`\n      );\n    }\n    const data = dataOptions.call(publicThis, publicThis);\n    if (!!(process.env.NODE_ENV !== \"production\") && isPromise(data)) {\n      warn$1(\n        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`\n      );\n    }\n    if (!isObject(data)) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(`data() should return an object.`);\n    } else {\n      instance.data = reactive(data);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (const key in data) {\n          checkDuplicateProperties(\"Data\" /* DATA */, key);\n          if (!isReservedPrefix(key[0])) {\n            Object.defineProperty(ctx, key, {\n              configurable: true,\n              enumerable: true,\n              get: () => data[key],\n              set: NOOP\n            });\n          }\n        }\n      }\n    }\n  }\n  shouldCacheAccess = true;\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = computedOptions[key];\n      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;\n      if (!!(process.env.NODE_ENV !== \"production\") && get === NOOP) {\n        warn$1(`Computed property \"${key}\" has no getter.`);\n      }\n      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : !!(process.env.NODE_ENV !== \"production\") ? () => {\n        warn$1(\n          `Write operation failed: computed property \"${key}\" is readonly.`\n        );\n      } : NOOP;\n      const c = computed({\n        get,\n        set\n      });\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: (v) => c.value = v\n      });\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        checkDuplicateProperties(\"Computed\" /* COMPUTED */, key);\n      }\n    }\n  }\n  if (watchOptions) {\n    for (const key in watchOptions) {\n      createWatcher(watchOptions[key], ctx, publicThis, key);\n    }\n  }\n  if (provideOptions) {\n    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;\n    Reflect.ownKeys(provides).forEach((key) => {\n      provide(key, provides[key]);\n    });\n  }\n  if (created) {\n    callHook(created, instance, \"c\");\n  }\n  function registerLifecycleHook(register, hook) {\n    if (isArray(hook)) {\n      hook.forEach((_hook) => register(_hook.bind(publicThis)));\n    } else if (hook) {\n      register(hook.bind(publicThis));\n    }\n  }\n  registerLifecycleHook(onBeforeMount, beforeMount);\n  registerLifecycleHook(onMounted, mounted);\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate);\n  registerLifecycleHook(onUpdated, updated);\n  registerLifecycleHook(onActivated, activated);\n  registerLifecycleHook(onDeactivated, deactivated);\n  registerLifecycleHook(onErrorCaptured, errorCaptured);\n  registerLifecycleHook(onRenderTracked, renderTracked);\n  registerLifecycleHook(onRenderTriggered, renderTriggered);\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount);\n  registerLifecycleHook(onUnmounted, unmounted);\n  registerLifecycleHook(onServerPrefetch, serverPrefetch);\n  if (isArray(expose)) {\n    if (expose.length) {\n      const exposed = instance.exposed || (instance.exposed = {});\n      expose.forEach((key) => {\n        Object.defineProperty(exposed, key, {\n          get: () => publicThis[key],\n          set: (val) => publicThis[key] = val,\n          enumerable: true\n        });\n      });\n    } else if (!instance.exposed) {\n      instance.exposed = {};\n    }\n  }\n  if (render && instance.render === NOOP) {\n    instance.render = render;\n  }\n  if (inheritAttrs != null) {\n    instance.inheritAttrs = inheritAttrs;\n  }\n  if (components) instance.components = components;\n  if (directives) instance.directives = directives;\n  if (serverPrefetch) {\n    markAsyncBoundary(instance);\n  }\n}\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {\n  if (isArray(injectOptions)) {\n    injectOptions = normalizeInject(injectOptions);\n  }\n  for (const key in injectOptions) {\n    const opt = injectOptions[key];\n    let injected;\n    if (isObject(opt)) {\n      if (\"default\" in opt) {\n        injected = inject(\n          opt.from || key,\n          opt.default,\n          true\n        );\n      } else {\n        injected = inject(opt.from || key);\n      }\n    } else {\n      injected = inject(opt);\n    }\n    if (isRef(injected)) {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => injected.value,\n        set: (v) => injected.value = v\n      });\n    } else {\n      ctx[key] = injected;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      checkDuplicateProperties(\"Inject\" /* INJECT */, key);\n    }\n  }\n}\nfunction callHook(hook, instance, type) {\n  callWithAsyncErrorHandling(\n    isArray(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),\n    instance,\n    type\n  );\n}\nfunction createWatcher(raw, ctx, publicThis, key) {\n  let getter = key.includes(\".\") ? createPathGetter(publicThis, key) : () => publicThis[key];\n  if (isString(raw)) {\n    const handler = ctx[raw];\n    if (isFunction(handler)) {\n      {\n        watch(getter, handler);\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(`Invalid watch handler specified by key \"${raw}\"`, handler);\n    }\n  } else if (isFunction(raw)) {\n    {\n      watch(getter, raw.bind(publicThis));\n    }\n  } else if (isObject(raw)) {\n    if (isArray(raw)) {\n      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));\n    } else {\n      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];\n      if (isFunction(handler)) {\n        watch(getter, handler, raw);\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        warn$1(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\n      }\n    }\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(`Invalid watch option: \"${key}\"`, raw);\n  }\n}\nfunction resolveMergedOptions(instance) {\n  const base = instance.type;\n  const { mixins, extends: extendsOptions } = base;\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: { optionMergeStrategies }\n  } = instance.appContext;\n  const cached = cache.get(base);\n  let resolved;\n  if (cached) {\n    resolved = cached;\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    {\n      resolved = base;\n    }\n  } else {\n    resolved = {};\n    if (globalMixins.length) {\n      globalMixins.forEach(\n        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)\n      );\n    }\n    mergeOptions(resolved, base, optionMergeStrategies);\n  }\n  if (isObject(base)) {\n    cache.set(base, resolved);\n  }\n  return resolved;\n}\nfunction mergeOptions(to, from, strats, asMixin = false) {\n  const { mixins, extends: extendsOptions } = from;\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true);\n  }\n  if (mixins) {\n    mixins.forEach(\n      (m) => mergeOptions(to, m, strats, true)\n    );\n  }\n  for (const key in from) {\n    if (asMixin && key === \"expose\") {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(\n        `\"expose\" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`\n      );\n    } else {\n      const strat = internalOptionMergeStrats[key] || strats && strats[key];\n      to[key] = strat ? strat(to[key], from[key]) : from[key];\n    }\n  }\n  return to;\n}\nconst internalOptionMergeStrats = {\n  data: mergeDataFn,\n  props: mergeEmitsOrPropsOptions,\n  emits: mergeEmitsOrPropsOptions,\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n};\nfunction mergeDataFn(to, from) {\n  if (!from) {\n    return to;\n  }\n  if (!to) {\n    return from;\n  }\n  return function mergedDataFn() {\n    return (extend)(\n      isFunction(to) ? to.call(this, this) : to,\n      isFunction(from) ? from.call(this, this) : from\n    );\n  };\n}\nfunction mergeInject(to, from) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\nfunction normalizeInject(raw) {\n  if (isArray(raw)) {\n    const res = {};\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i];\n    }\n    return res;\n  }\n  return raw;\n}\nfunction mergeAsArray(to, from) {\n  return to ? [...new Set([].concat(to, from))] : from;\n}\nfunction mergeObjectOptions(to, from) {\n  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;\n}\nfunction mergeEmitsOrPropsOptions(to, from) {\n  if (to) {\n    if (isArray(to) && isArray(from)) {\n      return [.../* @__PURE__ */ new Set([...to, ...from])];\n    }\n    return extend(\n      /* @__PURE__ */ Object.create(null),\n      normalizePropsOrEmits(to),\n      normalizePropsOrEmits(from != null ? from : {})\n    );\n  } else {\n    return from;\n  }\n}\nfunction mergeWatchOptions(to, from) {\n  if (!to) return from;\n  if (!from) return to;\n  const merged = extend(/* @__PURE__ */ Object.create(null), to);\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key]);\n  }\n  return merged;\n}\n\nfunction createAppContext() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: void 0,\n      warnHandler: void 0,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: /* @__PURE__ */ Object.create(null),\n    optionsCache: /* @__PURE__ */ new WeakMap(),\n    propsCache: /* @__PURE__ */ new WeakMap(),\n    emitsCache: /* @__PURE__ */ new WeakMap()\n  };\n}\nlet uid$1 = 0;\nfunction createAppAPI(render, hydrate) {\n  return function createApp(rootComponent, rootProps = null) {\n    if (!isFunction(rootComponent)) {\n      rootComponent = extend({}, rootComponent);\n    }\n    if (rootProps != null && !isObject(rootProps)) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(`root props passed to app.mount() must be an object.`);\n      rootProps = null;\n    }\n    const context = createAppContext();\n    const installedPlugins = /* @__PURE__ */ new WeakSet();\n    const pluginCleanupFns = [];\n    let isMounted = false;\n    const app = context.app = {\n      _uid: uid$1++,\n      _component: rootComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n      version,\n      get config() {\n        return context.config;\n      },\n      set config(v) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\n            `app.config cannot be replaced. Modify individual options instead.`\n          );\n        }\n      },\n      use(plugin, ...options) {\n        if (installedPlugins.has(plugin)) {\n          !!(process.env.NODE_ENV !== \"production\") && warn$1(`Plugin has already been applied to target app.`);\n        } else if (plugin && isFunction(plugin.install)) {\n          installedPlugins.add(plugin);\n          plugin.install(app, ...options);\n        } else if (isFunction(plugin)) {\n          installedPlugins.add(plugin);\n          plugin(app, ...options);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\n            `A plugin must either be a function or an object with an \"install\" function.`\n          );\n        }\n        return app;\n      },\n      mixin(mixin) {\n        if (__VUE_OPTIONS_API__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin);\n          } else if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn$1(\n              \"Mixin has already been applied to target app\" + (mixin.name ? `: ${mixin.name}` : \"\")\n            );\n          }\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\"Mixins are only available in builds supporting Options API\");\n        }\n        return app;\n      },\n      component(name, component) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          validateComponentName(name, context.config);\n        }\n        if (!component) {\n          return context.components[name];\n        }\n        if (!!(process.env.NODE_ENV !== \"production\") && context.components[name]) {\n          warn$1(`Component \"${name}\" has already been registered in target app.`);\n        }\n        context.components[name] = component;\n        return app;\n      },\n      directive(name, directive) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          validateDirectiveName(name);\n        }\n        if (!directive) {\n          return context.directives[name];\n        }\n        if (!!(process.env.NODE_ENV !== \"production\") && context.directives[name]) {\n          warn$1(`Directive \"${name}\" has already been registered in target app.`);\n        }\n        context.directives[name] = directive;\n        return app;\n      },\n      mount(rootContainer, isHydrate, namespace) {\n        if (!isMounted) {\n          if (!!(process.env.NODE_ENV !== \"production\") && rootContainer.__vue_app__) {\n            warn$1(\n              `There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling \\`app.unmount()\\` first.`\n            );\n          }\n          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);\n          vnode.appContext = context;\n          if (namespace === true) {\n            namespace = \"svg\";\n          } else if (namespace === false) {\n            namespace = void 0;\n          }\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            context.reload = () => {\n              const cloned = cloneVNode(vnode);\n              cloned.el = null;\n              render(cloned, rootContainer, namespace);\n            };\n          }\n          if (isHydrate && hydrate) {\n            hydrate(vnode, rootContainer);\n          } else {\n            render(vnode, rootContainer, namespace);\n          }\n          isMounted = true;\n          app._container = rootContainer;\n          rootContainer.__vue_app__ = app;\n          if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n            app._instance = vnode.component;\n            devtoolsInitApp(app, version);\n          }\n          return getComponentPublicInstance(vnode.component);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\n            `App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \\`const createMyApp = () => createApp(App)\\``\n          );\n        }\n      },\n      onUnmount(cleanupFn) {\n        if (!!(process.env.NODE_ENV !== \"production\") && typeof cleanupFn !== \"function\") {\n          warn$1(\n            `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`\n          );\n        }\n        pluginCleanupFns.push(cleanupFn);\n      },\n      unmount() {\n        if (isMounted) {\n          callWithAsyncErrorHandling(\n            pluginCleanupFns,\n            app._instance,\n            16\n          );\n          render(null, app._container);\n          if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n            app._instance = null;\n            devtoolsUnmountApp(app);\n          }\n          delete app._container.__vue_app__;\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(`Cannot unmount an app that is not mounted.`);\n        }\n      },\n      provide(key, value) {\n        if (!!(process.env.NODE_ENV !== \"production\") && key in context.provides) {\n          if (hasOwn(context.provides, key)) {\n            warn$1(\n              `App already provides property with key \"${String(key)}\". It will be overwritten with the new value.`\n            );\n          } else {\n            warn$1(\n              `App already provides property with key \"${String(key)}\" inherited from its parent element. It will be overwritten with the new value.`\n            );\n          }\n        }\n        context.provides[key] = value;\n        return app;\n      },\n      runWithContext(fn) {\n        const lastApp = currentApp;\n        currentApp = app;\n        try {\n          return fn();\n        } finally {\n          currentApp = lastApp;\n        }\n      }\n    };\n    return app;\n  };\n}\nlet currentApp = null;\n\nfunction provide(key, value) {\n  if (!currentInstance) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(`provide() can only be used inside setup().`);\n    }\n  } else {\n    let provides = currentInstance.provides;\n    const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n    provides[key] = value;\n  }\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n  const instance = getCurrentInstance();\n  if (instance || currentApp) {\n    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;\n    if (provides && key in provides) {\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(`injection \"${String(key)}\" not found.`);\n    }\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(`inject() can only be used inside setup() or functional components.`);\n  }\n}\nfunction hasInjectionContext() {\n  return !!(getCurrentInstance() || currentApp);\n}\n\nconst internalObjectProto = {};\nconst createInternalObject = () => Object.create(internalObjectProto);\nconst isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;\n\nfunction initProps(instance, rawProps, isStateful, isSSR = false) {\n  const props = {};\n  const attrs = createInternalObject();\n  instance.propsDefaults = /* @__PURE__ */ Object.create(null);\n  setFullProps(instance, rawProps, props, attrs);\n  for (const key in instance.propsOptions[0]) {\n    if (!(key in props)) {\n      props[key] = void 0;\n    }\n  }\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    validateProps(rawProps || {}, props, instance);\n  }\n  if (isStateful) {\n    instance.props = isSSR ? props : shallowReactive(props);\n  } else {\n    if (!instance.type.props) {\n      instance.props = attrs;\n    } else {\n      instance.props = props;\n    }\n  }\n  instance.attrs = attrs;\n}\nfunction isInHmrContext(instance) {\n  while (instance) {\n    if (instance.type.__hmrId) return true;\n    instance = instance.parent;\n  }\n}\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n  const {\n    props,\n    attrs,\n    vnode: { patchFlag }\n  } = instance;\n  const rawCurrentProps = toRaw(props);\n  const [options] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  if (\n    // always force full diff in dev\n    // - #1942 if hmr is enabled with sfc component\n    // - vite#872 non-sfc component used by sfc component\n    !(!!(process.env.NODE_ENV !== \"production\") && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)\n  ) {\n    if (patchFlag & 8) {\n      const propsToUpdate = instance.vnode.dynamicProps;\n      for (let i = 0; i < propsToUpdate.length; i++) {\n        let key = propsToUpdate[i];\n        if (isEmitListener(instance.emitsOptions, key)) {\n          continue;\n        }\n        const value = rawProps[key];\n        if (options) {\n          if (hasOwn(attrs, key)) {\n            if (value !== attrs[key]) {\n              attrs[key] = value;\n              hasAttrsChanged = true;\n            }\n          } else {\n            const camelizedKey = camelize(key);\n            props[camelizedKey] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              camelizedKey,\n              value,\n              instance,\n              false\n            );\n          }\n        } else {\n          if (value !== attrs[key]) {\n            attrs[key] = value;\n            hasAttrsChanged = true;\n          }\n        }\n      }\n    }\n  } else {\n    if (setFullProps(instance, rawProps, props, attrs)) {\n      hasAttrsChanged = true;\n    }\n    let kebabKey;\n    for (const key in rawCurrentProps) {\n      if (!rawProps || // for camelCase\n      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {\n        if (options) {\n          if (rawPrevProps && // for camelCase\n          (rawPrevProps[key] !== void 0 || // for kebab-case\n          rawPrevProps[kebabKey] !== void 0)) {\n            props[key] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              key,\n              void 0,\n              instance,\n              true\n            );\n          }\n        } else {\n          delete props[key];\n        }\n      }\n    }\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (!rawProps || !hasOwn(rawProps, key) && true) {\n          delete attrs[key];\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (hasAttrsChanged) {\n    trigger(instance.attrs, \"set\", \"\");\n  }\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    validateProps(rawProps || {}, props, instance);\n  }\n}\nfunction setFullProps(instance, rawProps, props, attrs) {\n  const [options, needCastKeys] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  let rawCastValues;\n  if (rawProps) {\n    for (let key in rawProps) {\n      if (isReservedProp(key)) {\n        continue;\n      }\n      const value = rawProps[key];\n      let camelKey;\n      if (options && hasOwn(options, camelKey = camelize(key))) {\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n          props[camelKey] = value;\n        } else {\n          (rawCastValues || (rawCastValues = {}))[camelKey] = value;\n        }\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        if (!(key in attrs) || value !== attrs[key]) {\n          attrs[key] = value;\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (needCastKeys) {\n    const rawCurrentProps = toRaw(props);\n    const castValues = rawCastValues || EMPTY_OBJ;\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i];\n      props[key] = resolvePropValue(\n        options,\n        rawCurrentProps,\n        key,\n        castValues[key],\n        instance,\n        !hasOwn(castValues, key)\n      );\n    }\n  }\n  return hasAttrsChanged;\n}\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\n  const opt = options[key];\n  if (opt != null) {\n    const hasDefault = hasOwn(opt, \"default\");\n    if (hasDefault && value === void 0) {\n      const defaultValue = opt.default;\n      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {\n        const { propsDefaults } = instance;\n        if (key in propsDefaults) {\n          value = propsDefaults[key];\n        } else {\n          const reset = setCurrentInstance(instance);\n          value = propsDefaults[key] = defaultValue.call(\n            null,\n            props\n          );\n          reset();\n        }\n      } else {\n        value = defaultValue;\n      }\n      if (instance.ce) {\n        instance.ce._setProp(key, value);\n      }\n    }\n    if (opt[0 /* shouldCast */]) {\n      if (isAbsent && !hasDefault) {\n        value = false;\n      } else if (opt[1 /* shouldCastTrue */] && (value === \"\" || value === hyphenate(key))) {\n        value = true;\n      }\n    }\n  }\n  return value;\n}\nconst mixinPropsCache = /* @__PURE__ */ new WeakMap();\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\n  const cache = __VUE_OPTIONS_API__ && asMixin ? mixinPropsCache : appContext.propsCache;\n  const cached = cache.get(comp);\n  if (cached) {\n    return cached;\n  }\n  const raw = comp.props;\n  const normalized = {};\n  const needCastKeys = [];\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\n    const extendProps = (raw2) => {\n      hasExtends = true;\n      const [props, keys] = normalizePropsOptions(raw2, appContext, true);\n      extend(normalized, props);\n      if (keys) needCastKeys.push(...keys);\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps);\n    }\n    if (comp.extends) {\n      extendProps(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if (isObject(comp)) {\n      cache.set(comp, EMPTY_ARR);\n    }\n    return EMPTY_ARR;\n  }\n  if (isArray(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      if (!!(process.env.NODE_ENV !== \"production\") && !isString(raw[i])) {\n        warn$1(`props must be strings when using array syntax.`, raw[i]);\n      }\n      const normalizedKey = camelize(raw[i]);\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = EMPTY_OBJ;\n      }\n    }\n  } else if (raw) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !isObject(raw)) {\n      warn$1(`invalid props options`, raw);\n    }\n    for (const key in raw) {\n      const normalizedKey = camelize(key);\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key];\n        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);\n        const propType = prop.type;\n        let shouldCast = false;\n        let shouldCastTrue = true;\n        if (isArray(propType)) {\n          for (let index = 0; index < propType.length; ++index) {\n            const type = propType[index];\n            const typeName = isFunction(type) && type.name;\n            if (typeName === \"Boolean\") {\n              shouldCast = true;\n              break;\n            } else if (typeName === \"String\") {\n              shouldCastTrue = false;\n            }\n          }\n        } else {\n          shouldCast = isFunction(propType) && propType.name === \"Boolean\";\n        }\n        prop[0 /* shouldCast */] = shouldCast;\n        prop[1 /* shouldCastTrue */] = shouldCastTrue;\n        if (shouldCast || hasOwn(prop, \"default\")) {\n          needCastKeys.push(normalizedKey);\n        }\n      }\n    }\n  }\n  const res = [normalized, needCastKeys];\n  if (isObject(comp)) {\n    cache.set(comp, res);\n  }\n  return res;\n}\nfunction validatePropName(key) {\n  if (key[0] !== \"$\" && !isReservedProp(key)) {\n    return true;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(`Invalid prop name: \"${key}\" is a reserved property.`);\n  }\n  return false;\n}\nfunction getType(ctor) {\n  if (ctor === null) {\n    return \"null\";\n  }\n  if (typeof ctor === \"function\") {\n    return ctor.name || \"\";\n  } else if (typeof ctor === \"object\") {\n    const name = ctor.constructor && ctor.constructor.name;\n    return name || \"\";\n  }\n  return \"\";\n}\nfunction validateProps(rawProps, props, instance) {\n  const resolvedValues = toRaw(props);\n  const options = instance.propsOptions[0];\n  const camelizePropsKey = Object.keys(rawProps).map((key) => camelize(key));\n  for (const key in options) {\n    let opt = options[key];\n    if (opt == null) continue;\n    validateProp(\n      key,\n      resolvedValues[key],\n      opt,\n      !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(resolvedValues) : resolvedValues,\n      !camelizePropsKey.includes(key)\n    );\n  }\n}\nfunction validateProp(name, value, prop, props, isAbsent) {\n  const { type, required, validator, skipCheck } = prop;\n  if (required && isAbsent) {\n    warn$1('Missing required prop: \"' + name + '\"');\n    return;\n  }\n  if (value == null && !required) {\n    return;\n  }\n  if (type != null && type !== true && !skipCheck) {\n    let isValid = false;\n    const types = isArray(type) ? type : [type];\n    const expectedTypes = [];\n    for (let i = 0; i < types.length && !isValid; i++) {\n      const { valid, expectedType } = assertType(value, types[i]);\n      expectedTypes.push(expectedType || \"\");\n      isValid = valid;\n    }\n    if (!isValid) {\n      warn$1(getInvalidTypeMessage(name, value, expectedTypes));\n      return;\n    }\n  }\n  if (validator && !validator(value, props)) {\n    warn$1('Invalid prop: custom validator check failed for prop \"' + name + '\".');\n  }\n}\nconst isSimpleType = /* @__PURE__ */ makeMap(\n  \"String,Number,Boolean,Function,Symbol,BigInt\"\n);\nfunction assertType(value, type) {\n  let valid;\n  const expectedType = getType(type);\n  if (expectedType === \"null\") {\n    valid = value === null;\n  } else if (isSimpleType(expectedType)) {\n    const t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    if (!valid && t === \"object\") {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === \"Object\") {\n    valid = isObject(value);\n  } else if (expectedType === \"Array\") {\n    valid = isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid,\n    expectedType\n  };\n}\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  if (expectedTypes.length === 0) {\n    return `Prop type [] for prop \"${name}\" won't match anything. Did you mean to use type Array instead?`;\n  }\n  let message = `Invalid prop: type check failed for prop \"${name}\". Expected ${expectedTypes.map(capitalize).join(\" | \")}`;\n  const expectedType = expectedTypes[0];\n  const receivedType = toRawType(value);\n  const expectedValue = styleValue(value, expectedType);\n  const receivedValue = styleValue(value, receivedType);\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += ` with value ${expectedValue}`;\n  }\n  message += `, got ${receivedType} `;\n  if (isExplicable(receivedType)) {\n    message += `with value ${receivedValue}.`;\n  }\n  return message;\n}\nfunction styleValue(value, type) {\n  if (type === \"String\") {\n    return `\"${value}\"`;\n  } else if (type === \"Number\") {\n    return `${Number(value)}`;\n  } else {\n    return `${value}`;\n  }\n}\nfunction isExplicable(type) {\n  const explicitTypes = [\"string\", \"number\", \"boolean\"];\n  return explicitTypes.some((elem) => type.toLowerCase() === elem);\n}\nfunction isBoolean(...args) {\n  return args.some((elem) => elem.toLowerCase() === \"boolean\");\n}\n\nconst isInternalKey = (key) => key === \"_\" || key === \"_ctx\" || key === \"$stable\";\nconst normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];\nconst normalizeSlot = (key, rawSlot, ctx) => {\n  if (rawSlot._n) {\n    return rawSlot;\n  }\n  const normalized = withCtx((...args) => {\n    if (!!(process.env.NODE_ENV !== \"production\") && currentInstance && !(ctx === null && currentRenderingInstance) && !(ctx && ctx.root !== currentInstance.root)) {\n      warn$1(\n        `Slot \"${key}\" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`\n      );\n    }\n    return normalizeSlotValue(rawSlot(...args));\n  }, ctx);\n  normalized._c = false;\n  return normalized;\n};\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\n  const ctx = rawSlots._ctx;\n  for (const key in rawSlots) {\n    if (isInternalKey(key)) continue;\n    const value = rawSlots[key];\n    if (isFunction(value)) {\n      slots[key] = normalizeSlot(key, value, ctx);\n    } else if (value != null) {\n      if (!!(process.env.NODE_ENV !== \"production\") && true) {\n        warn$1(\n          `Non-function value encountered for slot \"${key}\". Prefer function slots for better performance.`\n        );\n      }\n      const normalized = normalizeSlotValue(value);\n      slots[key] = () => normalized;\n    }\n  }\n};\nconst normalizeVNodeSlots = (instance, children) => {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isKeepAlive(instance.vnode) && true) {\n    warn$1(\n      `Non-function value encountered for default slot. Prefer function slots for better performance.`\n    );\n  }\n  const normalized = normalizeSlotValue(children);\n  instance.slots.default = () => normalized;\n};\nconst assignSlots = (slots, children, optimized) => {\n  for (const key in children) {\n    if (optimized || !isInternalKey(key)) {\n      slots[key] = children[key];\n    }\n  }\n};\nconst initSlots = (instance, children, optimized) => {\n  const slots = instance.slots = createInternalObject();\n  if (instance.vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      assignSlots(slots, children, optimized);\n      if (optimized) {\n        def(slots, \"_\", type, true);\n      }\n    } else {\n      normalizeObjectSlots(children, slots);\n    }\n  } else if (children) {\n    normalizeVNodeSlots(instance, children);\n  }\n};\nconst updateSlots = (instance, children, optimized) => {\n  const { vnode, slots } = instance;\n  let needDeletionCheck = true;\n  let deletionComparisonTarget = EMPTY_OBJ;\n  if (vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      if (!!(process.env.NODE_ENV !== \"production\") && isHmrUpdating) {\n        assignSlots(slots, children, optimized);\n        trigger(instance, \"set\", \"$slots\");\n      } else if (optimized && type === 1) {\n        needDeletionCheck = false;\n      } else {\n        assignSlots(slots, children, optimized);\n      }\n    } else {\n      needDeletionCheck = !children.$stable;\n      normalizeObjectSlots(children, slots);\n    }\n    deletionComparisonTarget = children;\n  } else if (children) {\n    normalizeVNodeSlots(instance, children);\n    deletionComparisonTarget = { default: 1 };\n  }\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {\n        delete slots[key];\n      }\n    }\n  }\n};\n\nlet supported;\nlet perf;\nfunction startMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    perf.mark(`vue-${type}-${instance.uid}`);\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction endMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    const startTag = `vue-${type}-${instance.uid}`;\n    const endTag = startTag + `:end`;\n    const measureName = `<${formatComponentName(instance, instance.type)}> ${type}`;\n    perf.mark(endTag);\n    perf.measure(measureName, startTag, endTag);\n    perf.clearMeasures(measureName);\n    perf.clearMarks(startTag);\n    perf.clearMarks(endTag);\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction isSupported() {\n  if (supported !== void 0) {\n    return supported;\n  }\n  if (typeof window !== \"undefined\" && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\n\nfunction initFeatureFlags() {\n  const needWarn = [];\n  if (typeof __VUE_OPTIONS_API__ !== \"boolean\") {\n    !!(process.env.NODE_ENV !== \"production\") && needWarn.push(`__VUE_OPTIONS_API__`);\n    getGlobalThis().__VUE_OPTIONS_API__ = true;\n  }\n  if (typeof __VUE_PROD_DEVTOOLS__ !== \"boolean\") {\n    !!(process.env.NODE_ENV !== \"production\") && needWarn.push(`__VUE_PROD_DEVTOOLS__`);\n    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;\n  }\n  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== \"boolean\") {\n    !!(process.env.NODE_ENV !== \"production\") && needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);\n    getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && needWarn.length) {\n    const multi = needWarn.length > 1;\n    console.warn(\n      `Feature flag${multi ? `s` : ``} ${needWarn.join(\", \")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.\n\nFor more details, see https://link.vuejs.org/feature-flags.`\n    );\n  }\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense ;\nfunction createRenderer(options) {\n  return baseCreateRenderer(options);\n}\nfunction createHydrationRenderer(options) {\n  return baseCreateRenderer(options, createHydrationFunctions);\n}\nfunction baseCreateRenderer(options, createHydrationFns) {\n  {\n    initFeatureFlags();\n  }\n  const target = getGlobalThis();\n  target.__VUE__ = true;\n  if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\n  }\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = NOOP,\n    insertStaticContent: hostInsertStaticContent\n  } = options;\n  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!(process.env.NODE_ENV !== \"production\") && isHmrUpdating ? false : !!n2.dynamicChildren) => {\n    if (n1 === n2) {\n      return;\n    }\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1);\n      unmount(n1, parentComponent, parentSuspense, true);\n      n1 = null;\n    }\n    if (n2.patchFlag === -2) {\n      optimized = false;\n      n2.dynamicChildren = null;\n    }\n    const { type, ref, shapeFlag } = n2;\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor);\n        break;\n      case Comment:\n        processCommentNode(n1, n2, container, anchor);\n        break;\n      case Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, namespace);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          patchStaticNode(n1, n2, container, namespace);\n        }\n        break;\n      case Fragment:\n        processFragment(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        break;\n      default:\n        if (shapeFlag & 1) {\n          processElement(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else if (shapeFlag & 6) {\n          processComponent(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else if (shapeFlag & 64) {\n          type.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n        } else if (shapeFlag & 128) {\n          type.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\"Invalid VNode type:\", type, `(${typeof type})`);\n        }\n    }\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\n    } else if (ref == null && n1 && n1.ref != null) {\n      setRef(n1.ref, null, parentSuspense, n1, true);\n    }\n  };\n  const processText = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(\n        n2.el = hostCreateText(n2.children),\n        container,\n        anchor\n      );\n    } else {\n      const el = n2.el = n1.el;\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children);\n      }\n    }\n  };\n  const processCommentNode = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(\n        n2.el = hostCreateComment(n2.children || \"\"),\n        container,\n        anchor\n      );\n    } else {\n      n2.el = n1.el;\n    }\n  };\n  const mountStaticNode = (n2, container, anchor, namespace) => {\n    [n2.el, n2.anchor] = hostInsertStaticContent(\n      n2.children,\n      container,\n      anchor,\n      namespace,\n      n2.el,\n      n2.anchor\n    );\n  };\n  const patchStaticNode = (n1, n2, container, namespace) => {\n    if (n2.children !== n1.children) {\n      const anchor = hostNextSibling(n1.anchor);\n      removeStaticNode(n1);\n      [n2.el, n2.anchor] = hostInsertStaticContent(\n        n2.children,\n        container,\n        anchor,\n        namespace\n      );\n    } else {\n      n2.el = n1.el;\n      n2.anchor = n1.anchor;\n    }\n  };\n  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostInsert(el, container, nextSibling);\n      el = next;\n    }\n    hostInsert(anchor, container, nextSibling);\n  };\n  const removeStaticNode = ({ el, anchor }) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostRemove(el);\n      el = next;\n    }\n    hostRemove(anchor);\n  };\n  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    if (n2.type === \"svg\") {\n      namespace = \"svg\";\n    } else if (n2.type === \"math\") {\n      namespace = \"mathml\";\n    }\n    if (n1 == null) {\n      mountElement(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    } else {\n      const customElement = !!(n1.el && n1.el._isVueCE) ? n1.el : null;\n      try {\n        if (customElement) {\n          customElement._beginPatch();\n        }\n        patchElement(\n          n1,\n          n2,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      } finally {\n        if (customElement) {\n          customElement._endPatch();\n        }\n      }\n    }\n  };\n  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let el;\n    let vnodeHook;\n    const { props, shapeFlag, transition, dirs } = vnode;\n    el = vnode.el = hostCreateElement(\n      vnode.type,\n      namespace,\n      props && props.is,\n      props\n    );\n    if (shapeFlag & 8) {\n      hostSetElementText(el, vnode.children);\n    } else if (shapeFlag & 16) {\n      mountChildren(\n        vnode.children,\n        el,\n        null,\n        parentComponent,\n        parentSuspense,\n        resolveChildrenNamespace(vnode, namespace),\n        slotScopeIds,\n        optimized\n      );\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n    }\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\n    if (props) {\n      for (const key in props) {\n        if (key !== \"value\" && !isReservedProp(key)) {\n          hostPatchProp(el, key, null, props[key], namespace, parentComponent);\n        }\n      }\n      if (\"value\" in props) {\n        hostPatchProp(el, \"value\", null, props.value, namespace);\n      }\n      if (vnodeHook = props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHook, parentComponent, vnode);\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      def(el, \"__vnode\", vnode, true);\n      def(el, \"__vueParentComponent\", parentComponent, true);\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n    }\n    const needCallTransitionHooks = needTransition(parentSuspense, transition);\n    if (needCallTransitionHooks) {\n      transition.beforeEnter(el);\n    }\n    hostInsert(el, container, anchor);\n    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        needCallTransitionHooks && transition.enter(el);\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n      }, parentSuspense);\n    }\n  };\n  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId);\n    }\n    if (slotScopeIds) {\n      for (let i = 0; i < slotScopeIds.length; i++) {\n        hostSetScopeId(el, slotScopeIds[i]);\n      }\n    }\n    if (parentComponent) {\n      let subTree = parentComponent.subTree;\n      if (!!(process.env.NODE_ENV !== \"production\") && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {\n        subTree = filterSingleRoot(subTree.children) || subTree;\n      }\n      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {\n        const parentVNode = parentComponent.vnode;\n        setScopeId(\n          el,\n          parentVNode,\n          parentVNode.scopeId,\n          parentVNode.slotScopeIds,\n          parentComponent.parent\n        );\n      }\n    }\n  };\n  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);\n      patch(\n        null,\n        child,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    }\n  };\n  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    const el = n2.el = n1.el;\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      el.__vnode = n2;\n    }\n    let { patchFlag, dynamicChildren, dirs } = n2;\n    patchFlag |= n1.patchFlag & 16;\n    const oldProps = n1.props || EMPTY_OBJ;\n    const newProps = n2.props || EMPTY_OBJ;\n    let vnodeHook;\n    parentComponent && toggleRecurse(parentComponent, false);\n    if (vnodeHook = newProps.onVnodeBeforeUpdate) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n    }\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, \"beforeUpdate\");\n    }\n    parentComponent && toggleRecurse(parentComponent, true);\n    if (!!(process.env.NODE_ENV !== \"production\") && isHmrUpdating) {\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {\n      hostSetElementText(el, \"\");\n    }\n    if (dynamicChildren) {\n      patchBlockChildren(\n        n1.dynamicChildren,\n        dynamicChildren,\n        el,\n        parentComponent,\n        parentSuspense,\n        resolveChildrenNamespace(n2, namespace),\n        slotScopeIds\n      );\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        traverseStaticChildren(n1, n2);\n      }\n    } else if (!optimized) {\n      patchChildren(\n        n1,\n        n2,\n        el,\n        null,\n        parentComponent,\n        parentSuspense,\n        resolveChildrenNamespace(n2, namespace),\n        slotScopeIds,\n        false\n      );\n    }\n    if (patchFlag > 0) {\n      if (patchFlag & 16) {\n        patchProps(el, oldProps, newProps, parentComponent, namespace);\n      } else {\n        if (patchFlag & 2) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, \"class\", null, newProps.class, namespace);\n          }\n        }\n        if (patchFlag & 4) {\n          hostPatchProp(el, \"style\", oldProps.style, newProps.style, namespace);\n        }\n        if (patchFlag & 8) {\n          const propsToUpdate = n2.dynamicProps;\n          for (let i = 0; i < propsToUpdate.length; i++) {\n            const key = propsToUpdate[i];\n            const prev = oldProps[key];\n            const next = newProps[key];\n            if (next !== prev || key === \"value\") {\n              hostPatchProp(el, key, prev, next, namespace, parentComponent);\n            }\n          }\n        }\n      }\n      if (patchFlag & 1) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children);\n        }\n      }\n    } else if (!optimized && dynamicChildren == null) {\n      patchProps(el, oldProps, newProps, parentComponent, namespace);\n    }\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, \"updated\");\n      }, parentSuspense);\n    }\n  };\n  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i];\n      const newVNode = newChildren[i];\n      const container = (\n        // oldVNode may be an errored async setup() component inside Suspense\n        // which will not have a mounted element\n        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent\n        // of the Fragment itself so it can move its children.\n        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement\n        // which also requires the correct parent container\n        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.\n        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (\n          // In other cases, the parent container is not actually used so we\n          // just pass the block element here to avoid a DOM parentNode call.\n          fallbackContainer\n        )\n      );\n      patch(\n        oldVNode,\n        newVNode,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        true\n      );\n    }\n  };\n  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {\n    if (oldProps !== newProps) {\n      if (oldProps !== EMPTY_OBJ) {\n        for (const key in oldProps) {\n          if (!isReservedProp(key) && !(key in newProps)) {\n            hostPatchProp(\n              el,\n              key,\n              oldProps[key],\n              null,\n              namespace,\n              parentComponent\n            );\n          }\n        }\n      }\n      for (const key in newProps) {\n        if (isReservedProp(key)) continue;\n        const next = newProps[key];\n        const prev = oldProps[key];\n        if (next !== prev && key !== \"value\") {\n          hostPatchProp(el, key, prev, next, namespace, parentComponent);\n        }\n      }\n      if (\"value\" in newProps) {\n        hostPatchProp(el, \"value\", oldProps.value, newProps.value, namespace);\n      }\n    }\n  };\n  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText(\"\");\n    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText(\"\");\n    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\n    if (!!(process.env.NODE_ENV !== \"production\") && // #5523 dev root fragment may inherit directives\n    (isHmrUpdating || patchFlag & 2048)) {\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor);\n      hostInsert(fragmentEndAnchor, container, anchor);\n      mountChildren(\n        // #10007\n        // such fragment like `<></>` will be compiled into\n        // a fragment which doesn't have a children.\n        // In this case fallback to an empty array\n        n2.children || [],\n        container,\n        fragmentEndAnchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    } else {\n      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result\n      // of renderSlot() with no valid children\n      n1.dynamicChildren) {\n        patchBlockChildren(\n          n1.dynamicChildren,\n          dynamicChildren,\n          container,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds\n        );\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          traverseStaticChildren(n1, n2);\n        } else if (\n          // #2080 if the stable fragment has a key, it's a <template v-for> that may\n          //  get moved around. Make sure all root level vnodes inherit el.\n          // #2134 or if it's a component root, it may also get moved around\n          // as the component is being moved.\n          n2.key != null || parentComponent && n2 === parentComponent.subTree\n        ) {\n          traverseStaticChildren(\n            n1,\n            n2,\n            true\n            /* shallow */\n          );\n        }\n      } else {\n        patchChildren(\n          n1,\n          n2,\n          container,\n          fragmentEndAnchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      }\n    }\n  };\n  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    n2.slotScopeIds = slotScopeIds;\n    if (n1 == null) {\n      if (n2.shapeFlag & 512) {\n        parentComponent.ctx.activate(\n          n2,\n          container,\n          anchor,\n          namespace,\n          optimized\n        );\n      } else {\n        mountComponent(\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          optimized\n        );\n      }\n    } else {\n      updateComponent(n1, n2, optimized);\n    }\n  };\n  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {\n    const instance = (initialVNode.component = createComponentInstance(\n      initialVNode,\n      parentComponent,\n      parentSuspense\n    ));\n    if (!!(process.env.NODE_ENV !== \"production\") && instance.type.__hmrId) {\n      registerHMR(instance);\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      pushWarningContext(initialVNode);\n      startMeasure(instance, `mount`);\n    }\n    if (isKeepAlive(initialVNode)) {\n      instance.ctx.renderer = internals;\n    }\n    {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        startMeasure(instance, `init`);\n      }\n      setupComponent(instance, false, optimized);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        endMeasure(instance, `init`);\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && isHmrUpdating) initialVNode.el = null;\n    if (instance.asyncDep) {\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);\n      if (!initialVNode.el) {\n        const placeholder = instance.subTree = createVNode(Comment);\n        processCommentNode(null, placeholder, container, anchor);\n        initialVNode.placeholder = placeholder.el;\n      }\n    } else {\n      setupRenderEffect(\n        instance,\n        initialVNode,\n        container,\n        anchor,\n        parentSuspense,\n        namespace,\n        optimized\n      );\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      popWarningContext();\n      endMeasure(instance, `mount`);\n    }\n  };\n  const updateComponent = (n1, n2, optimized) => {\n    const instance = n2.component = n1.component;\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (instance.asyncDep && !instance.asyncResolved) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          pushWarningContext(n2);\n        }\n        updateComponentPreRender(instance, n2, optimized);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          popWarningContext();\n        }\n        return;\n      } else {\n        instance.next = n2;\n        instance.update();\n      }\n    } else {\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  };\n  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        let vnodeHook;\n        const { el, props } = initialVNode;\n        const { bm, m, parent, root, type } = instance;\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\n        toggleRecurse(instance, false);\n        if (bm) {\n          invokeArrayFns(bm);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode);\n        }\n        toggleRecurse(instance, true);\n        if (el && hydrateNode) {\n          const hydrateSubTree = () => {\n            if (!!(process.env.NODE_ENV !== \"production\")) {\n              startMeasure(instance, `render`);\n            }\n            instance.subTree = renderComponentRoot(instance);\n            if (!!(process.env.NODE_ENV !== \"production\")) {\n              endMeasure(instance, `render`);\n            }\n            if (!!(process.env.NODE_ENV !== \"production\")) {\n              startMeasure(instance, `hydrate`);\n            }\n            hydrateNode(\n              el,\n              instance.subTree,\n              instance,\n              parentSuspense,\n              null\n            );\n            if (!!(process.env.NODE_ENV !== \"production\")) {\n              endMeasure(instance, `hydrate`);\n            }\n          };\n          if (isAsyncWrapperVNode && type.__asyncHydrate) {\n            type.__asyncHydrate(\n              el,\n              instance,\n              hydrateSubTree\n            );\n          } else {\n            hydrateSubTree();\n          }\n        } else {\n          if (root.ce && // @ts-expect-error _def is private\n          root.ce._def.shadowRoot !== false) {\n            root.ce._injectChildStyle(type);\n          }\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            startMeasure(instance, `render`);\n          }\n          const subTree = instance.subTree = renderComponentRoot(instance);\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            endMeasure(instance, `render`);\n          }\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            startMeasure(instance, `patch`);\n          }\n          patch(\n            null,\n            subTree,\n            container,\n            anchor,\n            instance,\n            parentSuspense,\n            namespace\n          );\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            endMeasure(instance, `patch`);\n          }\n          initialVNode.el = subTree.el;\n        }\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {\n          const scopedInitialVNode = initialVNode;\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),\n            parentSuspense\n          );\n        }\n        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense);\n        }\n        instance.isMounted = true;\n        if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n          devtoolsComponentAdded(instance);\n        }\n        initialVNode = container = anchor = null;\n      } else {\n        let { next, bu, u, parent, vnode } = instance;\n        {\n          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);\n          if (nonHydratedAsyncRoot) {\n            if (next) {\n              next.el = vnode.el;\n              updateComponentPreRender(instance, next, optimized);\n            }\n            nonHydratedAsyncRoot.asyncDep.then(() => {\n              if (!instance.isUnmounted) {\n                componentUpdateFn();\n              }\n            });\n            return;\n          }\n        }\n        let originNext = next;\n        let vnodeHook;\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          pushWarningContext(next || instance.vnode);\n        }\n        toggleRecurse(instance, false);\n        if (next) {\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next, optimized);\n        } else {\n          next = vnode;\n        }\n        if (bu) {\n          invokeArrayFns(bu);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode);\n        }\n        toggleRecurse(instance, true);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          startMeasure(instance, `render`);\n        }\n        const nextTree = renderComponentRoot(instance);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          endMeasure(instance, `render`);\n        }\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          startMeasure(instance, `patch`);\n        }\n        patch(\n          prevTree,\n          nextTree,\n          // parent may have changed if it's in a teleport\n          hostParentNode(prevTree.el),\n          // anchor may have changed if it's in a fragment\n          getNextHostNode(prevTree),\n          instance,\n          parentSuspense,\n          namespace\n        );\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          endMeasure(instance, `patch`);\n        }\n        next.el = nextTree.el;\n        if (originNext === null) {\n          updateHOCHostEl(instance, nextTree.el);\n        }\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeUpdated) {\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook, parent, next, vnode),\n            parentSuspense\n          );\n        }\n        if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n          devtoolsComponentUpdated(instance);\n        }\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          popWarningContext();\n        }\n      }\n    };\n    instance.scope.on();\n    const effect = instance.effect = new ReactiveEffect(componentUpdateFn);\n    instance.scope.off();\n    const update = instance.update = effect.run.bind(effect);\n    const job = instance.job = effect.runIfDirty.bind(effect);\n    job.i = instance;\n    job.id = instance.uid;\n    effect.scheduler = () => queueJob(job);\n    toggleRecurse(instance, true);\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      effect.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;\n      effect.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;\n    }\n    update();\n  };\n  const updateComponentPreRender = (instance, nextVNode, optimized) => {\n    nextVNode.component = instance;\n    const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n    updateProps(instance, nextVNode.props, prevProps, optimized);\n    updateSlots(instance, nextVNode.children, optimized);\n    pauseTracking();\n    flushPreFlushCbs(instance);\n    resetTracking();\n  };\n  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {\n    const c1 = n1 && n1.children;\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n    const c2 = n2.children;\n    const { patchFlag, shapeFlag } = n2;\n    if (patchFlag > 0) {\n      if (patchFlag & 128) {\n        patchKeyedChildren(\n          c1,\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        return;\n      } else if (patchFlag & 256) {\n        patchUnkeyedChildren(\n          c1,\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        return;\n      }\n    }\n    if (shapeFlag & 8) {\n      if (prevShapeFlag & 16) {\n        unmountChildren(c1, parentComponent, parentSuspense);\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2);\n      }\n    } else {\n      if (prevShapeFlag & 16) {\n        if (shapeFlag & 16) {\n          patchKeyedChildren(\n            c1,\n            c2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else {\n          unmountChildren(c1, parentComponent, parentSuspense, true);\n        }\n      } else {\n        if (prevShapeFlag & 8) {\n          hostSetElementText(container, \"\");\n        }\n        if (shapeFlag & 16) {\n          mountChildren(\n            c2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        }\n      }\n    }\n  };\n  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    c1 = c1 || EMPTY_ARR;\n    c2 = c2 || EMPTY_ARR;\n    const oldLength = c1.length;\n    const newLength = c2.length;\n    const commonLength = Math.min(oldLength, newLength);\n    let i;\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      patch(\n        c1[i],\n        nextChild,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    }\n    if (oldLength > newLength) {\n      unmountChildren(\n        c1,\n        parentComponent,\n        parentSuspense,\n        true,\n        false,\n        commonLength\n      );\n    } else {\n      mountChildren(\n        c2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n        commonLength\n      );\n    }\n  };\n  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1;\n    let e2 = l2 - 1;\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      } else {\n        break;\n      }\n      i++;\n    }\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      } else {\n        break;\n      }\n      e1--;\n      e2--;\n    }\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1;\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n        while (i <= e2) {\n          patch(\n            null,\n            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          i++;\n        }\n      }\n    } else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true);\n        i++;\n      }\n    } else {\n      const s1 = i;\n      const s2 = i;\n      const keyToNewIndexMap = /* @__PURE__ */ new Map();\n      for (i = s2; i <= e2; i++) {\n        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (nextChild.key != null) {\n          if (!!(process.env.NODE_ENV !== \"production\") && keyToNewIndexMap.has(nextChild.key)) {\n            warn$1(\n              `Duplicate keys found during update:`,\n              JSON.stringify(nextChild.key),\n              `Make sure keys are unique.`\n            );\n          }\n          keyToNewIndexMap.set(nextChild.key, i);\n        }\n      }\n      let j;\n      let patched = 0;\n      const toBePatched = e2 - s2 + 1;\n      let moved = false;\n      let maxNewIndexSoFar = 0;\n      const newIndexToOldIndexMap = new Array(toBePatched);\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i];\n        if (patched >= toBePatched) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n          continue;\n        }\n        let newIndex;\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key);\n        } else {\n          for (j = s2; j <= e2; j++) {\n            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {\n              newIndex = j;\n              break;\n            }\n          }\n        }\n        if (newIndex === void 0) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1;\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex;\n          } else {\n            moved = true;\n          }\n          patch(\n            prevChild,\n            c2[newIndex],\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          patched++;\n        }\n      }\n      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;\n      j = increasingNewIndexSequence.length - 1;\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i;\n        const nextChild = c2[nextIndex];\n        const anchorVNode = c2[nextIndex + 1];\n        const anchor = nextIndex + 1 < l2 ? (\n          // #13559, fallback to el placeholder for unresolved async component\n          anchorVNode.el || anchorVNode.placeholder\n        ) : parentAnchor;\n        if (newIndexToOldIndexMap[i] === 0) {\n          patch(\n            null,\n            nextChild,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else if (moved) {\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, 2);\n          } else {\n            j--;\n          }\n        }\n      }\n    }\n  };\n  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n    const { el, type, transition, children, shapeFlag } = vnode;\n    if (shapeFlag & 6) {\n      move(vnode.component.subTree, container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 128) {\n      vnode.suspense.move(container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 64) {\n      type.move(vnode, container, anchor, internals);\n      return;\n    }\n    if (type === Fragment) {\n      hostInsert(el, container, anchor);\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, anchor, moveType);\n      }\n      hostInsert(vnode.anchor, container, anchor);\n      return;\n    }\n    if (type === Static) {\n      moveStaticNode(vnode, container, anchor);\n      return;\n    }\n    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;\n    if (needTransition2) {\n      if (moveType === 0) {\n        transition.beforeEnter(el);\n        hostInsert(el, container, anchor);\n        queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n      } else {\n        const { leave, delayLeave, afterLeave } = transition;\n        const remove2 = () => {\n          if (vnode.ctx.isUnmounted) {\n            hostRemove(el);\n          } else {\n            hostInsert(el, container, anchor);\n          }\n        };\n        const performLeave = () => {\n          if (el._isLeaving) {\n            el[leaveCbKey](\n              true\n              /* cancelled */\n            );\n          }\n          leave(el, () => {\n            remove2();\n            afterLeave && afterLeave();\n          });\n        };\n        if (delayLeave) {\n          delayLeave(el, remove2, performLeave);\n        } else {\n          performLeave();\n        }\n      }\n    } else {\n      hostInsert(el, container, anchor);\n    }\n  };\n  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs,\n      cacheIndex\n    } = vnode;\n    if (patchFlag === -2) {\n      optimized = false;\n    }\n    if (ref != null) {\n      pauseTracking();\n      setRef(ref, null, parentSuspense, vnode, true);\n      resetTracking();\n    }\n    if (cacheIndex != null) {\n      parentComponent.renderCache[cacheIndex] = void 0;\n    }\n    if (shapeFlag & 256) {\n      parentComponent.ctx.deactivate(vnode);\n      return;\n    }\n    const shouldInvokeDirs = shapeFlag & 1 && dirs;\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\n    let vnodeHook;\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n    }\n    if (shapeFlag & 6) {\n      unmountComponent(vnode.component, parentSuspense, doRemove);\n    } else {\n      if (shapeFlag & 128) {\n        vnode.suspense.unmount(parentSuspense, doRemove);\n        return;\n      }\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeUnmount\");\n      }\n      if (shapeFlag & 64) {\n        vnode.type.remove(\n          vnode,\n          parentComponent,\n          parentSuspense,\n          internals,\n          doRemove\n        );\n      } else if (dynamicChildren && // #5154\n      // when v-once is used inside a block, setBlockTracking(-1) marks the\n      // parent block with hasOnce: true\n      // so that it doesn't take the fast path during unmount - otherwise\n      // components nested in v-once are never unmounted.\n      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments\n      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {\n        unmountChildren(\n          dynamicChildren,\n          parentComponent,\n          parentSuspense,\n          false,\n          true\n        );\n      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {\n        unmountChildren(children, parentComponent, parentSuspense);\n      }\n      if (doRemove) {\n        remove(vnode);\n      }\n    }\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, \"unmounted\");\n      }, parentSuspense);\n    }\n  };\n  const remove = (vnode) => {\n    const { type, el, anchor, transition } = vnode;\n    if (type === Fragment) {\n      if (!!(process.env.NODE_ENV !== \"production\") && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {\n        vnode.children.forEach((child) => {\n          if (child.type === Comment) {\n            hostRemove(child.el);\n          } else {\n            remove(child);\n          }\n        });\n      } else {\n        removeFragment(el, anchor);\n      }\n      return;\n    }\n    if (type === Static) {\n      removeStaticNode(vnode);\n      return;\n    }\n    const performRemove = () => {\n      hostRemove(el);\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave();\n      }\n    };\n    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {\n      const { leave, delayLeave } = transition;\n      const performLeave = () => leave(el, performRemove);\n      if (delayLeave) {\n        delayLeave(vnode.el, performRemove, performLeave);\n      } else {\n        performLeave();\n      }\n    } else {\n      performRemove();\n    }\n  };\n  const removeFragment = (cur, end) => {\n    let next;\n    while (cur !== end) {\n      next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n    hostRemove(end);\n  };\n  const unmountComponent = (instance, parentSuspense, doRemove) => {\n    if (!!(process.env.NODE_ENV !== \"production\") && instance.type.__hmrId) {\n      unregisterHMR(instance);\n    }\n    const { bum, scope, job, subTree, um, m, a } = instance;\n    invalidateMount(m);\n    invalidateMount(a);\n    if (bum) {\n      invokeArrayFns(bum);\n    }\n    scope.stop();\n    if (job) {\n      job.flags |= 8;\n      unmount(subTree, instance, parentSuspense, doRemove);\n    }\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense);\n    }\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true;\n    }, parentSuspense);\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      devtoolsComponentRemoved(instance);\n    }\n  };\n  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n    }\n  };\n  const getNextHostNode = (vnode) => {\n    if (vnode.shapeFlag & 6) {\n      return getNextHostNode(vnode.component.subTree);\n    }\n    if (vnode.shapeFlag & 128) {\n      return vnode.suspense.next();\n    }\n    const el = hostNextSibling(vnode.anchor || vnode.el);\n    const teleportEnd = el && el[TeleportEndKey];\n    return teleportEnd ? hostNextSibling(teleportEnd) : el;\n  };\n  let isFlushing = false;\n  const render = (vnode, container, namespace) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true);\n      }\n    } else {\n      patch(\n        container._vnode || null,\n        vnode,\n        container,\n        null,\n        null,\n        null,\n        namespace\n      );\n    }\n    container._vnode = vnode;\n    if (!isFlushing) {\n      isFlushing = true;\n      flushPreFlushCbs();\n      flushPostFlushCbs();\n      isFlushing = false;\n    }\n  };\n  const internals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  };\n  let hydrate;\n  let hydrateNode;\n  if (createHydrationFns) {\n    [hydrate, hydrateNode] = createHydrationFns(\n      internals\n    );\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  };\n}\nfunction resolveChildrenNamespace({ type, props }, currentNamespace) {\n  return currentNamespace === \"svg\" && type === \"foreignObject\" || currentNamespace === \"mathml\" && type === \"annotation-xml\" && props && props.encoding && props.encoding.includes(\"html\") ? void 0 : currentNamespace;\n}\nfunction toggleRecurse({ effect, job }, allowed) {\n  if (allowed) {\n    effect.flags |= 32;\n    job.flags |= 4;\n  } else {\n    effect.flags &= -33;\n    job.flags &= -5;\n  }\n}\nfunction needTransition(parentSuspense, transition) {\n  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;\n}\nfunction traverseStaticChildren(n1, n2, shallow = false) {\n  const ch1 = n1.children;\n  const ch2 = n2.children;\n  if (isArray(ch1) && isArray(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      const c1 = ch1[i];\n      let c2 = ch2[i];\n      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {\n          c2 = ch2[i] = cloneIfMounted(ch2[i]);\n          c2.el = c1.el;\n        }\n        if (!shallow && c2.patchFlag !== -2)\n          traverseStaticChildren(c1, c2);\n      }\n      if (c2.type === Text && // avoid cached text nodes retaining detached dom nodes\n      c2.patchFlag !== -1) {\n        c2.el = c1.el;\n      }\n      if (c2.type === Comment && !c2.el) {\n        c2.el = c1.el;\n      }\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        c2.el && (c2.el.__vnode = c2);\n      }\n    }\n  }\n}\nfunction getSequence(arr) {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\nfunction locateNonHydratedAsyncRoot(instance) {\n  const subComponent = instance.subTree.component;\n  if (subComponent) {\n    if (subComponent.asyncDep && !subComponent.asyncResolved) {\n      return subComponent;\n    } else {\n      return locateNonHydratedAsyncRoot(subComponent);\n    }\n  }\n}\nfunction invalidateMount(hooks) {\n  if (hooks) {\n    for (let i = 0; i < hooks.length; i++)\n      hooks[i].flags |= 8;\n  }\n}\n\nconst ssrContextKey = Symbol.for(\"v-scx\");\nconst useSSRContext = () => {\n  {\n    const ctx = inject(ssrContextKey);\n    if (!ctx) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(\n        `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`\n      );\n    }\n    return ctx;\n  }\n};\n\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n  return doWatch(\n    effect,\n    null,\n    !!(process.env.NODE_ENV !== \"production\") ? extend({}, options, { flush: \"post\" }) : { flush: \"post\" }\n  );\n}\nfunction watchSyncEffect(effect, options) {\n  return doWatch(\n    effect,\n    null,\n    !!(process.env.NODE_ENV !== \"production\") ? extend({}, options, { flush: \"sync\" }) : { flush: \"sync\" }\n  );\n}\nfunction watch(source, cb, options) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isFunction(cb)) {\n    warn$1(\n      `\\`watch(fn, options?)\\` signature has been moved to a separate API. Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only supports \\`watch(source, cb, options?) signature.`\n    );\n  }\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, flush, once } = options;\n  if (!!(process.env.NODE_ENV !== \"production\") && !cb) {\n    if (immediate !== void 0) {\n      warn$1(\n        `watch() \"immediate\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n    if (deep !== void 0) {\n      warn$1(\n        `watch() \"deep\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n    if (once !== void 0) {\n      warn$1(\n        `watch() \"once\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n  }\n  const baseWatchOptions = extend({}, options);\n  if (!!(process.env.NODE_ENV !== \"production\")) baseWatchOptions.onWarn = warn$1;\n  const runsImmediately = cb && immediate || !cb && flush !== \"post\";\n  let ssrCleanup;\n  if (isInSSRComponentSetup) {\n    if (flush === \"sync\") {\n      const ctx = useSSRContext();\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);\n    } else if (!runsImmediately) {\n      const watchStopHandle = () => {\n      };\n      watchStopHandle.stop = NOOP;\n      watchStopHandle.resume = NOOP;\n      watchStopHandle.pause = NOOP;\n      return watchStopHandle;\n    }\n  }\n  const instance = currentInstance;\n  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);\n  let isPre = false;\n  if (flush === \"post\") {\n    baseWatchOptions.scheduler = (job) => {\n      queuePostRenderEffect(job, instance && instance.suspense);\n    };\n  } else if (flush !== \"sync\") {\n    isPre = true;\n    baseWatchOptions.scheduler = (job, isFirstRun) => {\n      if (isFirstRun) {\n        job();\n      } else {\n        queueJob(job);\n      }\n    };\n  }\n  baseWatchOptions.augmentJob = (job) => {\n    if (cb) {\n      job.flags |= 4;\n    }\n    if (isPre) {\n      job.flags |= 2;\n      if (instance) {\n        job.id = instance.uid;\n        job.i = instance;\n      }\n    }\n  };\n  const watchHandle = watch$1(source, cb, baseWatchOptions);\n  if (isInSSRComponentSetup) {\n    if (ssrCleanup) {\n      ssrCleanup.push(watchHandle);\n    } else if (runsImmediately) {\n      watchHandle();\n    }\n  }\n  return watchHandle;\n}\nfunction instanceWatch(source, value, options) {\n  const publicThis = this.proxy;\n  const getter = isString(source) ? source.includes(\".\") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);\n  let cb;\n  if (isFunction(value)) {\n    cb = value;\n  } else {\n    cb = value.handler;\n    options = value;\n  }\n  const reset = setCurrentInstance(this);\n  const res = doWatch(getter, cb.bind(publicThis), options);\n  reset();\n  return res;\n}\nfunction createPathGetter(ctx, path) {\n  const segments = path.split(\".\");\n  return () => {\n    let cur = ctx;\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n    return cur;\n  };\n}\n\nfunction useModel(props, name, options = EMPTY_OBJ) {\n  const i = getCurrentInstance();\n  if (!!(process.env.NODE_ENV !== \"production\") && !i) {\n    warn$1(`useModel() called without active instance.`);\n    return ref();\n  }\n  const camelizedName = camelize(name);\n  if (!!(process.env.NODE_ENV !== \"production\") && !i.propsOptions[0][camelizedName]) {\n    warn$1(`useModel() called with prop \"${name}\" which is not declared.`);\n    return ref();\n  }\n  const hyphenatedName = hyphenate(name);\n  const modifiers = getModelModifiers(props, camelizedName);\n  const res = customRef((track, trigger) => {\n    let localValue;\n    let prevSetValue = EMPTY_OBJ;\n    let prevEmittedValue;\n    watchSyncEffect(() => {\n      const propValue = props[camelizedName];\n      if (hasChanged(localValue, propValue)) {\n        localValue = propValue;\n        trigger();\n      }\n    });\n    return {\n      get() {\n        track();\n        return options.get ? options.get(localValue) : localValue;\n      },\n      set(value) {\n        const emittedValue = options.set ? options.set(value) : value;\n        if (!hasChanged(emittedValue, localValue) && !(prevSetValue !== EMPTY_OBJ && hasChanged(value, prevSetValue))) {\n          return;\n        }\n        const rawProps = i.vnode.props;\n        if (!(rawProps && // check if parent has passed v-model\n        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {\n          localValue = value;\n          trigger();\n        }\n        i.emit(`update:${name}`, emittedValue);\n        if (hasChanged(value, emittedValue) && hasChanged(value, prevSetValue) && !hasChanged(emittedValue, prevEmittedValue)) {\n          trigger();\n        }\n        prevSetValue = value;\n        prevEmittedValue = emittedValue;\n      }\n    };\n  });\n  res[Symbol.iterator] = () => {\n    let i2 = 0;\n    return {\n      next() {\n        if (i2 < 2) {\n          return { value: i2++ ? modifiers || EMPTY_OBJ : res, done: false };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  };\n  return res;\n}\nconst getModelModifiers = (props, modelName) => {\n  return modelName === \"modelValue\" || modelName === \"model-value\" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];\n};\n\nfunction emit(instance, event, ...rawArgs) {\n  if (instance.isUnmounted) return;\n  const props = instance.vnode.props || EMPTY_OBJ;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const {\n      emitsOptions,\n      propsOptions: [propsOptions]\n    } = instance;\n    if (emitsOptions) {\n      if (!(event in emitsOptions) && true) {\n        if (!propsOptions || !(toHandlerKey(camelize(event)) in propsOptions)) {\n          warn$1(\n            `Component emitted event \"${event}\" but it is neither declared in the emits option nor as an \"${toHandlerKey(camelize(event))}\" prop.`\n          );\n        }\n      } else {\n        const validator = emitsOptions[event];\n        if (isFunction(validator)) {\n          const isValid = validator(...rawArgs);\n          if (!isValid) {\n            warn$1(\n              `Invalid event arguments: event validation failed for event \"${event}\".`\n            );\n          }\n        }\n      }\n    }\n  }\n  let args = rawArgs;\n  const isModelListener = event.startsWith(\"update:\");\n  const modifiers = isModelListener && getModelModifiers(props, event.slice(7));\n  if (modifiers) {\n    if (modifiers.trim) {\n      args = rawArgs.map((a) => isString(a) ? a.trim() : a);\n    }\n    if (modifiers.number) {\n      args = rawArgs.map(looseToNumber);\n    }\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n    devtoolsComponentEmit(instance, event, args);\n  }\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const lowerCaseEvent = event.toLowerCase();\n    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {\n      warn$1(\n        `Event \"${lowerCaseEvent}\" is emitted in component ${formatComponentName(\n          instance,\n          instance.type\n        )} but the handler is registered for \"${event}\". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use \"${hyphenate(\n          event\n        )}\" instead of \"${event}\".`\n      );\n    }\n  }\n  let handlerName;\n  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)\n  props[handlerName = toHandlerKey(camelize(event))];\n  if (!handler && isModelListener) {\n    handler = props[handlerName = toHandlerKey(hyphenate(event))];\n  }\n  if (handler) {\n    callWithAsyncErrorHandling(\n      handler,\n      instance,\n      6,\n      args\n    );\n  }\n  const onceHandler = props[handlerName + `Once`];\n  if (onceHandler) {\n    if (!instance.emitted) {\n      instance.emitted = {};\n    } else if (instance.emitted[handlerName]) {\n      return;\n    }\n    instance.emitted[handlerName] = true;\n    callWithAsyncErrorHandling(\n      onceHandler,\n      instance,\n      6,\n      args\n    );\n  }\n}\nconst mixinEmitsCache = /* @__PURE__ */ new WeakMap();\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\n  const cache = __VUE_OPTIONS_API__ && asMixin ? mixinEmitsCache : appContext.emitsCache;\n  const cached = cache.get(comp);\n  if (cached !== void 0) {\n    return cached;\n  }\n  const raw = comp.emits;\n  let normalized = {};\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\n    const extendEmits = (raw2) => {\n      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);\n      if (normalizedFromExtend) {\n        hasExtends = true;\n        extend(normalized, normalizedFromExtend);\n      }\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits);\n    }\n    if (comp.extends) {\n      extendEmits(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if (isObject(comp)) {\n      cache.set(comp, null);\n    }\n    return null;\n  }\n  if (isArray(raw)) {\n    raw.forEach((key) => normalized[key] = null);\n  } else {\n    extend(normalized, raw);\n  }\n  if (isObject(comp)) {\n    cache.set(comp, normalized);\n  }\n  return normalized;\n}\nfunction isEmitListener(options, key) {\n  if (!options || !isOn(key)) {\n    return false;\n  }\n  key = key.slice(2).replace(/Once$/, \"\");\n  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);\n}\n\nlet accessedAttrs = false;\nfunction markAttrsAccessed() {\n  accessedAttrs = true;\n}\nfunction renderComponentRoot(instance) {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    props,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs\n  } = instance;\n  const prev = setCurrentRenderingInstance(instance);\n  let result;\n  let fallthroughAttrs;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    accessedAttrs = false;\n  }\n  try {\n    if (vnode.shapeFlag & 4) {\n      const proxyToUse = withProxy || proxy;\n      const thisProxy = !!(process.env.NODE_ENV !== \"production\") && setupState.__isScriptSetup ? new Proxy(proxyToUse, {\n        get(target, key, receiver) {\n          warn$1(\n            `Property '${String(\n              key\n            )}' was accessed via 'this'. Avoid using 'this' in templates.`\n          );\n          return Reflect.get(target, key, receiver);\n        }\n      }) : proxyToUse;\n      result = normalizeVNode(\n        render.call(\n          thisProxy,\n          proxyToUse,\n          renderCache,\n          !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(props) : props,\n          setupState,\n          data,\n          ctx\n        )\n      );\n      fallthroughAttrs = attrs;\n    } else {\n      const render2 = Component;\n      if (!!(process.env.NODE_ENV !== \"production\") && attrs === props) {\n        markAttrsAccessed();\n      }\n      result = normalizeVNode(\n        render2.length > 1 ? render2(\n          !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(props) : props,\n          !!(process.env.NODE_ENV !== \"production\") ? {\n            get attrs() {\n              markAttrsAccessed();\n              return shallowReadonly(attrs);\n            },\n            slots,\n            emit\n          } : { attrs, slots, emit }\n        ) : render2(\n          !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(props) : props,\n          null\n        )\n      );\n      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);\n    }\n  } catch (err) {\n    blockStack.length = 0;\n    handleError(err, instance, 1);\n    result = createVNode(Comment);\n  }\n  let root = result;\n  let setRoot = void 0;\n  if (!!(process.env.NODE_ENV !== \"production\") && result.patchFlag > 0 && result.patchFlag & 2048) {\n    [root, setRoot] = getChildRoot(result);\n  }\n  if (fallthroughAttrs && inheritAttrs !== false) {\n    const keys = Object.keys(fallthroughAttrs);\n    const { shapeFlag } = root;\n    if (keys.length) {\n      if (shapeFlag & (1 | 6)) {\n        if (propsOptions && keys.some(isModelListener)) {\n          fallthroughAttrs = filterModelListeners(\n            fallthroughAttrs,\n            propsOptions\n          );\n        }\n        root = cloneVNode(root, fallthroughAttrs, false, true);\n      } else if (!!(process.env.NODE_ENV !== \"production\") && !accessedAttrs && root.type !== Comment) {\n        const allAttrs = Object.keys(attrs);\n        const eventAttrs = [];\n        const extraAttrs = [];\n        for (let i = 0, l = allAttrs.length; i < l; i++) {\n          const key = allAttrs[i];\n          if (isOn(key)) {\n            if (!isModelListener(key)) {\n              eventAttrs.push(key[2].toLowerCase() + key.slice(3));\n            }\n          } else {\n            extraAttrs.push(key);\n          }\n        }\n        if (extraAttrs.length) {\n          warn$1(\n            `Extraneous non-props attributes (${extraAttrs.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`\n          );\n        }\n        if (eventAttrs.length) {\n          warn$1(\n            `Extraneous non-emits event listeners (${eventAttrs.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the \"emits\" option.`\n          );\n        }\n      }\n    }\n  }\n  if (vnode.dirs) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !isElementRoot(root)) {\n      warn$1(\n        `Runtime directive used on component with non-element root node. The directives will not function as intended.`\n      );\n    }\n    root = cloneVNode(root, null, false, true);\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n  }\n  if (vnode.transition) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !isElementRoot(root)) {\n      warn$1(\n        `Component inside <Transition> renders non-element root node that cannot be animated.`\n      );\n    }\n    setTransitionHooks(root, vnode.transition);\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && setRoot) {\n    setRoot(root);\n  } else {\n    result = root;\n  }\n  setCurrentRenderingInstance(prev);\n  return result;\n}\nconst getChildRoot = (vnode) => {\n  const rawChildren = vnode.children;\n  const dynamicChildren = vnode.dynamicChildren;\n  const childRoot = filterSingleRoot(rawChildren, false);\n  if (!childRoot) {\n    return [vnode, void 0];\n  } else if (!!(process.env.NODE_ENV !== \"production\") && childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {\n    return getChildRoot(childRoot);\n  }\n  const index = rawChildren.indexOf(childRoot);\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n  const setRoot = (updatedRoot) => {\n    rawChildren[index] = updatedRoot;\n    if (dynamicChildren) {\n      if (dynamicIndex > -1) {\n        dynamicChildren[dynamicIndex] = updatedRoot;\n      } else if (updatedRoot.patchFlag > 0) {\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\n      }\n    }\n  };\n  return [normalizeVNode(childRoot), setRoot];\n};\nfunction filterSingleRoot(children, recurse = true) {\n  let singleRoot;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (isVNode(child)) {\n      if (child.type !== Comment || child.children === \"v-if\") {\n        if (singleRoot) {\n          return;\n        } else {\n          singleRoot = child;\n          if (!!(process.env.NODE_ENV !== \"production\") && recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {\n            return filterSingleRoot(singleRoot.children);\n          }\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  return singleRoot;\n}\nconst getFunctionalFallthrough = (attrs) => {\n  let res;\n  for (const key in attrs) {\n    if (key === \"class\" || key === \"style\" || isOn(key)) {\n      (res || (res = {}))[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst filterModelListeners = (attrs, props) => {\n  const res = {};\n  for (const key in attrs) {\n    if (!isModelListener(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst isElementRoot = (vnode) => {\n  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;\n};\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  const { props: prevProps, children: prevChildren, component } = prevVNode;\n  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\n  const emits = component.emitsOptions;\n  if (!!(process.env.NODE_ENV !== \"production\") && (prevChildren || nextChildren) && isHmrUpdating) {\n    return true;\n  }\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true;\n  }\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & 1024) {\n      return true;\n    }\n    if (patchFlag & 16) {\n      if (!prevProps) {\n        return !!nextProps;\n      }\n      return hasPropsChanged(prevProps, nextProps, emits);\n    } else if (patchFlag & 8) {\n      const dynamicProps = nextVNode.dynamicProps;\n      for (let i = 0; i < dynamicProps.length; i++) {\n        const key = dynamicProps[i];\n        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !nextChildren.$stable) {\n        return true;\n      }\n    }\n    if (prevProps === nextProps) {\n      return false;\n    }\n    if (!prevProps) {\n      return !!nextProps;\n    }\n    if (!nextProps) {\n      return true;\n    }\n    return hasPropsChanged(prevProps, nextProps, emits);\n  }\n  return false;\n}\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction updateHOCHostEl({ vnode, parent }, el) {\n  while (parent) {\n    const root = parent.subTree;\n    if (root.suspense && root.suspense.activeBranch === vnode) {\n      root.el = vnode.el;\n    }\n    if (root === vnode) {\n      (vnode = parent.vnode).el = el;\n      parent = parent.parent;\n    } else {\n      break;\n    }\n  }\n}\n\nconst isSuspense = (type) => type.__isSuspense;\nlet suspenseId = 0;\nconst SuspenseImpl = {\n  name: \"Suspense\",\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {\n    if (n1 == null) {\n      mountSuspense(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      );\n    } else {\n      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {\n        n2.suspense = n1.suspense;\n        n2.suspense.vnode = n2;\n        n2.el = n1.el;\n        return;\n      }\n      patchSuspense(\n        n1,\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        namespace,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      );\n    }\n  },\n  hydrate: hydrateSuspense,\n  normalize: normalizeSuspenseChildren\n};\nconst Suspense = SuspenseImpl ;\nfunction triggerEvent(vnode, name) {\n  const eventListener = vnode.props && vnode.props[name];\n  if (isFunction(eventListener)) {\n    eventListener();\n  }\n}\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {\n  const {\n    p: patch,\n    o: { createElement }\n  } = rendererInternals;\n  const hiddenContainer = createElement(\"div\");\n  const suspense = vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    container,\n    hiddenContainer,\n    anchor,\n    namespace,\n    slotScopeIds,\n    optimized,\n    rendererInternals\n  );\n  patch(\n    null,\n    suspense.pendingBranch = vnode.ssContent,\n    hiddenContainer,\n    null,\n    parentComponent,\n    suspense,\n    namespace,\n    slotScopeIds\n  );\n  if (suspense.deps > 0) {\n    triggerEvent(vnode, \"onPending\");\n    triggerEvent(vnode, \"onFallback\");\n    patch(\n      null,\n      vnode.ssFallback,\n      container,\n      anchor,\n      parentComponent,\n      null,\n      // fallback tree will not have suspense context\n      namespace,\n      slotScopeIds\n    );\n    setActiveBranch(suspense, vnode.ssFallback);\n  } else {\n    suspense.resolve(false, true);\n  }\n}\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {\n  const suspense = n2.suspense = n1.suspense;\n  suspense.vnode = n2;\n  n2.el = n1.el;\n  const newBranch = n2.ssContent;\n  const newFallback = n2.ssFallback;\n  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch;\n    if (isSameVNodeType(pendingBranch, newBranch)) {\n      patch(\n        pendingBranch,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else if (isInFallback) {\n        if (!isHydrating) {\n          patch(\n            activeBranch,\n            newFallback,\n            container,\n            anchor,\n            parentComponent,\n            null,\n            // fallback tree will not have suspense context\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          setActiveBranch(suspense, newFallback);\n        }\n      }\n    } else {\n      suspense.pendingId = suspenseId++;\n      if (isHydrating) {\n        suspense.isHydrating = false;\n        suspense.activeBranch = pendingBranch;\n      } else {\n        unmount(pendingBranch, parentComponent, suspense);\n      }\n      suspense.deps = 0;\n      suspense.effects.length = 0;\n      suspense.hiddenContainer = createElement(\"div\");\n      if (isInFallback) {\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        } else {\n          patch(\n            activeBranch,\n            newFallback,\n            container,\n            anchor,\n            parentComponent,\n            null,\n            // fallback tree will not have suspense context\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          setActiveBranch(suspense, newFallback);\n        }\n      } else if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {\n        patch(\n          activeBranch,\n          newBranch,\n          container,\n          anchor,\n          parentComponent,\n          suspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        suspense.resolve(true);\n      } else {\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {\n      patch(\n        activeBranch,\n        newBranch,\n        container,\n        anchor,\n        parentComponent,\n        suspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n      setActiveBranch(suspense, newBranch);\n    } else {\n      triggerEvent(n2, \"onPending\");\n      suspense.pendingBranch = newBranch;\n      if (newBranch.shapeFlag & 512) {\n        suspense.pendingId = newBranch.component.suspenseId;\n      } else {\n        suspense.pendingId = suspenseId++;\n      }\n      patch(\n        null,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else {\n        const { timeout, pendingId } = suspense;\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback);\n            }\n          }, timeout);\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback);\n        }\n      }\n    }\n  }\n}\nlet hasWarned = false;\nfunction createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\n  if (!!(process.env.NODE_ENV !== \"production\") && true && !hasWarned) {\n    hasWarned = true;\n    console[console.info ? \"info\" : \"log\"](\n      `<Suspense> is an experimental feature and its API will likely change.`\n    );\n  }\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: { parentNode, remove }\n  } = rendererInternals;\n  let parentSuspenseId;\n  const isSuspensible = isVNodeSuspensible(vnode);\n  if (isSuspensible) {\n    if (parentSuspense && parentSuspense.pendingBranch) {\n      parentSuspenseId = parentSuspense.pendingId;\n      parentSuspense.deps++;\n    }\n  }\n  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    assertNumber(timeout, `Suspense timeout`);\n  }\n  const initialAnchor = anchor;\n  const suspense = {\n    vnode,\n    parent: parentSuspense,\n    parentComponent,\n    namespace,\n    container,\n    hiddenContainer,\n    deps: 0,\n    pendingId: suspenseId++,\n    timeout: typeof timeout === \"number\" ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: !isHydrating,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n    resolve(resume = false, sync = false) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        if (!resume && !suspense.pendingBranch) {\n          throw new Error(\n            `suspense.resolve() is called without a pending branch.`\n          );\n        }\n        if (suspense.isUnmounted) {\n          throw new Error(\n            `suspense.resolve() is called on an already unmounted suspense boundary.`\n          );\n        }\n      }\n      const {\n        vnode: vnode2,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent: parentComponent2,\n        container: container2,\n        isInFallback\n      } = suspense;\n      let delayEnter = false;\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false;\n      } else if (!resume) {\n        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === \"out-in\";\n        if (delayEnter) {\n          activeBranch.transition.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(\n                pendingBranch,\n                container2,\n                anchor === initialAnchor ? next(activeBranch) : anchor,\n                0\n              );\n              queuePostFlushCb(effects);\n              if (isInFallback && vnode2.ssFallback) {\n                vnode2.ssFallback.el = null;\n              }\n            }\n          };\n        }\n        if (activeBranch) {\n          if (parentNode(activeBranch.el) === container2) {\n            anchor = next(activeBranch);\n          }\n          unmount(activeBranch, parentComponent2, suspense, true);\n          if (!delayEnter && isInFallback && vnode2.ssFallback) {\n            vnode2.ssFallback.el = null;\n          }\n        }\n        if (!delayEnter) {\n          move(pendingBranch, container2, anchor, 0);\n        }\n      }\n      setActiveBranch(suspense, pendingBranch);\n      suspense.pendingBranch = null;\n      suspense.isInFallback = false;\n      let parent = suspense.parent;\n      let hasUnresolvedAncestor = false;\n      while (parent) {\n        if (parent.pendingBranch) {\n          parent.effects.push(...effects);\n          hasUnresolvedAncestor = true;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!hasUnresolvedAncestor && !delayEnter) {\n        queuePostFlushCb(effects);\n      }\n      suspense.effects = [];\n      if (isSuspensible) {\n        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {\n          parentSuspense.deps--;\n          if (parentSuspense.deps === 0 && !sync) {\n            parentSuspense.resolve();\n          }\n        }\n      }\n      triggerEvent(vnode2, \"onResolve\");\n    },\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;\n      triggerEvent(vnode2, \"onFallback\");\n      const anchor2 = next(activeBranch);\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return;\n        }\n        patch(\n          null,\n          fallbackVNode,\n          container2,\n          anchor2,\n          parentComponent2,\n          null,\n          // fallback tree will not have suspense context\n          namespace2,\n          slotScopeIds,\n          optimized\n        );\n        setActiveBranch(suspense, fallbackVNode);\n      };\n      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === \"out-in\";\n      if (delayEnter) {\n        activeBranch.transition.afterLeave = mountFallback;\n      }\n      suspense.isInFallback = true;\n      unmount(\n        activeBranch,\n        parentComponent2,\n        null,\n        // no suspense so unmount hooks fire now\n        true\n        // shouldRemove\n      );\n      if (!delayEnter) {\n        mountFallback();\n      }\n    },\n    move(container2, anchor2, type) {\n      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);\n      suspense.container = container2;\n    },\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch);\n    },\n    registerDep(instance, setupRenderEffect, optimized2) {\n      const isInPendingSuspense = !!suspense.pendingBranch;\n      if (isInPendingSuspense) {\n        suspense.deps++;\n      }\n      const hydratedEl = instance.vnode.el;\n      instance.asyncDep.catch((err) => {\n        handleError(err, instance, 0);\n      }).then((asyncSetupResult) => {\n        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {\n          return;\n        }\n        instance.asyncResolved = true;\n        const { vnode: vnode2 } = instance;\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          pushWarningContext(vnode2);\n        }\n        handleSetupResult(instance, asyncSetupResult, false);\n        if (hydratedEl) {\n          vnode2.el = hydratedEl;\n        }\n        const placeholder = !hydratedEl && instance.subTree.el;\n        setupRenderEffect(\n          instance,\n          vnode2,\n          // component may have been moved before resolve.\n          // if this is not a hydration, instance.subTree will be the comment\n          // placeholder.\n          parentNode(hydratedEl || instance.subTree.el),\n          // anchor will not be used if this is hydration, so only need to\n          // consider the comment placeholder case.\n          hydratedEl ? null : next(instance.subTree),\n          suspense,\n          namespace,\n          optimized2\n        );\n        if (placeholder) {\n          vnode2.placeholder = null;\n          remove(placeholder);\n        }\n        updateHOCHostEl(instance, vnode2.el);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          popWarningContext();\n        }\n        if (isInPendingSuspense && --suspense.deps === 0) {\n          suspense.resolve();\n        }\n      });\n    },\n    unmount(parentSuspense2, doRemove) {\n      suspense.isUnmounted = true;\n      if (suspense.activeBranch) {\n        unmount(\n          suspense.activeBranch,\n          parentComponent,\n          parentSuspense2,\n          doRemove\n        );\n      }\n      if (suspense.pendingBranch) {\n        unmount(\n          suspense.pendingBranch,\n          parentComponent,\n          parentSuspense2,\n          doRemove\n        );\n      }\n    }\n  };\n  return suspense;\n}\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {\n  const suspense = vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    node.parentNode,\n    // eslint-disable-next-line no-restricted-globals\n    document.createElement(\"div\"),\n    null,\n    namespace,\n    slotScopeIds,\n    optimized,\n    rendererInternals,\n    true\n  );\n  const result = hydrateNode(\n    node,\n    suspense.pendingBranch = vnode.ssContent,\n    parentComponent,\n    suspense,\n    slotScopeIds,\n    optimized\n  );\n  if (suspense.deps === 0) {\n    suspense.resolve(false, true);\n  }\n  return result;\n}\nfunction normalizeSuspenseChildren(vnode) {\n  const { shapeFlag, children } = vnode;\n  const isSlotChildren = shapeFlag & 32;\n  vnode.ssContent = normalizeSuspenseSlot(\n    isSlotChildren ? children.default : children\n  );\n  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);\n}\nfunction normalizeSuspenseSlot(s) {\n  let block;\n  if (isFunction(s)) {\n    const trackBlock = isBlockTreeEnabled && s._c;\n    if (trackBlock) {\n      s._d = false;\n      openBlock();\n    }\n    s = s();\n    if (trackBlock) {\n      s._d = true;\n      block = currentBlock;\n      closeBlock();\n    }\n  }\n  if (isArray(s)) {\n    const singleChild = filterSingleRoot(s);\n    if (!!(process.env.NODE_ENV !== \"production\") && !singleChild && s.filter((child) => child !== NULL_DYNAMIC_COMPONENT).length > 0) {\n      warn$1(`<Suspense> slots expect a single root node.`);\n    }\n    s = singleChild;\n  }\n  s = normalizeVNode(s);\n  if (block && !s.dynamicChildren) {\n    s.dynamicChildren = block.filter((c) => c !== s);\n  }\n  return s;\n}\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if (isArray(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n}\nfunction setActiveBranch(suspense, branch) {\n  suspense.activeBranch = branch;\n  const { vnode, parentComponent } = suspense;\n  let el = branch.el;\n  while (!el && branch.component) {\n    branch = branch.component.subTree;\n    el = branch.el;\n  }\n  vnode.el = el;\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el;\n    updateHOCHostEl(parentComponent, el);\n  }\n}\nfunction isVNodeSuspensible(vnode) {\n  const suspensible = vnode.props && vnode.props.suspensible;\n  return suspensible != null && suspensible !== false;\n}\n\nconst Fragment = Symbol.for(\"v-fgt\");\nconst Text = Symbol.for(\"v-txt\");\nconst Comment = Symbol.for(\"v-cmt\");\nconst Static = Symbol.for(\"v-stc\");\nconst blockStack = [];\nlet currentBlock = null;\nfunction openBlock(disableTracking = false) {\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n}\nlet isBlockTreeEnabled = 1;\nfunction setBlockTracking(value, inVOnce = false) {\n  isBlockTreeEnabled += value;\n  if (value < 0 && currentBlock && inVOnce) {\n    currentBlock.hasOnce = true;\n  }\n}\nfunction setupBlock(vnode) {\n  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;\n  closeBlock();\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(\n    createBaseVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      shapeFlag,\n      true\n    )\n  );\n}\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n  return setupBlock(\n    createVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      true\n    )\n  );\n}\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\nfunction isSameVNodeType(n1, n2) {\n  if (!!(process.env.NODE_ENV !== \"production\") && n2.shapeFlag & 6 && n1.component) {\n    const dirtyInstances = hmrDirtyComponents.get(n2.type);\n    if (dirtyInstances && dirtyInstances.has(n1.component)) {\n      n1.shapeFlag &= -257;\n      n2.shapeFlag &= -513;\n      return false;\n    }\n  }\n  return n1.type === n2.type && n1.key === n2.key;\n}\nlet vnodeArgsTransformer;\nfunction transformVNodeArgs(transformer) {\n  vnodeArgsTransformer = transformer;\n}\nconst createVNodeWithArgsTransform = (...args) => {\n  return _createVNode(\n    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args\n  );\n};\nconst normalizeKey = ({ key }) => key != null ? key : null;\nconst normalizeRef = ({\n  ref,\n  ref_key,\n  ref_for\n}) => {\n  if (typeof ref === \"number\") {\n    ref = \"\" + ref;\n  }\n  return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;\n};\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetStart: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: currentRenderingInstance\n  };\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children);\n    if (shapeFlag & 128) {\n      type.normalize(vnode);\n    }\n  } else if (children) {\n    vnode.shapeFlag |= isString(children) ? 8 : 16;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && vnode.key !== vnode.key) {\n    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\n  }\n  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself\n  !isBlockNode && // has current parent block\n  currentBlock && // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  vnode.patchFlag !== 32) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nconst createVNode = !!(process.env.NODE_ENV !== \"production\") ? createVNodeWithArgsTransform : _createVNode;\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !type) {\n      warn$1(`Invalid vnode type when creating vnode: ${type}.`);\n    }\n    type = Comment;\n  }\n  if (isVNode(type)) {\n    const cloned = cloneVNode(\n      type,\n      props,\n      true\n      /* mergeRef: true */\n    );\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\n      if (cloned.shapeFlag & 6) {\n        currentBlock[currentBlock.indexOf(type)] = cloned;\n      } else {\n        currentBlock.push(cloned);\n      }\n    }\n    cloned.patchFlag = -2;\n    return cloned;\n  }\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  }\n  if (props) {\n    props = guardReactiveProps(props);\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n      props.class = normalizeClass(klass);\n    }\n    if (isObject(style)) {\n      if (isProxy(style) && !isArray(style)) {\n        style = extend({}, style);\n      }\n      props.style = normalizeStyle(style);\n    }\n  }\n  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;\n  if (!!(process.env.NODE_ENV !== \"production\") && shapeFlag & 4 && isProxy(type)) {\n    type = toRaw(type);\n    warn$1(\n      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \\`markRaw\\` or using \\`shallowRef\\` instead of \\`ref\\`.`,\n      `\nComponent that was made reactive: `,\n      type\n    );\n  }\n  return createBaseVNode(\n    type,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    shapeFlag,\n    isBlockNode,\n    true\n  );\n}\nfunction guardReactiveProps(props) {\n  if (!props) return null;\n  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;\n}\nfunction cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {\n  const { props, ref, patchFlag, children, transition } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  const cloned = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ? (\n      // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n      // if the vnode itself already has a ref, cloneVNode will need to merge\n      // the refs so the single vnode can be set on multiple refs\n      mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)\n    ) : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children: !!(process.env.NODE_ENV !== \"production\") && patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,\n    target: vnode.target,\n    targetStart: vnode.targetStart,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    placeholder: vnode.placeholder,\n    el: vnode.el,\n    anchor: vnode.anchor,\n    ctx: vnode.ctx,\n    ce: vnode.ce\n  };\n  if (transition && cloneTransition) {\n    setTransitionHooks(\n      cloned,\n      transition.clone(cloned)\n    );\n  }\n  return cloned;\n}\nfunction deepCloneVNode(vnode) {\n  const cloned = cloneVNode(vnode);\n  if (isArray(vnode.children)) {\n    cloned.children = vnode.children.map(deepCloneVNode);\n  }\n  return cloned;\n}\nfunction createTextVNode(text = \" \", flag = 0) {\n  return createVNode(Text, null, text, flag);\n}\nfunction createStaticVNode(content, numberOfNodes) {\n  const vnode = createVNode(Static, null, content);\n  vnode.staticCount = numberOfNodes;\n  return vnode;\n}\nfunction createCommentVNode(text = \"\", asBlock = false) {\n  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);\n}\nfunction normalizeVNode(child) {\n  if (child == null || typeof child === \"boolean\") {\n    return createVNode(Comment);\n  } else if (isArray(child)) {\n    return createVNode(\n      Fragment,\n      null,\n      // #3666, avoid reference pollution when reusing vnode\n      child.slice()\n    );\n  } else if (isVNode(child)) {\n    return cloneIfMounted(child);\n  } else {\n    return createVNode(Text, null, String(child));\n  }\n}\nfunction cloneIfMounted(child) {\n  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);\n}\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const { shapeFlag } = vnode;\n  if (children == null) {\n    children = null;\n  } else if (isArray(children)) {\n    type = 16;\n  } else if (typeof children === \"object\") {\n    if (shapeFlag & (1 | 64)) {\n      const slot = children.default;\n      if (slot) {\n        slot._c && (slot._d = false);\n        normalizeChildren(vnode, slot());\n        slot._c && (slot._d = true);\n      }\n      return;\n    } else {\n      type = 32;\n      const slotFlag = children._;\n      if (!slotFlag && !isInternalObject(children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3 && currentRenderingInstance) {\n        if (currentRenderingInstance.slots._ === 1) {\n          children._ = 1;\n        } else {\n          children._ = 2;\n          vnode.patchFlag |= 1024;\n        }\n      }\n    }\n  } else if (isFunction(children)) {\n    children = { default: children, _ctx: currentRenderingInstance };\n    type = 32;\n  } else {\n    children = String(children);\n    if (shapeFlag & 64) {\n      type = 16;\n      children = [createTextVNode(children)];\n    } else {\n      type = 8;\n    }\n  }\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\nfunction mergeProps(...args) {\n  const ret = {};\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i];\n    for (const key in toMerge) {\n      if (key === \"class\") {\n        if (ret.class !== toMerge.class) {\n          ret.class = normalizeClass([ret.class, toMerge.class]);\n        }\n      } else if (key === \"style\") {\n        ret.style = normalizeStyle([ret.style, toMerge.style]);\n      } else if (isOn(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {\n          ret[key] = existing ? [].concat(existing, incoming) : incoming;\n        }\n      } else if (key !== \"\") {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n  return ret;\n}\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n  callWithAsyncErrorHandling(hook, instance, 7, [\n    vnode,\n    prevVNode\n  ]);\n}\n\nconst emptyAppContext = createAppContext();\nlet uid = 0;\nfunction createComponentInstance(vnode, parent, suspense) {\n  const type = vnode.type;\n  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n  const instance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null,\n    // to be immediately set\n    next: null,\n    subTree: null,\n    // will be set synchronously right after creation\n    effect: null,\n    update: null,\n    // will be set synchronously right after creation\n    job: null,\n    scope: new EffectScope(\n      true\n      /* detached */\n    ),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    ids: parent ? parent.ids : [\"\", 0, 0],\n    accessCache: null,\n    renderCache: [],\n    // local resolved assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n    // emit\n    emit: null,\n    // to be set immediately\n    emitted: null,\n    // props default value\n    propsDefaults: EMPTY_OBJ,\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n    // state\n    ctx: EMPTY_OBJ,\n    data: EMPTY_OBJ,\n    props: EMPTY_OBJ,\n    attrs: EMPTY_OBJ,\n    slots: EMPTY_OBJ,\n    refs: EMPTY_OBJ,\n    setupState: EMPTY_OBJ,\n    setupContext: null,\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    instance.ctx = createDevRenderContext(instance);\n  } else {\n    instance.ctx = { _: instance };\n  }\n  instance.root = parent ? parent.root : instance;\n  instance.emit = emit.bind(null, instance);\n  if (vnode.ce) {\n    vnode.ce(instance);\n  }\n  return instance;\n}\nlet currentInstance = null;\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\nlet internalSetCurrentInstance;\nlet setInSSRSetupState;\n{\n  const g = getGlobalThis();\n  const registerGlobalSetter = (key, setter) => {\n    let setters;\n    if (!(setters = g[key])) setters = g[key] = [];\n    setters.push(setter);\n    return (v) => {\n      if (setters.length > 1) setters.forEach((set) => set(v));\n      else setters[0](v);\n    };\n  };\n  internalSetCurrentInstance = registerGlobalSetter(\n    `__VUE_INSTANCE_SETTERS__`,\n    (v) => currentInstance = v\n  );\n  setInSSRSetupState = registerGlobalSetter(\n    `__VUE_SSR_SETTERS__`,\n    (v) => isInSSRComponentSetup = v\n  );\n}\nconst setCurrentInstance = (instance) => {\n  const prev = currentInstance;\n  internalSetCurrentInstance(instance);\n  instance.scope.on();\n  return () => {\n    instance.scope.off();\n    internalSetCurrentInstance(prev);\n  };\n};\nconst unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off();\n  internalSetCurrentInstance(null);\n};\nconst isBuiltInTag = /* @__PURE__ */ makeMap(\"slot,component\");\nfunction validateComponentName(name, { isNativeTag }) {\n  if (isBuiltInTag(name) || isNativeTag(name)) {\n    warn$1(\n      \"Do not use built-in or reserved HTML elements as component id: \" + name\n    );\n  }\n}\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & 4;\n}\nlet isInSSRComponentSetup = false;\nfunction setupComponent(instance, isSSR = false, optimized = false) {\n  isSSR && setInSSRSetupState(isSSR);\n  const { props, children } = instance.vnode;\n  const isStateful = isStatefulComponent(instance);\n  initProps(instance, props, isStateful, isSSR);\n  initSlots(instance, children, optimized || isSSR);\n  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;\n  isSSR && setInSSRSetupState(false);\n  return setupResult;\n}\nfunction setupStatefulComponent(instance, isSSR) {\n  var _a;\n  const Component = instance.type;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    if (Component.name) {\n      validateComponentName(Component.name, instance.appContext.config);\n    }\n    if (Component.components) {\n      const names = Object.keys(Component.components);\n      for (let i = 0; i < names.length; i++) {\n        validateComponentName(names[i], instance.appContext.config);\n      }\n    }\n    if (Component.directives) {\n      const names = Object.keys(Component.directives);\n      for (let i = 0; i < names.length; i++) {\n        validateDirectiveName(names[i]);\n      }\n    }\n    if (Component.compilerOptions && isRuntimeOnly()) {\n      warn$1(\n        `\"compilerOptions\" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`\n      );\n    }\n  }\n  instance.accessCache = /* @__PURE__ */ Object.create(null);\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    exposePropsOnRenderContext(instance);\n  }\n  const { setup } = Component;\n  if (setup) {\n    pauseTracking();\n    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;\n    const reset = setCurrentInstance(instance);\n    const setupResult = callWithErrorHandling(\n      setup,\n      instance,\n      0,\n      [\n        !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(instance.props) : instance.props,\n        setupContext\n      ]\n    );\n    const isAsyncSetup = isPromise(setupResult);\n    resetTracking();\n    reset();\n    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {\n      markAsyncBoundary(instance);\n    }\n    if (isAsyncSetup) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\n      if (isSSR) {\n        return setupResult.then((resolvedResult) => {\n          handleSetupResult(instance, resolvedResult, isSSR);\n        }).catch((e) => {\n          handleError(e, instance, 0);\n        });\n      } else {\n        instance.asyncDep = setupResult;\n        if (!!(process.env.NODE_ENV !== \"production\") && !instance.suspense) {\n          const name = (_a = Component.name) != null ? _a : \"Anonymous\";\n          warn$1(\n            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`\n          );\n        }\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR);\n    }\n  } else {\n    finishComponentSetup(instance, isSSR);\n  }\n}\nfunction handleSetupResult(instance, setupResult, isSSR) {\n  if (isFunction(setupResult)) {\n    if (instance.type.__ssrInlineRender) {\n      instance.ssrRender = setupResult;\n    } else {\n      instance.render = setupResult;\n    }\n  } else if (isObject(setupResult)) {\n    if (!!(process.env.NODE_ENV !== \"production\") && isVNode(setupResult)) {\n      warn$1(\n        `setup() should not return VNodes directly - return a render function instead.`\n      );\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      instance.devtoolsRawSetupState = setupResult;\n    }\n    instance.setupState = proxyRefs(setupResult);\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      exposeSetupStateOnRenderContext(instance);\n    }\n  } else if (!!(process.env.NODE_ENV !== \"production\") && setupResult !== void 0) {\n    warn$1(\n      `setup() should return an object. Received: ${setupResult === null ? \"null\" : typeof setupResult}`\n    );\n  }\n  finishComponentSetup(instance, isSSR);\n}\nlet compile;\nlet installWithProxy;\nfunction registerRuntimeCompiler(_compile) {\n  compile = _compile;\n  installWithProxy = (i) => {\n    if (i.render._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n    }\n  };\n}\nconst isRuntimeOnly = () => !compile;\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\n  const Component = instance.type;\n  if (!instance.render) {\n    if (!isSSR && compile && !Component.render) {\n      const template = Component.template || __VUE_OPTIONS_API__ && resolveMergedOptions(instance).template;\n      if (template) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          startMeasure(instance, `compile`);\n        }\n        const { isCustomElement, compilerOptions } = instance.appContext.config;\n        const { delimiters, compilerOptions: componentCompilerOptions } = Component;\n        const finalCompilerOptions = extend(\n          extend(\n            {\n              isCustomElement,\n              delimiters\n            },\n            compilerOptions\n          ),\n          componentCompilerOptions\n        );\n        Component.render = compile(template, finalCompilerOptions);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          endMeasure(instance, `compile`);\n        }\n      }\n    }\n    instance.render = Component.render || NOOP;\n    if (installWithProxy) {\n      installWithProxy(instance);\n    }\n  }\n  if (__VUE_OPTIONS_API__ && true) {\n    const reset = setCurrentInstance(instance);\n    pauseTracking();\n    try {\n      applyOptions(instance);\n    } finally {\n      resetTracking();\n      reset();\n    }\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && !Component.render && instance.render === NOOP && !isSSR) {\n    if (!compile && Component.template) {\n      warn$1(\n        `Component provided template option but runtime compilation is not supported in this build of Vue.` + (` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".` )\n      );\n    } else {\n      warn$1(`Component is missing template or render function: `, Component);\n    }\n  }\n}\nconst attrsProxyHandlers = !!(process.env.NODE_ENV !== \"production\") ? {\n  get(target, key) {\n    markAttrsAccessed();\n    track(target, \"get\", \"\");\n    return target[key];\n  },\n  set() {\n    warn$1(`setupContext.attrs is readonly.`);\n    return false;\n  },\n  deleteProperty() {\n    warn$1(`setupContext.attrs is readonly.`);\n    return false;\n  }\n} : {\n  get(target, key) {\n    track(target, \"get\", \"\");\n    return target[key];\n  }\n};\nfunction getSlotsProxy(instance) {\n  return new Proxy(instance.slots, {\n    get(target, key) {\n      track(instance, \"get\", \"$slots\");\n      return target[key];\n    }\n  });\n}\nfunction createSetupContext(instance) {\n  const expose = (exposed) => {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      if (instance.exposed) {\n        warn$1(`expose() should be called only once per setup().`);\n      }\n      if (exposed != null) {\n        let exposedType = typeof exposed;\n        if (exposedType === \"object\") {\n          if (isArray(exposed)) {\n            exposedType = \"array\";\n          } else if (isRef(exposed)) {\n            exposedType = \"ref\";\n          }\n        }\n        if (exposedType !== \"object\") {\n          warn$1(\n            `expose() should be passed a plain object, received ${exposedType}.`\n          );\n        }\n      }\n    }\n    instance.exposed = exposed || {};\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    let attrsProxy;\n    let slotsProxy;\n    return Object.freeze({\n      get attrs() {\n        return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));\n      },\n      get slots() {\n        return slotsProxy || (slotsProxy = getSlotsProxy(instance));\n      },\n      get emit() {\n        return (event, ...args) => instance.emit(event, ...args);\n      },\n      expose\n    });\n  } else {\n    return {\n      attrs: new Proxy(instance.attrs, attrsProxyHandlers),\n      slots: instance.slots,\n      emit: instance.emit,\n      expose\n    };\n  }\n}\nfunction getComponentPublicInstance(instance) {\n  if (instance.exposed) {\n    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        } else if (key in publicPropertiesMap) {\n          return publicPropertiesMap[key](instance);\n        }\n      },\n      has(target, key) {\n        return key in target || key in publicPropertiesMap;\n      }\n    }));\n  } else {\n    return instance.proxy;\n  }\n}\nconst classifyRE = /(?:^|[-_])\\w/g;\nconst classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, \"\");\nfunction getComponentName(Component, includeInferred = true) {\n  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;\n}\nfunction formatComponentName(instance, Component, isRoot = false) {\n  let name = getComponentName(Component);\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n    if (match) {\n      name = match[1];\n    }\n  }\n  if (!name && instance && instance.parent) {\n    const inferFromRegistry = (registry) => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key;\n        }\n      }\n    };\n    name = inferFromRegistry(\n      instance.components || instance.parent.type.components\n    ) || inferFromRegistry(instance.appContext.components);\n  }\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\nfunction isClassComponent(value) {\n  return isFunction(value) && \"__vccOpts\" in value;\n}\n\nconst computed = (getterOrOptions, debugOptions) => {\n  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const i = getCurrentInstance();\n    if (i && i.appContext.config.warnRecursiveComputed) {\n      c._warnRecursive = true;\n    }\n  }\n  return c;\n};\n\nfunction h(type, propsOrChildren, children) {\n  try {\n    setBlockTracking(-1);\n    const l = arguments.length;\n    if (l === 2) {\n      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\n        if (isVNode(propsOrChildren)) {\n          return createVNode(type, null, [propsOrChildren]);\n        }\n        return createVNode(type, propsOrChildren);\n      } else {\n        return createVNode(type, null, propsOrChildren);\n      }\n    } else {\n      if (l > 3) {\n        children = Array.prototype.slice.call(arguments, 2);\n      } else if (l === 3 && isVNode(children)) {\n        children = [children];\n      }\n      return createVNode(type, propsOrChildren, children);\n    }\n  } finally {\n    setBlockTracking(1);\n  }\n}\n\nfunction initCustomFormatter() {\n  if (!!!(process.env.NODE_ENV !== \"production\") || typeof window === \"undefined\") {\n    return;\n  }\n  const vueStyle = { style: \"color:#3ba776\" };\n  const numberStyle = { style: \"color:#1677ff\" };\n  const stringStyle = { style: \"color:#f5222d\" };\n  const keywordStyle = { style: \"color:#eb2f96\" };\n  const formatter = {\n    __vue_custom_formatter: true,\n    header(obj) {\n      if (!isObject(obj)) {\n        return null;\n      }\n      if (obj.__isVue) {\n        return [\"div\", vueStyle, `VueInstance`];\n      } else if (isRef(obj)) {\n        pauseTracking();\n        const value = obj.value;\n        resetTracking();\n        return [\n          \"div\",\n          {},\n          [\"span\", vueStyle, genRefFlag(obj)],\n          \"<\",\n          formatValue(value),\n          `>`\n        ];\n      } else if (isReactive(obj)) {\n        return [\n          \"div\",\n          {},\n          [\"span\", vueStyle, isShallow(obj) ? \"ShallowReactive\" : \"Reactive\"],\n          \"<\",\n          formatValue(obj),\n          `>${isReadonly(obj) ? ` (readonly)` : ``}`\n        ];\n      } else if (isReadonly(obj)) {\n        return [\n          \"div\",\n          {},\n          [\"span\", vueStyle, isShallow(obj) ? \"ShallowReadonly\" : \"Readonly\"],\n          \"<\",\n          formatValue(obj),\n          \">\"\n        ];\n      }\n      return null;\n    },\n    hasBody(obj) {\n      return obj && obj.__isVue;\n    },\n    body(obj) {\n      if (obj && obj.__isVue) {\n        return [\n          \"div\",\n          {},\n          ...formatInstance(obj.$)\n        ];\n      }\n    }\n  };\n  function formatInstance(instance) {\n    const blocks = [];\n    if (instance.type.props && instance.props) {\n      blocks.push(createInstanceBlock(\"props\", toRaw(instance.props)));\n    }\n    if (instance.setupState !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock(\"setup\", instance.setupState));\n    }\n    if (instance.data !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock(\"data\", toRaw(instance.data)));\n    }\n    const computed = extractKeys(instance, \"computed\");\n    if (computed) {\n      blocks.push(createInstanceBlock(\"computed\", computed));\n    }\n    const injected = extractKeys(instance, \"inject\");\n    if (injected) {\n      blocks.push(createInstanceBlock(\"injected\", injected));\n    }\n    blocks.push([\n      \"div\",\n      {},\n      [\n        \"span\",\n        {\n          style: keywordStyle.style + \";opacity:0.66\"\n        },\n        \"$ (internal): \"\n      ],\n      [\"object\", { object: instance }]\n    ]);\n    return blocks;\n  }\n  function createInstanceBlock(type, target) {\n    target = extend({}, target);\n    if (!Object.keys(target).length) {\n      return [\"span\", {}];\n    }\n    return [\n      \"div\",\n      { style: \"line-height:1.25em;margin-bottom:0.6em\" },\n      [\n        \"div\",\n        {\n          style: \"color:#476582\"\n        },\n        type\n      ],\n      [\n        \"div\",\n        {\n          style: \"padding-left:1.25em\"\n        },\n        ...Object.keys(target).map((key) => {\n          return [\n            \"div\",\n            {},\n            [\"span\", keywordStyle, key + \": \"],\n            formatValue(target[key], false)\n          ];\n        })\n      ]\n    ];\n  }\n  function formatValue(v, asRaw = true) {\n    if (typeof v === \"number\") {\n      return [\"span\", numberStyle, v];\n    } else if (typeof v === \"string\") {\n      return [\"span\", stringStyle, JSON.stringify(v)];\n    } else if (typeof v === \"boolean\") {\n      return [\"span\", keywordStyle, v];\n    } else if (isObject(v)) {\n      return [\"object\", { object: asRaw ? toRaw(v) : v }];\n    } else {\n      return [\"span\", stringStyle, String(v)];\n    }\n  }\n  function extractKeys(instance, type) {\n    const Comp = instance.type;\n    if (isFunction(Comp)) {\n      return;\n    }\n    const extracted = {};\n    for (const key in instance.ctx) {\n      if (isKeyOfType(Comp, key, type)) {\n        extracted[key] = instance.ctx[key];\n      }\n    }\n    return extracted;\n  }\n  function isKeyOfType(Comp, key, type) {\n    const opts = Comp[type];\n    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {\n      return true;\n    }\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n      return true;\n    }\n    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {\n      return true;\n    }\n  }\n  function genRefFlag(v) {\n    if (isShallow(v)) {\n      return `ShallowRef`;\n    }\n    if (v.effect) {\n      return `ComputedRef`;\n    }\n    return `Ref`;\n  }\n  if (window.devtoolsFormatters) {\n    window.devtoolsFormatters.push(formatter);\n  } else {\n    window.devtoolsFormatters = [formatter];\n  }\n}\n\nfunction withMemo(memo, render, cache, index) {\n  const cached = cache[index];\n  if (cached && isMemoSame(cached, memo)) {\n    return cached;\n  }\n  const ret = render();\n  ret.memo = memo.slice();\n  ret.cacheIndex = index;\n  return cache[index] = ret;\n}\nfunction isMemoSame(cached, memo) {\n  const prev = cached.memo;\n  if (prev.length != memo.length) {\n    return false;\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if (hasChanged(prev[i], memo[i])) {\n      return false;\n    }\n  }\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(cached);\n  }\n  return true;\n}\n\nconst version = \"3.5.24\";\nconst warn = !!(process.env.NODE_ENV !== \"production\") ? warn$1 : NOOP;\nconst ErrorTypeStrings = ErrorTypeStrings$1 ;\nconst devtools = !!(process.env.NODE_ENV !== \"production\") || true ? devtools$1 : void 0;\nconst setDevtoolsHook = !!(process.env.NODE_ENV !== \"production\") || true ? setDevtoolsHook$1 : NOOP;\nconst _ssrUtils = {\n  createComponentInstance,\n  setupComponent,\n  renderComponentRoot,\n  setCurrentRenderingInstance,\n  isVNode: isVNode,\n  normalizeVNode,\n  getComponentPublicInstance,\n  ensureValidVNode,\n  pushWarningContext,\n  popWarningContext\n};\nconst ssrUtils = _ssrUtils ;\nconst resolveFilter = null;\nconst compatUtils = null;\nconst DeprecationTypes = null;\n\nexport { BaseTransition, BaseTransitionPropsValidators, Comment, DeprecationTypes, ErrorCodes, ErrorTypeStrings, Fragment, KeepAlive, Static, Suspense, Teleport, Text, assertNumber, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, compatUtils, computed, createBlock, createCommentVNode, createElementBlock, createBaseVNode as createElementVNode, createHydrationRenderer, createPropsRestProxy, createRenderer, createSlots, createStaticVNode, createTextVNode, createVNode, defineAsyncComponent, defineComponent, defineEmits, defineExpose, defineModel, defineOptions, defineProps, defineSlots, devtools, getCurrentInstance, getTransitionRawChildren, guardReactiveProps, h, handleError, hasInjectionContext, hydrateOnIdle, hydrateOnInteraction, hydrateOnMediaQuery, hydrateOnVisible, initCustomFormatter, inject, isMemoSame, isRuntimeOnly, isVNode, mergeDefaults, mergeModels, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onServerPrefetch, onUnmounted, onUpdated, openBlock, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveFilter, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useAttrs, useId, useModel, useSSRContext, useSlots, useTemplateRef, useTransitionState, version, warn, watch, watchEffect, watchPostEffect, watchSyncEffect, withAsyncContext, withCtx, withDefaults, withDirectives, withMemo, withScopeId };\n","/**\n* @vue/runtime-dom v3.5.24\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { warn, BaseTransitionPropsValidators, h, BaseTransition, assertNumber, getCurrentInstance, onBeforeUpdate, queuePostFlushCb, onMounted, watch, onUnmounted, Fragment, Static, camelize, callWithAsyncErrorHandling, defineComponent, nextTick, unref, createVNode, useTransitionState, onUpdated, toRaw, getTransitionRawChildren, setTransitionHooks, resolveTransitionHooks, Text, createRenderer, createHydrationRenderer, isRuntimeOnly } from '@vue/runtime-core';\nexport * from '@vue/runtime-core';\nimport { extend, isObject, toNumber, isArray, NOOP, normalizeCssVarValue, isString, hyphenate, capitalize, isSpecialBooleanAttr, includeBooleanAttr, isSymbol, isFunction, isOn, isModelListener, camelize as camelize$1, isPlainObject, hasOwn, EMPTY_OBJ, looseToNumber, looseIndexOf, isSet, looseEqual, invokeArrayFns, isHTMLTag, isSVGTag, isMathMLTag } from '@vue/shared';\n\nlet policy = void 0;\nconst tt = typeof window !== \"undefined\" && window.trustedTypes;\nif (tt) {\n  try {\n    policy = /* @__PURE__ */ tt.createPolicy(\"vue\", {\n      createHTML: (val) => val\n    });\n  } catch (e) {\n    !!(process.env.NODE_ENV !== \"production\") && warn(`Error creating trusted types policy: ${e}`);\n  }\n}\nconst unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;\nconst svgNS = \"http://www.w3.org/2000/svg\";\nconst mathmlNS = \"http://www.w3.org/1998/Math/MathML\";\nconst doc = typeof document !== \"undefined\" ? document : null;\nconst templateContainer = doc && /* @__PURE__ */ doc.createElement(\"template\");\nconst nodeOps = {\n  insert: (child, parent, anchor) => {\n    parent.insertBefore(child, anchor || null);\n  },\n  remove: (child) => {\n    const parent = child.parentNode;\n    if (parent) {\n      parent.removeChild(child);\n    }\n  },\n  createElement: (tag, namespace, is, props) => {\n    const el = namespace === \"svg\" ? doc.createElementNS(svgNS, tag) : namespace === \"mathml\" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);\n    if (tag === \"select\" && props && props.multiple != null) {\n      el.setAttribute(\"multiple\", props.multiple);\n    }\n    return el;\n  },\n  createText: (text) => doc.createTextNode(text),\n  createComment: (text) => doc.createComment(text),\n  setText: (node, text) => {\n    node.nodeValue = text;\n  },\n  setElementText: (el, text) => {\n    el.textContent = text;\n  },\n  parentNode: (node) => node.parentNode,\n  nextSibling: (node) => node.nextSibling,\n  querySelector: (selector) => doc.querySelector(selector),\n  setScopeId(el, id) {\n    el.setAttribute(id, \"\");\n  },\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(content, parent, anchor, namespace, start, end) {\n    const before = anchor ? anchor.previousSibling : parent.lastChild;\n    if (start && (start === end || start.nextSibling)) {\n      while (true) {\n        parent.insertBefore(start.cloneNode(true), anchor);\n        if (start === end || !(start = start.nextSibling)) break;\n      }\n    } else {\n      templateContainer.innerHTML = unsafeToTrustedHTML(\n        namespace === \"svg\" ? `<svg>${content}</svg>` : namespace === \"mathml\" ? `<math>${content}</math>` : content\n      );\n      const template = templateContainer.content;\n      if (namespace === \"svg\" || namespace === \"mathml\") {\n        const wrapper = template.firstChild;\n        while (wrapper.firstChild) {\n          template.appendChild(wrapper.firstChild);\n        }\n        template.removeChild(wrapper);\n      }\n      parent.insertBefore(template, anchor);\n    }\n    return [\n      // first\n      before ? before.nextSibling : parent.firstChild,\n      // last\n      anchor ? anchor.previousSibling : parent.lastChild\n    ];\n  }\n};\n\nconst TRANSITION = \"transition\";\nconst ANIMATION = \"animation\";\nconst vtcKey = Symbol(\"_vtc\");\nconst DOMTransitionPropsValidators = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: true\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n};\nconst TransitionPropsValidators = /* @__PURE__ */ extend(\n  {},\n  BaseTransitionPropsValidators,\n  DOMTransitionPropsValidators\n);\nconst decorate$1 = (t) => {\n  t.displayName = \"Transition\";\n  t.props = TransitionPropsValidators;\n  return t;\n};\nconst Transition = /* @__PURE__ */ decorate$1(\n  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)\n);\nconst callHook = (hook, args = []) => {\n  if (isArray(hook)) {\n    hook.forEach((h2) => h2(...args));\n  } else if (hook) {\n    hook(...args);\n  }\n};\nconst hasExplicitCallback = (hook) => {\n  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;\n};\nfunction resolveTransitionProps(rawProps) {\n  const baseProps = {};\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      baseProps[key] = rawProps[key];\n    }\n  }\n  if (rawProps.css === false) {\n    return baseProps;\n  }\n  const {\n    name = \"v\",\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps;\n  const durations = normalizeDuration(duration);\n  const enterDuration = durations && durations[0];\n  const leaveDuration = durations && durations[1];\n  const {\n    onBeforeEnter,\n    onEnter,\n    onEnterCancelled,\n    onLeave,\n    onLeaveCancelled,\n    onBeforeAppear = onBeforeEnter,\n    onAppear = onEnter,\n    onAppearCancelled = onEnterCancelled\n  } = baseProps;\n  const finishEnter = (el, isAppear, done, isCancelled) => {\n    el._enterCancelled = isCancelled;\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n    done && done();\n  };\n  const finishLeave = (el, done) => {\n    el._isLeaving = false;\n    removeTransitionClass(el, leaveFromClass);\n    removeTransitionClass(el, leaveToClass);\n    removeTransitionClass(el, leaveActiveClass);\n    done && done();\n  };\n  const makeEnterHook = (isAppear) => {\n    return (el, done) => {\n      const hook = isAppear ? onAppear : onEnter;\n      const resolve = () => finishEnter(el, isAppear, done);\n      callHook(hook, [el, resolve]);\n      nextFrame(() => {\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        if (!hasExplicitCallback(hook)) {\n          whenTransitionEnds(el, type, enterDuration, resolve);\n        }\n      });\n    };\n  };\n  return extend(baseProps, {\n    onBeforeEnter(el) {\n      callHook(onBeforeEnter, [el]);\n      addTransitionClass(el, enterFromClass);\n      addTransitionClass(el, enterActiveClass);\n    },\n    onBeforeAppear(el) {\n      callHook(onBeforeAppear, [el]);\n      addTransitionClass(el, appearFromClass);\n      addTransitionClass(el, appearActiveClass);\n    },\n    onEnter: makeEnterHook(false),\n    onAppear: makeEnterHook(true),\n    onLeave(el, done) {\n      el._isLeaving = true;\n      const resolve = () => finishLeave(el, done);\n      addTransitionClass(el, leaveFromClass);\n      if (!el._enterCancelled) {\n        forceReflow(el);\n        addTransitionClass(el, leaveActiveClass);\n      } else {\n        addTransitionClass(el, leaveActiveClass);\n        forceReflow(el);\n      }\n      nextFrame(() => {\n        if (!el._isLeaving) {\n          return;\n        }\n        removeTransitionClass(el, leaveFromClass);\n        addTransitionClass(el, leaveToClass);\n        if (!hasExplicitCallback(onLeave)) {\n          whenTransitionEnds(el, type, leaveDuration, resolve);\n        }\n      });\n      callHook(onLeave, [el, resolve]);\n    },\n    onEnterCancelled(el) {\n      finishEnter(el, false, void 0, true);\n      callHook(onEnterCancelled, [el]);\n    },\n    onAppearCancelled(el) {\n      finishEnter(el, true, void 0, true);\n      callHook(onAppearCancelled, [el]);\n    },\n    onLeaveCancelled(el) {\n      finishLeave(el);\n      callHook(onLeaveCancelled, [el]);\n    }\n  });\n}\nfunction normalizeDuration(duration) {\n  if (duration == null) {\n    return null;\n  } else if (isObject(duration)) {\n    return [NumberOf(duration.enter), NumberOf(duration.leave)];\n  } else {\n    const n = NumberOf(duration);\n    return [n, n];\n  }\n}\nfunction NumberOf(val) {\n  const res = toNumber(val);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    assertNumber(res, \"<transition> explicit duration\");\n  }\n  return res;\n}\nfunction addTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach((c) => c && el.classList.add(c));\n  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach((c) => c && el.classList.remove(c));\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.delete(cls);\n    if (!_vtc.size) {\n      el[vtcKey] = void 0;\n    }\n  }\n}\nfunction nextFrame(cb) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb);\n  });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n  const id = el._endId = ++endId;\n  const resolveIfNotStale = () => {\n    if (id === el._endId) {\n      resolve();\n    }\n  };\n  if (explicitTimeout != null) {\n    return setTimeout(resolveIfNotStale, explicitTimeout);\n  }\n  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\n  if (!type) {\n    return resolve();\n  }\n  const endEvent = type + \"end\";\n  let ended = 0;\n  const end = () => {\n    el.removeEventListener(endEvent, onEnd);\n    resolveIfNotStale();\n  };\n  const onEnd = (e) => {\n    if (e.target === el && ++ended >= propCount) {\n      end();\n    }\n  };\n  setTimeout(() => {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n  const styles = window.getComputedStyle(el);\n  const getStyleProperties = (key) => (styles[key] || \"\").split(\", \");\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n  const animationTimeout = getTimeout(animationDelays, animationDurations);\n  let type = null;\n  let timeout = 0;\n  let propCount = 0;\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  const hasTransform = type === TRANSITION && /\\b(?:transform|all)(?:,|$)/.test(\n    getStyleProperties(`${TRANSITION}Property`).toString()\n  );\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  };\n}\nfunction getTimeout(delays, durations) {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\nfunction toMs(s) {\n  if (s === \"auto\") return 0;\n  return Number(s.slice(0, -1).replace(\",\", \".\")) * 1e3;\n}\nfunction forceReflow(el) {\n  const targetDocument = el ? el.ownerDocument : document;\n  return targetDocument.body.offsetHeight;\n}\n\nfunction patchClass(el, value, isSVG) {\n  const transitionClasses = el[vtcKey];\n  if (transitionClasses) {\n    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(\" \");\n  }\n  if (value == null) {\n    el.removeAttribute(\"class\");\n  } else if (isSVG) {\n    el.setAttribute(\"class\", value);\n  } else {\n    el.className = value;\n  }\n}\n\nconst vShowOriginalDisplay = Symbol(\"_vod\");\nconst vShowHidden = Symbol(\"_vsh\");\nconst vShow = {\n  // used for prop mismatch check during hydration\n  name: \"show\",\n  beforeMount(el, { value }, { transition }) {\n    el[vShowOriginalDisplay] = el.style.display === \"none\" ? \"\" : el.style.display;\n    if (transition && value) {\n      transition.beforeEnter(el);\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  mounted(el, { value }, { transition }) {\n    if (transition && value) {\n      transition.enter(el);\n    }\n  },\n  updated(el, { value, oldValue }, { transition }) {\n    if (!value === !oldValue) return;\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el);\n        setDisplay(el, true);\n        transition.enter(el);\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false);\n        });\n      }\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  beforeUnmount(el, { value }) {\n    setDisplay(el, value);\n  }\n};\nfunction setDisplay(el, value) {\n  el.style.display = value ? el[vShowOriginalDisplay] : \"none\";\n  el[vShowHidden] = !value;\n}\nfunction initVShowForSSR() {\n  vShow.getSSRProps = ({ value }) => {\n    if (!value) {\n      return { style: { display: \"none\" } };\n    }\n  };\n}\n\nconst CSS_VAR_TEXT = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"CSS_VAR_TEXT\" : \"\");\nfunction useCssVars(getter) {\n  const instance = getCurrentInstance();\n  if (!instance) {\n    !!(process.env.NODE_ENV !== \"production\") && warn(`useCssVars is called without current active component instance.`);\n    return;\n  }\n  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {\n    Array.from(\n      document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`)\n    ).forEach((node) => setVarsOnNode(node, vars));\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    instance.getCssVars = () => getter(instance.proxy);\n  }\n  const setVars = () => {\n    const vars = getter(instance.proxy);\n    if (instance.ce) {\n      setVarsOnNode(instance.ce, vars);\n    } else {\n      setVarsOnVNode(instance.subTree, vars);\n    }\n    updateTeleports(vars);\n  };\n  onBeforeUpdate(() => {\n    queuePostFlushCb(setVars);\n  });\n  onMounted(() => {\n    watch(setVars, NOOP, { flush: \"post\" });\n    const ob = new MutationObserver(setVars);\n    ob.observe(instance.subTree.el.parentNode, { childList: true });\n    onUnmounted(() => ob.disconnect());\n  });\n}\nfunction setVarsOnVNode(vnode, vars) {\n  if (vnode.shapeFlag & 128) {\n    const suspense = vnode.suspense;\n    vnode = suspense.activeBranch;\n    if (suspense.pendingBranch && !suspense.isHydrating) {\n      suspense.effects.push(() => {\n        setVarsOnVNode(suspense.activeBranch, vars);\n      });\n    }\n  }\n  while (vnode.component) {\n    vnode = vnode.component.subTree;\n  }\n  if (vnode.shapeFlag & 1 && vnode.el) {\n    setVarsOnNode(vnode.el, vars);\n  } else if (vnode.type === Fragment) {\n    vnode.children.forEach((c) => setVarsOnVNode(c, vars));\n  } else if (vnode.type === Static) {\n    let { el, anchor } = vnode;\n    while (el) {\n      setVarsOnNode(el, vars);\n      if (el === anchor) break;\n      el = el.nextSibling;\n    }\n  }\n}\nfunction setVarsOnNode(el, vars) {\n  if (el.nodeType === 1) {\n    const style = el.style;\n    let cssText = \"\";\n    for (const key in vars) {\n      const value = normalizeCssVarValue(vars[key]);\n      style.setProperty(`--${key}`, value);\n      cssText += `--${key}: ${value};`;\n    }\n    style[CSS_VAR_TEXT] = cssText;\n  }\n}\n\nconst displayRE = /(?:^|;)\\s*display\\s*:/;\nfunction patchStyle(el, prev, next) {\n  const style = el.style;\n  const isCssString = isString(next);\n  let hasControlledDisplay = false;\n  if (next && !isCssString) {\n    if (prev) {\n      if (!isString(prev)) {\n        for (const key in prev) {\n          if (next[key] == null) {\n            setStyle(style, key, \"\");\n          }\n        }\n      } else {\n        for (const prevStyle of prev.split(\";\")) {\n          const key = prevStyle.slice(0, prevStyle.indexOf(\":\")).trim();\n          if (next[key] == null) {\n            setStyle(style, key, \"\");\n          }\n        }\n      }\n    }\n    for (const key in next) {\n      if (key === \"display\") {\n        hasControlledDisplay = true;\n      }\n      setStyle(style, key, next[key]);\n    }\n  } else {\n    if (isCssString) {\n      if (prev !== next) {\n        const cssVarText = style[CSS_VAR_TEXT];\n        if (cssVarText) {\n          next += \";\" + cssVarText;\n        }\n        style.cssText = next;\n        hasControlledDisplay = displayRE.test(next);\n      }\n    } else if (prev) {\n      el.removeAttribute(\"style\");\n    }\n  }\n  if (vShowOriginalDisplay in el) {\n    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : \"\";\n    if (el[vShowHidden]) {\n      style.display = \"none\";\n    }\n  }\n}\nconst semicolonRE = /[^\\\\];\\s*$/;\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n  if (isArray(val)) {\n    val.forEach((v) => setStyle(style, name, v));\n  } else {\n    if (val == null) val = \"\";\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      if (semicolonRE.test(val)) {\n        warn(\n          `Unexpected semicolon at the end of '${name}' style value: '${val}'`\n        );\n      }\n    }\n    if (name.startsWith(\"--\")) {\n      style.setProperty(name, val);\n    } else {\n      const prefixed = autoPrefix(style, name);\n      if (importantRE.test(val)) {\n        style.setProperty(\n          hyphenate(prefixed),\n          val.replace(importantRE, \"\"),\n          \"important\"\n        );\n      } else {\n        style[prefixed] = val;\n      }\n    }\n  }\n}\nconst prefixes = [\"Webkit\", \"Moz\", \"ms\"];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n  const cached = prefixCache[rawName];\n  if (cached) {\n    return cached;\n  }\n  let name = camelize(rawName);\n  if (name !== \"filter\" && name in style) {\n    return prefixCache[rawName] = name;\n  }\n  name = capitalize(name);\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefixed = prefixes[i] + name;\n    if (prefixed in style) {\n      return prefixCache[rawName] = prefixed;\n    }\n  }\n  return rawName;\n}\n\nconst xlinkNS = \"http://www.w3.org/1999/xlink\";\nfunction patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {\n  if (isSVG && key.startsWith(\"xlink:\")) {\n    if (value == null) {\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (value == null || isBoolean && !includeBooleanAttr(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(\n        key,\n        isBoolean ? \"\" : isSymbol(value) ? String(value) : value\n      );\n    }\n  }\n}\n\nfunction patchDOMProp(el, key, value, parentComponent, attrName) {\n  if (key === \"innerHTML\" || key === \"textContent\") {\n    if (value != null) {\n      el[key] = key === \"innerHTML\" ? unsafeToTrustedHTML(value) : value;\n    }\n    return;\n  }\n  const tag = el.tagName;\n  if (key === \"value\" && tag !== \"PROGRESS\" && // custom elements may use _value internally\n  !tag.includes(\"-\")) {\n    const oldValue = tag === \"OPTION\" ? el.getAttribute(\"value\") || \"\" : el.value;\n    const newValue = value == null ? (\n      // #11647: value should be set as empty string for null and undefined,\n      // but <input type=\"checkbox\"> should be set as 'on'.\n      el.type === \"checkbox\" ? \"on\" : \"\"\n    ) : String(value);\n    if (oldValue !== newValue || !(\"_value\" in el)) {\n      el.value = newValue;\n    }\n    if (value == null) {\n      el.removeAttribute(key);\n    }\n    el._value = value;\n    return;\n  }\n  let needRemove = false;\n  if (value === \"\" || value == null) {\n    const type = typeof el[key];\n    if (type === \"boolean\") {\n      value = includeBooleanAttr(value);\n    } else if (value == null && type === \"string\") {\n      value = \"\";\n      needRemove = true;\n    } else if (type === \"number\") {\n      value = 0;\n      needRemove = true;\n    }\n  }\n  try {\n    el[key] = value;\n  } catch (e) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !needRemove) {\n      warn(\n        `Failed setting prop \"${key}\" on <${tag.toLowerCase()}>: value ${value} is invalid.`,\n        e\n      );\n    }\n  }\n  needRemove && el.removeAttribute(attrName || key);\n}\n\nfunction addEventListener(el, event, handler, options) {\n  el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n  el.removeEventListener(event, handler, options);\n}\nconst veiKey = Symbol(\"_vei\");\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n  const invokers = el[veiKey] || (el[veiKey] = {});\n  const existingInvoker = invokers[rawName];\n  if (nextValue && existingInvoker) {\n    existingInvoker.value = !!(process.env.NODE_ENV !== \"production\") ? sanitizeEventValue(nextValue, rawName) : nextValue;\n  } else {\n    const [name, options] = parseName(rawName);\n    if (nextValue) {\n      const invoker = invokers[rawName] = createInvoker(\n        !!(process.env.NODE_ENV !== \"production\") ? sanitizeEventValue(nextValue, rawName) : nextValue,\n        instance\n      );\n      addEventListener(el, name, invoker, options);\n    } else if (existingInvoker) {\n      removeEventListener(el, name, existingInvoker, options);\n      invokers[rawName] = void 0;\n    }\n  }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n  let options;\n  if (optionsModifierRE.test(name)) {\n    options = {};\n    let m;\n    while (m = name.match(optionsModifierRE)) {\n      name = name.slice(0, name.length - m[0].length);\n      options[m[0].toLowerCase()] = true;\n    }\n  }\n  const event = name[2] === \":\" ? name.slice(3) : hyphenate(name.slice(2));\n  return [event, options];\n}\nlet cachedNow = 0;\nconst p = /* @__PURE__ */ Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());\nfunction createInvoker(initialValue, instance) {\n  const invoker = (e) => {\n    if (!e._vts) {\n      e._vts = Date.now();\n    } else if (e._vts <= invoker.attached) {\n      return;\n    }\n    callWithAsyncErrorHandling(\n      patchStopImmediatePropagation(e, invoker.value),\n      instance,\n      5,\n      [e]\n    );\n  };\n  invoker.value = initialValue;\n  invoker.attached = getNow();\n  return invoker;\n}\nfunction sanitizeEventValue(value, propName) {\n  if (isFunction(value) || isArray(value)) {\n    return value;\n  }\n  warn(\n    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?\nExpected function or array of functions, received type ${typeof value}.`\n  );\n  return NOOP;\n}\nfunction patchStopImmediatePropagation(e, value) {\n  if (isArray(value)) {\n    const originalStop = e.stopImmediatePropagation;\n    e.stopImmediatePropagation = () => {\n      originalStop.call(e);\n      e._stopped = true;\n    };\n    return value.map(\n      (fn) => (e2) => !e2._stopped && fn && fn(e2)\n    );\n  } else {\n    return value;\n  }\n}\n\nconst isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter\nkey.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;\nconst patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {\n  const isSVG = namespace === \"svg\";\n  if (key === \"class\") {\n    patchClass(el, nextValue, isSVG);\n  } else if (key === \"style\") {\n    patchStyle(el, prevValue, nextValue);\n  } else if (isOn(key)) {\n    if (!isModelListener(key)) {\n      patchEvent(el, key, prevValue, nextValue, parentComponent);\n    }\n  } else if (key[0] === \".\" ? (key = key.slice(1), true) : key[0] === \"^\" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {\n    patchDOMProp(el, key, nextValue);\n    if (!el.tagName.includes(\"-\") && (key === \"value\" || key === \"checked\" || key === \"selected\")) {\n      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== \"value\");\n    }\n  } else if (\n    // #11081 force set props for possible async custom element\n    el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))\n  ) {\n    patchDOMProp(el, camelize$1(key), nextValue, parentComponent, key);\n  } else {\n    if (key === \"true-value\") {\n      el._trueValue = nextValue;\n    } else if (key === \"false-value\") {\n      el._falseValue = nextValue;\n    }\n    patchAttr(el, key, nextValue, isSVG);\n  }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n  if (isSVG) {\n    if (key === \"innerHTML\" || key === \"textContent\") {\n      return true;\n    }\n    if (key in el && isNativeOn(key) && isFunction(value)) {\n      return true;\n    }\n    return false;\n  }\n  if (key === \"spellcheck\" || key === \"draggable\" || key === \"translate\" || key === \"autocorrect\") {\n    return false;\n  }\n  if (key === \"sandbox\" && el.tagName === \"IFRAME\") {\n    return false;\n  }\n  if (key === \"form\") {\n    return false;\n  }\n  if (key === \"list\" && el.tagName === \"INPUT\") {\n    return false;\n  }\n  if (key === \"type\" && el.tagName === \"TEXTAREA\") {\n    return false;\n  }\n  if (key === \"width\" || key === \"height\") {\n    const tag = el.tagName;\n    if (tag === \"IMG\" || tag === \"VIDEO\" || tag === \"CANVAS\" || tag === \"SOURCE\") {\n      return false;\n    }\n  }\n  if (isNativeOn(key) && isString(value)) {\n    return false;\n  }\n  return key in el;\n}\n\nconst REMOVAL = {};\n// @__NO_SIDE_EFFECTS__\nfunction defineCustomElement(options, extraOptions, _createApp) {\n  let Comp = defineComponent(options, extraOptions);\n  if (isPlainObject(Comp)) Comp = extend({}, Comp, extraOptions);\n  class VueCustomElement extends VueElement {\n    constructor(initialProps) {\n      super(Comp, initialProps, _createApp);\n    }\n  }\n  VueCustomElement.def = Comp;\n  return VueCustomElement;\n}\nconst defineSSRCustomElement = (/* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {\n  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);\n});\nconst BaseClass = typeof HTMLElement !== \"undefined\" ? HTMLElement : class {\n};\nclass VueElement extends BaseClass {\n  constructor(_def, _props = {}, _createApp = createApp) {\n    super();\n    this._def = _def;\n    this._props = _props;\n    this._createApp = _createApp;\n    this._isVueCE = true;\n    /**\n     * @internal\n     */\n    this._instance = null;\n    /**\n     * @internal\n     */\n    this._app = null;\n    /**\n     * @internal\n     */\n    this._nonce = this._def.nonce;\n    this._connected = false;\n    this._resolved = false;\n    this._patching = false;\n    this._dirty = false;\n    this._numberProps = null;\n    this._styleChildren = /* @__PURE__ */ new WeakSet();\n    this._ob = null;\n    if (this.shadowRoot && _createApp !== createApp) {\n      this._root = this.shadowRoot;\n    } else {\n      if (!!(process.env.NODE_ENV !== \"production\") && this.shadowRoot) {\n        warn(\n          `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \\`defineSSRCustomElement\\`.`\n        );\n      }\n      if (_def.shadowRoot !== false) {\n        this.attachShadow(\n          extend({}, _def.shadowRootOptions, {\n            mode: \"open\"\n          })\n        );\n        this._root = this.shadowRoot;\n      } else {\n        this._root = this;\n      }\n    }\n  }\n  connectedCallback() {\n    if (!this.isConnected) return;\n    if (!this.shadowRoot && !this._resolved) {\n      this._parseSlots();\n    }\n    this._connected = true;\n    let parent = this;\n    while (parent = parent && (parent.parentNode || parent.host)) {\n      if (parent instanceof VueElement) {\n        this._parent = parent;\n        break;\n      }\n    }\n    if (!this._instance) {\n      if (this._resolved) {\n        this._mount(this._def);\n      } else {\n        if (parent && parent._pendingResolve) {\n          this._pendingResolve = parent._pendingResolve.then(() => {\n            this._pendingResolve = void 0;\n            this._resolveDef();\n          });\n        } else {\n          this._resolveDef();\n        }\n      }\n    }\n  }\n  _setParent(parent = this._parent) {\n    if (parent) {\n      this._instance.parent = parent._instance;\n      this._inheritParentContext(parent);\n    }\n  }\n  _inheritParentContext(parent = this._parent) {\n    if (parent && this._app) {\n      Object.setPrototypeOf(\n        this._app._context.provides,\n        parent._instance.provides\n      );\n    }\n  }\n  disconnectedCallback() {\n    this._connected = false;\n    nextTick(() => {\n      if (!this._connected) {\n        if (this._ob) {\n          this._ob.disconnect();\n          this._ob = null;\n        }\n        this._app && this._app.unmount();\n        if (this._instance) this._instance.ce = void 0;\n        this._app = this._instance = null;\n        if (this._teleportTargets) {\n          this._teleportTargets.clear();\n          this._teleportTargets = void 0;\n        }\n      }\n    });\n  }\n  _processMutations(mutations) {\n    for (const m of mutations) {\n      this._setAttr(m.attributeName);\n    }\n  }\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  _resolveDef() {\n    if (this._pendingResolve) {\n      return;\n    }\n    for (let i = 0; i < this.attributes.length; i++) {\n      this._setAttr(this.attributes[i].name);\n    }\n    this._ob = new MutationObserver(this._processMutations.bind(this));\n    this._ob.observe(this, { attributes: true });\n    const resolve = (def, isAsync = false) => {\n      this._resolved = true;\n      this._pendingResolve = void 0;\n      const { props, styles } = def;\n      let numberProps;\n      if (props && !isArray(props)) {\n        for (const key in props) {\n          const opt = props[key];\n          if (opt === Number || opt && opt.type === Number) {\n            if (key in this._props) {\n              this._props[key] = toNumber(this._props[key]);\n            }\n            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize$1(key)] = true;\n          }\n        }\n      }\n      this._numberProps = numberProps;\n      this._resolveProps(def);\n      if (this.shadowRoot) {\n        this._applyStyles(styles);\n      } else if (!!(process.env.NODE_ENV !== \"production\") && styles) {\n        warn(\n          \"Custom element style injection is not supported when using shadowRoot: false\"\n        );\n      }\n      this._mount(def);\n    };\n    const asyncDef = this._def.__asyncLoader;\n    if (asyncDef) {\n      this._pendingResolve = asyncDef().then((def) => {\n        def.configureApp = this._def.configureApp;\n        resolve(this._def = def, true);\n      });\n    } else {\n      resolve(this._def);\n    }\n  }\n  _mount(def) {\n    if ((!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) && !def.name) {\n      def.name = \"VueElement\";\n    }\n    this._app = this._createApp(def);\n    this._inheritParentContext();\n    if (def.configureApp) {\n      def.configureApp(this._app);\n    }\n    this._app._ceVNode = this._createVNode();\n    this._app.mount(this._root);\n    const exposed = this._instance && this._instance.exposed;\n    if (!exposed) return;\n    for (const key in exposed) {\n      if (!hasOwn(this, key)) {\n        Object.defineProperty(this, key, {\n          // unwrap ref to be consistent with public instance behavior\n          get: () => unref(exposed[key])\n        });\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        warn(`Exposed property \"${key}\" already exists on custom element.`);\n      }\n    }\n  }\n  _resolveProps(def) {\n    const { props } = def;\n    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});\n    for (const key of Object.keys(this)) {\n      if (key[0] !== \"_\" && declaredPropKeys.includes(key)) {\n        this._setProp(key, this[key]);\n      }\n    }\n    for (const key of declaredPropKeys.map(camelize$1)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return this._getProp(key);\n        },\n        set(val) {\n          this._setProp(key, val, true, !this._patching);\n        }\n      });\n    }\n  }\n  _setAttr(key) {\n    if (key.startsWith(\"data-v-\")) return;\n    const has = this.hasAttribute(key);\n    let value = has ? this.getAttribute(key) : REMOVAL;\n    const camelKey = camelize$1(key);\n    if (has && this._numberProps && this._numberProps[camelKey]) {\n      value = toNumber(value);\n    }\n    this._setProp(camelKey, value, false, true);\n  }\n  /**\n   * @internal\n   */\n  _getProp(key) {\n    return this._props[key];\n  }\n  /**\n   * @internal\n   */\n  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {\n    if (val !== this._props[key]) {\n      this._dirty = true;\n      if (val === REMOVAL) {\n        delete this._props[key];\n      } else {\n        this._props[key] = val;\n        if (key === \"key\" && this._app) {\n          this._app._ceVNode.key = val;\n        }\n      }\n      if (shouldUpdate && this._instance) {\n        this._update();\n      }\n      if (shouldReflect) {\n        const ob = this._ob;\n        if (ob) {\n          this._processMutations(ob.takeRecords());\n          ob.disconnect();\n        }\n        if (val === true) {\n          this.setAttribute(hyphenate(key), \"\");\n        } else if (typeof val === \"string\" || typeof val === \"number\") {\n          this.setAttribute(hyphenate(key), val + \"\");\n        } else if (!val) {\n          this.removeAttribute(hyphenate(key));\n        }\n        ob && ob.observe(this, { attributes: true });\n      }\n    }\n  }\n  _update() {\n    const vnode = this._createVNode();\n    if (this._app) vnode.appContext = this._app._context;\n    render(vnode, this._root);\n  }\n  _createVNode() {\n    const baseProps = {};\n    if (!this.shadowRoot) {\n      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);\n    }\n    const vnode = createVNode(this._def, extend(baseProps, this._props));\n    if (!this._instance) {\n      vnode.ce = (instance) => {\n        this._instance = instance;\n        instance.ce = this;\n        instance.isCE = true;\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          instance.ceReload = (newStyles) => {\n            if (this._styles) {\n              this._styles.forEach((s) => this._root.removeChild(s));\n              this._styles.length = 0;\n            }\n            this._applyStyles(newStyles);\n            this._instance = null;\n            this._update();\n          };\n        }\n        const dispatch = (event, args) => {\n          this.dispatchEvent(\n            new CustomEvent(\n              event,\n              isPlainObject(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }\n            )\n          );\n        };\n        instance.emit = (event, ...args) => {\n          dispatch(event, args);\n          if (hyphenate(event) !== event) {\n            dispatch(hyphenate(event), args);\n          }\n        };\n        this._setParent();\n      };\n    }\n    return vnode;\n  }\n  _applyStyles(styles, owner) {\n    if (!styles) return;\n    if (owner) {\n      if (owner === this._def || this._styleChildren.has(owner)) {\n        return;\n      }\n      this._styleChildren.add(owner);\n    }\n    const nonce = this._nonce;\n    for (let i = styles.length - 1; i >= 0; i--) {\n      const s = document.createElement(\"style\");\n      if (nonce) s.setAttribute(\"nonce\", nonce);\n      s.textContent = styles[i];\n      this.shadowRoot.prepend(s);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        if (owner) {\n          if (owner.__hmrId) {\n            if (!this._childStyles) this._childStyles = /* @__PURE__ */ new Map();\n            let entry = this._childStyles.get(owner.__hmrId);\n            if (!entry) {\n              this._childStyles.set(owner.__hmrId, entry = []);\n            }\n            entry.push(s);\n          }\n        } else {\n          (this._styles || (this._styles = [])).push(s);\n        }\n      }\n    }\n  }\n  /**\n   * Only called when shadowRoot is false\n   */\n  _parseSlots() {\n    const slots = this._slots = {};\n    let n;\n    while (n = this.firstChild) {\n      const slotName = n.nodeType === 1 && n.getAttribute(\"slot\") || \"default\";\n      (slots[slotName] || (slots[slotName] = [])).push(n);\n      this.removeChild(n);\n    }\n  }\n  /**\n   * Only called when shadowRoot is false\n   */\n  _renderSlots() {\n    const outlets = this._getSlots();\n    const scopeId = this._instance.type.__scopeId;\n    for (let i = 0; i < outlets.length; i++) {\n      const o = outlets[i];\n      const slotName = o.getAttribute(\"name\") || \"default\";\n      const content = this._slots[slotName];\n      const parent = o.parentNode;\n      if (content) {\n        for (const n of content) {\n          if (scopeId && n.nodeType === 1) {\n            const id = scopeId + \"-s\";\n            const walker = document.createTreeWalker(n, 1);\n            n.setAttribute(id, \"\");\n            let child;\n            while (child = walker.nextNode()) {\n              child.setAttribute(id, \"\");\n            }\n          }\n          parent.insertBefore(n, o);\n        }\n      } else {\n        while (o.firstChild) parent.insertBefore(o.firstChild, o);\n      }\n      parent.removeChild(o);\n    }\n  }\n  /**\n   * @internal\n   */\n  _getSlots() {\n    const roots = [this];\n    if (this._teleportTargets) {\n      roots.push(...this._teleportTargets);\n    }\n    const slots = /* @__PURE__ */ new Set();\n    for (const root of roots) {\n      const found = root.querySelectorAll(\"slot\");\n      for (let i = 0; i < found.length; i++) {\n        slots.add(found[i]);\n      }\n    }\n    return Array.from(slots);\n  }\n  /**\n   * @internal\n   */\n  _injectChildStyle(comp) {\n    this._applyStyles(comp.styles, comp);\n  }\n  /**\n   * @internal\n   */\n  _beginPatch() {\n    this._patching = true;\n    this._dirty = false;\n  }\n  /**\n   * @internal\n   */\n  _endPatch() {\n    this._patching = false;\n    if (this._dirty && this._instance) {\n      this._update();\n    }\n  }\n  /**\n   * @internal\n   */\n  _removeChildStyle(comp) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this._styleChildren.delete(comp);\n      if (this._childStyles && comp.__hmrId) {\n        const oldStyles = this._childStyles.get(comp.__hmrId);\n        if (oldStyles) {\n          oldStyles.forEach((s) => this._root.removeChild(s));\n          oldStyles.length = 0;\n        }\n      }\n    }\n  }\n}\nfunction useHost(caller) {\n  const instance = getCurrentInstance();\n  const el = instance && instance.ce;\n  if (el) {\n    return el;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    if (!instance) {\n      warn(\n        `${caller || \"useHost\"} called without an active component instance.`\n      );\n    } else {\n      warn(\n        `${caller || \"useHost\"} can only be used in components defined via defineCustomElement.`\n      );\n    }\n  }\n  return null;\n}\nfunction useShadowRoot() {\n  const el = !!(process.env.NODE_ENV !== \"production\") ? useHost(\"useShadowRoot\") : useHost();\n  return el && el.shadowRoot;\n}\n\nfunction useCssModule(name = \"$style\") {\n  {\n    const instance = getCurrentInstance();\n    if (!instance) {\n      !!(process.env.NODE_ENV !== \"production\") && warn(`useCssModule must be called inside setup()`);\n      return EMPTY_OBJ;\n    }\n    const modules = instance.type.__cssModules;\n    if (!modules) {\n      !!(process.env.NODE_ENV !== \"production\") && warn(`Current instance does not have CSS modules injected.`);\n      return EMPTY_OBJ;\n    }\n    const mod = modules[name];\n    if (!mod) {\n      !!(process.env.NODE_ENV !== \"production\") && warn(`Current instance does not have CSS module named \"${name}\".`);\n      return EMPTY_OBJ;\n    }\n    return mod;\n  }\n}\n\nconst positionMap = /* @__PURE__ */ new WeakMap();\nconst newPositionMap = /* @__PURE__ */ new WeakMap();\nconst moveCbKey = Symbol(\"_moveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nconst decorate = (t) => {\n  delete t.props.mode;\n  return t;\n};\nconst TransitionGroupImpl = /* @__PURE__ */ decorate({\n  name: \"TransitionGroup\",\n  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {\n    tag: String,\n    moveClass: String\n  }),\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    let prevChildren;\n    let children;\n    onUpdated(() => {\n      if (!prevChildren.length) {\n        return;\n      }\n      const moveClass = props.moveClass || `${props.name || \"v\"}-move`;\n      if (!hasCSSTransform(\n        prevChildren[0].el,\n        instance.vnode.el,\n        moveClass\n      )) {\n        prevChildren = [];\n        return;\n      }\n      prevChildren.forEach(callPendingCbs);\n      prevChildren.forEach(recordPosition);\n      const movedChildren = prevChildren.filter(applyTranslation);\n      forceReflow(instance.vnode.el);\n      movedChildren.forEach((c) => {\n        const el = c.el;\n        const style = el.style;\n        addTransitionClass(el, moveClass);\n        style.transform = style.webkitTransform = style.transitionDuration = \"\";\n        const cb = el[moveCbKey] = (e) => {\n          if (e && e.target !== el) {\n            return;\n          }\n          if (!e || e.propertyName.endsWith(\"transform\")) {\n            el.removeEventListener(\"transitionend\", cb);\n            el[moveCbKey] = null;\n            removeTransitionClass(el, moveClass);\n          }\n        };\n        el.addEventListener(\"transitionend\", cb);\n      });\n      prevChildren = [];\n    });\n    return () => {\n      const rawProps = toRaw(props);\n      const cssTransitionProps = resolveTransitionProps(rawProps);\n      let tag = rawProps.tag || Fragment;\n      prevChildren = [];\n      if (children) {\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          if (child.el && child.el instanceof Element) {\n            prevChildren.push(child);\n            setTransitionHooks(\n              child,\n              resolveTransitionHooks(\n                child,\n                cssTransitionProps,\n                state,\n                instance\n              )\n            );\n            positionMap.set(child, {\n              left: child.el.offsetLeft,\n              top: child.el.offsetTop\n            });\n          }\n        }\n      }\n      children = slots.default ? getTransitionRawChildren(slots.default()) : [];\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.key != null) {\n          setTransitionHooks(\n            child,\n            resolveTransitionHooks(child, cssTransitionProps, state, instance)\n          );\n        } else if (!!(process.env.NODE_ENV !== \"production\") && child.type !== Text) {\n          warn(`<TransitionGroup> children must be keyed.`);\n        }\n      }\n      return createVNode(tag, null, children);\n    };\n  }\n});\nconst TransitionGroup = TransitionGroupImpl;\nfunction callPendingCbs(c) {\n  const el = c.el;\n  if (el[moveCbKey]) {\n    el[moveCbKey]();\n  }\n  if (el[enterCbKey]) {\n    el[enterCbKey]();\n  }\n}\nfunction recordPosition(c) {\n  newPositionMap.set(c, {\n    left: c.el.offsetLeft,\n    top: c.el.offsetTop\n  });\n}\nfunction applyTranslation(c) {\n  const oldPos = positionMap.get(c);\n  const newPos = newPositionMap.get(c);\n  const dx = oldPos.left - newPos.left;\n  const dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    const s = c.el.style;\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n    s.transitionDuration = \"0s\";\n    return c;\n  }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n  const clone = el.cloneNode();\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.forEach((cls) => {\n      cls.split(/\\s+/).forEach((c) => c && clone.classList.remove(c));\n    });\n  }\n  moveClass.split(/\\s+/).forEach((c) => c && clone.classList.add(c));\n  clone.style.display = \"none\";\n  const container = root.nodeType === 1 ? root : root.parentNode;\n  container.appendChild(clone);\n  const { hasTransform } = getTransitionInfo(clone);\n  container.removeChild(clone);\n  return hasTransform;\n}\n\nconst getModelAssigner = (vnode) => {\n  const fn = vnode.props[\"onUpdate:modelValue\"] || false;\n  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n  const target = e.target;\n  if (target.composing) {\n    target.composing = false;\n    target.dispatchEvent(new Event(\"input\"));\n  }\n}\nconst assignKey = Symbol(\"_assign\");\nfunction castValue(value, trim, number) {\n  if (trim) value = value.trim();\n  if (number) value = looseToNumber(value);\n  return value;\n}\nconst vModelText = {\n  created(el, { modifiers: { lazy, trim, number } }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    const castToNumber = number || vnode.props && vnode.props.type === \"number\";\n    addEventListener(el, lazy ? \"change\" : \"input\", (e) => {\n      if (e.target.composing) return;\n      el[assignKey](castValue(el.value, trim, castToNumber));\n    });\n    if (trim || castToNumber) {\n      addEventListener(el, \"change\", () => {\n        el.value = castValue(el.value, trim, castToNumber);\n      });\n    }\n    if (!lazy) {\n      addEventListener(el, \"compositionstart\", onCompositionStart);\n      addEventListener(el, \"compositionend\", onCompositionEnd);\n      addEventListener(el, \"change\", onCompositionEnd);\n    }\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(el, { value }) {\n    el.value = value == null ? \"\" : value;\n  },\n  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (el.composing) return;\n    const elValue = (number || el.type === \"number\") && !/^0\\d/.test(el.value) ? looseToNumber(el.value) : el.value;\n    const newValue = value == null ? \"\" : value;\n    if (elValue === newValue) {\n      return;\n    }\n    if (document.activeElement === el && el.type !== \"range\") {\n      if (lazy && value === oldValue) {\n        return;\n      }\n      if (trim && el.value.trim() === newValue) {\n        return;\n      }\n    }\n    el.value = newValue;\n  }\n};\nconst vModelCheckbox = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      const modelValue = el._modelValue;\n      const elementValue = getValue(el);\n      const checked = el.checked;\n      const assign = el[assignKey];\n      if (isArray(modelValue)) {\n        const index = looseIndexOf(modelValue, elementValue);\n        const found = index !== -1;\n        if (checked && !found) {\n          assign(modelValue.concat(elementValue));\n        } else if (!checked && found) {\n          const filtered = [...modelValue];\n          filtered.splice(index, 1);\n          assign(filtered);\n        }\n      } else if (isSet(modelValue)) {\n        const cloned = new Set(modelValue);\n        if (checked) {\n          cloned.add(elementValue);\n        } else {\n          cloned.delete(elementValue);\n        }\n        assign(cloned);\n      } else {\n        assign(getCheckboxValue(el, checked));\n      }\n    });\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    setChecked(el, binding, vnode);\n  }\n};\nfunction setChecked(el, { value, oldValue }, vnode) {\n  el._modelValue = value;\n  let checked;\n  if (isArray(value)) {\n    checked = looseIndexOf(value, vnode.props.value) > -1;\n  } else if (isSet(value)) {\n    checked = value.has(vnode.props.value);\n  } else {\n    if (value === oldValue) return;\n    checked = looseEqual(value, getCheckboxValue(el, true));\n  }\n  if (el.checked !== checked) {\n    el.checked = checked;\n  }\n}\nconst vModelRadio = {\n  created(el, { value }, vnode) {\n    el.checked = looseEqual(value, vnode.props.value);\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      el[assignKey](getValue(el));\n    });\n  },\n  beforeUpdate(el, { value, oldValue }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (value !== oldValue) {\n      el.checked = looseEqual(value, vnode.props.value);\n    }\n  }\n};\nconst vModelSelect = {\n  // <select multiple> value need to be deep traversed\n  deep: true,\n  created(el, { value, modifiers: { number } }, vnode) {\n    const isSetModel = isSet(value);\n    addEventListener(el, \"change\", () => {\n      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(\n        (o) => number ? looseToNumber(getValue(o)) : getValue(o)\n      );\n      el[assignKey](\n        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]\n      );\n      el._assigning = true;\n      nextTick(() => {\n        el._assigning = false;\n      });\n    });\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(el, { value }) {\n    setSelected(el, value);\n  },\n  beforeUpdate(el, _binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  updated(el, { value }) {\n    if (!el._assigning) {\n      setSelected(el, value);\n    }\n  }\n};\nfunction setSelected(el, value) {\n  const isMultiple = el.multiple;\n  const isArrayValue = isArray(value);\n  if (isMultiple && !isArrayValue && !isSet(value)) {\n    !!(process.env.NODE_ENV !== \"production\") && warn(\n      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`\n    );\n    return;\n  }\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    const option = el.options[i];\n    const optionValue = getValue(option);\n    if (isMultiple) {\n      if (isArrayValue) {\n        const optionType = typeof optionValue;\n        if (optionType === \"string\" || optionType === \"number\") {\n          option.selected = value.some((v) => String(v) === String(optionValue));\n        } else {\n          option.selected = looseIndexOf(value, optionValue) > -1;\n        }\n      } else {\n        option.selected = value.has(optionValue);\n      }\n    } else if (looseEqual(getValue(option), value)) {\n      if (el.selectedIndex !== i) el.selectedIndex = i;\n      return;\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1;\n  }\n}\nfunction getValue(el) {\n  return \"_value\" in el ? el._value : el.value;\n}\nfunction getCheckboxValue(el, checked) {\n  const key = checked ? \"_trueValue\" : \"_falseValue\";\n  return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"created\");\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"mounted\");\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"beforeUpdate\");\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"updated\");\n  }\n};\nfunction resolveDynamicModel(tagName, type) {\n  switch (tagName) {\n    case \"SELECT\":\n      return vModelSelect;\n    case \"TEXTAREA\":\n      return vModelText;\n    default:\n      switch (type) {\n        case \"checkbox\":\n          return vModelCheckbox;\n        case \"radio\":\n          return vModelRadio;\n        default:\n          return vModelText;\n      }\n  }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n  const modelToUse = resolveDynamicModel(\n    el.tagName,\n    vnode.props && vnode.props.type\n  );\n  const fn = modelToUse[hook];\n  fn && fn(el, binding, vnode, prevVNode);\n}\nfunction initVModelForSSR() {\n  vModelText.getSSRProps = ({ value }) => ({ value });\n  vModelRadio.getSSRProps = ({ value }, vnode) => {\n    if (vnode.props && looseEqual(vnode.props.value, value)) {\n      return { checked: true };\n    }\n  };\n  vModelCheckbox.getSSRProps = ({ value }, vnode) => {\n    if (isArray(value)) {\n      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {\n        return { checked: true };\n      }\n    } else if (isSet(value)) {\n      if (vnode.props && value.has(vnode.props.value)) {\n        return { checked: true };\n      }\n    } else if (value) {\n      return { checked: true };\n    }\n  };\n  vModelDynamic.getSSRProps = (binding, vnode) => {\n    if (typeof vnode.type !== \"string\") {\n      return;\n    }\n    const modelToUse = resolveDynamicModel(\n      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n      vnode.type.toUpperCase(),\n      vnode.props && vnode.props.type\n    );\n    if (modelToUse.getSSRProps) {\n      return modelToUse.getSSRProps(binding, vnode);\n    }\n  };\n}\n\nconst systemModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\"];\nconst modifierGuards = {\n  stop: (e) => e.stopPropagation(),\n  prevent: (e) => e.preventDefault(),\n  self: (e) => e.target !== e.currentTarget,\n  ctrl: (e) => !e.ctrlKey,\n  shift: (e) => !e.shiftKey,\n  alt: (e) => !e.altKey,\n  meta: (e) => !e.metaKey,\n  left: (e) => \"button\" in e && e.button !== 0,\n  middle: (e) => \"button\" in e && e.button !== 1,\n  right: (e) => \"button\" in e && e.button !== 2,\n  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))\n};\nconst withModifiers = (fn, modifiers) => {\n  const cache = fn._withMods || (fn._withMods = {});\n  const cacheKey = modifiers.join(\".\");\n  return cache[cacheKey] || (cache[cacheKey] = ((event, ...args) => {\n    for (let i = 0; i < modifiers.length; i++) {\n      const guard = modifierGuards[modifiers[i]];\n      if (guard && guard(event, modifiers)) return;\n    }\n    return fn(event, ...args);\n  }));\n};\nconst keyNames = {\n  esc: \"escape\",\n  space: \" \",\n  up: \"arrow-up\",\n  left: \"arrow-left\",\n  right: \"arrow-right\",\n  down: \"arrow-down\",\n  delete: \"backspace\"\n};\nconst withKeys = (fn, modifiers) => {\n  const cache = fn._withKeys || (fn._withKeys = {});\n  const cacheKey = modifiers.join(\".\");\n  return cache[cacheKey] || (cache[cacheKey] = ((event) => {\n    if (!(\"key\" in event)) {\n      return;\n    }\n    const eventKey = hyphenate(event.key);\n    if (modifiers.some(\n      (k) => k === eventKey || keyNames[k] === eventKey\n    )) {\n      return fn(event);\n    }\n  }));\n};\n\nconst rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n  return renderer || (renderer = createRenderer(rendererOptions));\n}\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);\n  enabledHydration = true;\n  return renderer;\n}\nconst render = ((...args) => {\n  ensureRenderer().render(...args);\n});\nconst hydrate = ((...args) => {\n  ensureHydrationRenderer().hydrate(...args);\n});\nconst createApp = ((...args) => {\n  const app = ensureRenderer().createApp(...args);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const { mount } = app;\n  app.mount = (containerOrSelector) => {\n    const container = normalizeContainer(containerOrSelector);\n    if (!container) return;\n    const component = app._component;\n    if (!isFunction(component) && !component.render && !component.template) {\n      component.template = container.innerHTML;\n    }\n    if (container.nodeType === 1) {\n      container.textContent = \"\";\n    }\n    const proxy = mount(container, false, resolveRootNamespace(container));\n    if (container instanceof Element) {\n      container.removeAttribute(\"v-cloak\");\n      container.setAttribute(\"data-v-app\", \"\");\n    }\n    return proxy;\n  };\n  return app;\n});\nconst createSSRApp = ((...args) => {\n  const app = ensureHydrationRenderer().createApp(...args);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const { mount } = app;\n  app.mount = (containerOrSelector) => {\n    const container = normalizeContainer(containerOrSelector);\n    if (container) {\n      return mount(container, true, resolveRootNamespace(container));\n    }\n  };\n  return app;\n});\nfunction resolveRootNamespace(container) {\n  if (container instanceof SVGElement) {\n    return \"svg\";\n  }\n  if (typeof MathMLElement === \"function\" && container instanceof MathMLElement) {\n    return \"mathml\";\n  }\n}\nfunction injectNativeTagCheck(app) {\n  Object.defineProperty(app.config, \"isNativeTag\", {\n    value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),\n    writable: false\n  });\n}\nfunction injectCompilerOptionsCheck(app) {\n  if (isRuntimeOnly()) {\n    const isCustomElement = app.config.isCustomElement;\n    Object.defineProperty(app.config, \"isCustomElement\", {\n      get() {\n        return isCustomElement;\n      },\n      set() {\n        warn(\n          `The \\`isCustomElement\\` config option is deprecated. Use \\`compilerOptions.isCustomElement\\` instead.`\n        );\n      }\n    });\n    const compilerOptions = app.config.compilerOptions;\n    const msg = `The \\`compilerOptions\\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka \"full build\"). Since you are using the runtime-only build, \\`compilerOptions\\` must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\n- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;\n    Object.defineProperty(app.config, \"compilerOptions\", {\n      get() {\n        warn(msg);\n        return compilerOptions;\n      },\n      set() {\n        warn(msg);\n      }\n    });\n  }\n}\nfunction normalizeContainer(container) {\n  if (isString(container)) {\n    const res = document.querySelector(container);\n    if (!!(process.env.NODE_ENV !== \"production\") && !res) {\n      warn(\n        `Failed to mount app: mount target selector \"${container}\" returned null.`\n      );\n    }\n    return res;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === \"closed\") {\n    warn(\n      `mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`\n    );\n  }\n  return container;\n}\nlet ssrDirectiveInitialized = false;\nconst initDirectivesForSSR = () => {\n  if (!ssrDirectiveInitialized) {\n    ssrDirectiveInitialized = true;\n    initVModelForSSR();\n    initVShowForSSR();\n  }\n} ;\n\nexport { Transition, TransitionGroup, VueElement, createApp, createSSRApp, defineCustomElement, defineSSRCustomElement, hydrate, initDirectivesForSSR, render, useCssModule, useCssVars, useHost, useShadowRoot, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, withKeys, withModifiers };\n","/* eslint-disable local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\nexport const ConsoleApiName = {\n    log: 'log',\n    debug: 'debug',\n    info: 'info',\n    warn: 'warn',\n    error: 'error',\n};\n/**\n * When building JS bundles, some users might use a plugin[1] or configuration[2] to remove\n * \"console.*\" references. This causes some issue as we expect `console.*` to be defined.\n * As a workaround, let's use a variable alias, so those expressions won't be taken into account by\n * simple static analysis.\n *\n * [1]: https://babeljs.io/docs/babel-plugin-transform-remove-console/\n * [2]: https://github.com/terser/terser#compress-options (look for drop_console)\n */\nexport const globalConsole = console;\nexport const originalConsoleMethods = {};\nObject.keys(ConsoleApiName).forEach((name) => {\n    originalConsoleMethods[name] = globalConsole[name];\n});\nconst PREFIX = 'Datadog Browser SDK:';\nexport const display = {\n    debug: originalConsoleMethods.debug.bind(globalConsole, PREFIX),\n    log: originalConsoleMethods.log.bind(globalConsole, PREFIX),\n    info: originalConsoleMethods.info.bind(globalConsole, PREFIX),\n    warn: originalConsoleMethods.warn.bind(globalConsole, PREFIX),\n    error: originalConsoleMethods.error.bind(globalConsole, PREFIX),\n};\nexport const DOCS_ORIGIN = 'https://docs.datadoghq.com';\nexport const DOCS_TROUBLESHOOTING = `${DOCS_ORIGIN}/real_user_monitoring/browser/troubleshooting`;\nexport const MORE_DETAILS = 'More details:';\n//# sourceMappingURL=display.js.map","import { display } from './display';\nexport function catchUserErrors(fn, errorMsg) {\n    return (...args) => {\n        try {\n            return fn(...args);\n        }\n        catch (err) {\n            display.error(errorMsg, err);\n        }\n    };\n}\n//# sourceMappingURL=catchUserErrors.js.map","/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold) {\n    return threshold !== 0 && Math.random() * 100 <= threshold;\n}\nexport function round(num, decimals) {\n    return +num.toFixed(decimals);\n}\nexport function isPercentage(value) {\n    return isNumber(value) && value >= 0 && value <= 100;\n}\nexport function isNumber(value) {\n    return typeof value === 'number';\n}\n//# sourceMappingURL=numberUtils.js.map","import { isNumber, round } from './numberUtils';\nexport const ONE_SECOND = 1000;\nexport const ONE_MINUTE = 60 * ONE_SECOND;\nexport const ONE_HOUR = 60 * ONE_MINUTE;\nexport const ONE_DAY = 24 * ONE_HOUR;\nexport const ONE_YEAR = 365 * ONE_DAY;\nexport function relativeToClocks(relative) {\n    return { relative, timeStamp: getCorrectedTimeStamp(relative) };\n}\nexport function timeStampToClocks(timeStamp) {\n    return { relative: getRelativeTime(timeStamp), timeStamp };\n}\nfunction getCorrectedTimeStamp(relativeTime) {\n    const correctedOrigin = (dateNow() - performance.now());\n    // apply correction only for positive drift\n    if (correctedOrigin > getNavigationStart()) {\n        return Math.round(addDuration(correctedOrigin, relativeTime));\n    }\n    return getTimeStamp(relativeTime);\n}\nexport function currentDrift() {\n    return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now()));\n}\nexport function toServerDuration(duration) {\n    if (!isNumber(duration)) {\n        return duration;\n    }\n    return round(duration * 1e6, 0);\n}\nexport function dateNow() {\n    // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n    // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n    // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n    // case ourselves.\n    // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n    return new Date().getTime();\n}\nexport function timeStampNow() {\n    return dateNow();\n}\nexport function relativeNow() {\n    return performance.now();\n}\nexport function clocksNow() {\n    return { relative: relativeNow(), timeStamp: timeStampNow() };\n}\nexport function clocksOrigin() {\n    return { relative: 0, timeStamp: getNavigationStart() };\n}\nexport function elapsed(start, end) {\n    return (end - start);\n}\nexport function addDuration(a, b) {\n    return a + b;\n}\n// Get the time since the navigation was started.\nexport function getRelativeTime(timestamp) {\n    return (timestamp - getNavigationStart());\n}\nexport function getTimeStamp(relativeTime) {\n    return Math.round(addDuration(getNavigationStart(), relativeTime));\n}\nexport function looksLikeRelativeTime(time) {\n    return time < ONE_YEAR;\n}\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart;\n/**\n * Notes: this does not use `performance.timeOrigin` because:\n * - It doesn't seem to reflect the actual time on which the navigation has started: it may be much farther in the past,\n * at least in Firefox 71. (see: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926)\n * - It is not supported in Safari <15\n */\nfunction getNavigationStart() {\n    if (navigationStart === undefined) {\n        navigationStart = performance.timing.navigationStart;\n    }\n    return navigationStart;\n}\n//# sourceMappingURL=timeUtils.js.map","export const ONE_KIBI_BYTE = 1024;\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE;\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/;\nexport function computeBytesCount(candidate) {\n    // Accurate bytes count computations can degrade performances when there is a lot of events to process\n    if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n        return candidate.length;\n    }\n    if (window.TextEncoder !== undefined) {\n        return new TextEncoder().encode(candidate).length;\n    }\n    return new Blob([candidate]).size;\n}\nexport function concatBuffers(buffers) {\n    const length = buffers.reduce((total, buffer) => total + buffer.length, 0);\n    const result = new Uint8Array(length);\n    let offset = 0;\n    for (const buffer of buffers) {\n        result.set(buffer, offset);\n        offset += buffer.length;\n    }\n    return result;\n}\n//# sourceMappingURL=byteUtils.js.map","export function shallowClone(object) {\n    return { ...object };\n}\nexport function objectHasValue(object, value) {\n    return Object.keys(object).some((key) => object[key] === value);\n}\nexport function isEmptyObject(object) {\n    return Object.keys(object).length === 0;\n}\nexport function mapValues(object, fn) {\n    const newObject = {};\n    for (const key of Object.keys(object)) {\n        newObject[key] = fn(object[key]);\n    }\n    return newObject;\n}\n//# sourceMappingURL=objectUtils.js.map","/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\nexport function getGlobalObject() {\n    if (typeof globalThis === 'object') {\n        return globalThis;\n    }\n    Object.defineProperty(Object.prototype, '_dd_temp_', {\n        get() {\n            return this;\n        },\n        configurable: true,\n    });\n    // @ts-ignore _dd_temp is defined using defineProperty\n    let globalObject = _dd_temp_;\n    // @ts-ignore _dd_temp is defined using defineProperty\n    delete Object.prototype._dd_temp_;\n    if (typeof globalObject !== 'object') {\n        // on safari _dd_temp_ is available on window but not globally\n        // fallback on other browser globals check\n        if (typeof self === 'object') {\n            globalObject = self;\n        }\n        else if (typeof window === 'object') {\n            globalObject = window;\n        }\n        else {\n            globalObject = {};\n        }\n    }\n    return globalObject;\n}\n//# sourceMappingURL=getGlobalObject.js.map","import { getGlobalObject } from './getGlobalObject';\n/**\n * Gets the original value for a DOM API that was potentially patched by Zone.js.\n *\n * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original\n * value of the patched functions/constructors/methods in a hidden property prefixed by\n * __zone_symbol__.\n *\n * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to\n * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to\n * use the original DOM API instead of the one patched by Zone.js.\n *\n * [1]: https://github.com/angular/angular/tree/main/packages/zone.js\n */\nexport function getZoneJsOriginalValue(target, name) {\n    const browserWindow = getGlobalObject();\n    let original;\n    if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {\n        original = target[browserWindow.Zone.__symbol__(name)];\n    }\n    if (!original) {\n        original = target[name];\n    }\n    return original;\n}\n//# sourceMappingURL=getZoneJsOriginalValue.js.map","import { display } from './display';\nlet onMonitorErrorCollected;\nlet debugMode = false;\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected) {\n    onMonitorErrorCollected = newOnMonitorErrorCollected;\n}\nexport function setDebugMode(newDebugMode) {\n    debugMode = newDebugMode;\n}\nexport function resetMonitor() {\n    onMonitorErrorCollected = undefined;\n    debugMode = false;\n}\nexport function monitored(_, __, descriptor) {\n    const originalMethod = descriptor.value;\n    descriptor.value = function (...args) {\n        const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod;\n        return decorated.apply(this, args);\n    };\n}\nexport function monitor(fn) {\n    return function () {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return callMonitored(fn, this, arguments);\n    }; // consider output type has input type\n}\nexport function callMonitored(fn, context, args) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return fn.apply(context, args);\n    }\n    catch (e) {\n        monitorError(e);\n    }\n}\nexport function monitorError(e) {\n    displayIfDebugEnabled(e);\n    if (onMonitorErrorCollected) {\n        try {\n            onMonitorErrorCollected(e);\n        }\n        catch (e) {\n            displayIfDebugEnabled(e);\n        }\n    }\n}\nexport function displayIfDebugEnabled(...args) {\n    if (debugMode) {\n        display.error('[MONITOR]', ...args);\n    }\n}\n//# sourceMappingURL=monitor.js.map","import { getZoneJsOriginalValue } from './getZoneJsOriginalValue';\nimport { monitor } from './monitor';\nimport { getGlobalObject } from './getGlobalObject';\nexport function setTimeout(callback, delay) {\n    return getZoneJsOriginalValue(getGlobalObject(), 'setTimeout')(monitor(callback), delay);\n}\nexport function clearTimeout(timeoutId) {\n    getZoneJsOriginalValue(getGlobalObject(), 'clearTimeout')(timeoutId);\n}\nexport function setInterval(callback, delay) {\n    return getZoneJsOriginalValue(getGlobalObject(), 'setInterval')(monitor(callback), delay);\n}\nexport function clearInterval(timeoutId) {\n    getZoneJsOriginalValue(getGlobalObject(), 'clearInterval')(timeoutId);\n}\n//# sourceMappingURL=timer.js.map","// eslint-disable-next-line no-restricted-syntax\nexport class Observable {\n    constructor(onFirstSubscribe) {\n        this.onFirstSubscribe = onFirstSubscribe;\n        this.observers = [];\n    }\n    subscribe(f) {\n        this.observers.push(f);\n        if (this.observers.length === 1 && this.onFirstSubscribe) {\n            this.onLastUnsubscribe = this.onFirstSubscribe(this) || undefined;\n        }\n        return {\n            unsubscribe: () => {\n                this.observers = this.observers.filter((other) => f !== other);\n                if (!this.observers.length && this.onLastUnsubscribe) {\n                    this.onLastUnsubscribe();\n                }\n            },\n        };\n    }\n    notify(data) {\n        this.observers.forEach((observer) => observer(data));\n    }\n}\nexport function mergeObservables(...observables) {\n    return new Observable((globalObservable) => {\n        const subscriptions = observables.map((observable) => observable.subscribe((data) => globalObservable.notify(data)));\n        return () => subscriptions.forEach((subscription) => subscription.unsubscribe());\n    });\n}\n//# sourceMappingURL=observable.js.map","import { setTimeout, clearTimeout } from '../timer';\n// use lodash API\nexport function throttle(fn, wait, options) {\n    const needLeadingExecution = options && options.leading !== undefined ? options.leading : true;\n    const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true;\n    let inWaitPeriod = false;\n    let pendingExecutionWithParameters;\n    let pendingTimeoutId;\n    return {\n        throttled: (...parameters) => {\n            if (inWaitPeriod) {\n                pendingExecutionWithParameters = parameters;\n                return;\n            }\n            if (needLeadingExecution) {\n                fn(...parameters);\n            }\n            else {\n                pendingExecutionWithParameters = parameters;\n            }\n            inWaitPeriod = true;\n            pendingTimeoutId = setTimeout(() => {\n                if (needTrailingExecution && pendingExecutionWithParameters) {\n                    fn(...pendingExecutionWithParameters);\n                }\n                inWaitPeriod = false;\n                pendingExecutionWithParameters = undefined;\n            }, wait);\n        },\n        cancel: () => {\n            clearTimeout(pendingTimeoutId);\n            inWaitPeriod = false;\n            pendingExecutionWithParameters = undefined;\n        },\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() { }\n//# sourceMappingURL=functionUtils.js.map","/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder) {\n    return placeholder\n        ? // eslint-disable-next-line  no-bitwise\n            (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n        : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID);\n}\nconst COMMA_SEPARATED_KEY_VALUE = /([\\w-]+)\\s*=\\s*([^;]+)/g;\nexport function findCommaSeparatedValue(rawString, name) {\n    COMMA_SEPARATED_KEY_VALUE.lastIndex = 0;\n    while (true) {\n        const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString);\n        if (match) {\n            if (match[1] === name) {\n                return match[2];\n            }\n        }\n        else {\n            break;\n        }\n    }\n}\nexport function findCommaSeparatedValues(rawString) {\n    const result = new Map();\n    COMMA_SEPARATED_KEY_VALUE.lastIndex = 0;\n    while (true) {\n        const match = COMMA_SEPARATED_KEY_VALUE.exec(rawString);\n        if (match) {\n            result.set(match[1], match[2]);\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\nexport function safeTruncate(candidate, length, suffix = '') {\n    const lastChar = candidate.charCodeAt(length - 1);\n    const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff;\n    const correctedLength = isLastCharSurrogatePair ? length + 1 : length;\n    if (candidate.length <= correctedLength) {\n        return candidate;\n    }\n    return `${candidate.slice(0, correctedLength)}${suffix}`;\n}\n//# sourceMappingURL=stringUtils.js.map","export function isChromium() {\n    return detectBrowserCached() === 0 /* Browser.CHROMIUM */;\n}\nexport function isSafari() {\n    return detectBrowserCached() === 1 /* Browser.SAFARI */;\n}\nlet browserCache;\nfunction detectBrowserCached() {\n    return browserCache !== null && browserCache !== void 0 ? browserCache : (browserCache = detectBrowser());\n}\n// Exported only for tests\nexport function detectBrowser(browserWindow = window) {\n    var _a;\n    const userAgent = browserWindow.navigator.userAgent;\n    if (browserWindow.chrome || /HeadlessChrome/.test(userAgent)) {\n        return 0 /* Browser.CHROMIUM */;\n    }\n    if (\n    // navigator.vendor is deprecated, but it is the most resilient way we found to detect\n    // \"Apple maintained browsers\" (AKA Safari). If one day it gets removed, we still have the\n    // useragent test as a semi-working fallback.\n    ((_a = browserWindow.navigator.vendor) === null || _a === void 0 ? void 0 : _a.indexOf('Apple')) === 0 ||\n        (/safari/i.test(userAgent) && !/chrome|android/i.test(userAgent))) {\n        return 1 /* Browser.SAFARI */;\n    }\n    return 2 /* Browser.OTHER */;\n}\n//# sourceMappingURL=browserDetection.js.map","import { display } from '../tools/display';\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils';\nimport { findCommaSeparatedValue, findCommaSeparatedValues, generateUUID } from '../tools/utils/stringUtils';\nexport function setCookie(name, value, expireDelay = 0, options) {\n    const date = new Date();\n    date.setTime(date.getTime() + expireDelay);\n    const expires = `expires=${date.toUTCString()}`;\n    const sameSite = options && options.crossSite ? 'none' : 'strict';\n    const domain = options && options.domain ? `;domain=${options.domain}` : '';\n    const secure = options && options.secure ? ';secure' : '';\n    const partitioned = options && options.partitioned ? ';partitioned' : '';\n    document.cookie = `${name}=${value};${expires};path=/;samesite=${sameSite}${domain}${secure}${partitioned}`;\n}\nexport function getCookie(name) {\n    return findCommaSeparatedValue(document.cookie, name);\n}\nlet initCookieParsed;\n/**\n * Returns a cached value of the cookie. Use this during SDK initialization (and whenever possible)\n * to avoid accessing document.cookie multiple times.\n */\nexport function getInitCookie(name) {\n    if (!initCookieParsed) {\n        initCookieParsed = findCommaSeparatedValues(document.cookie);\n    }\n    return initCookieParsed.get(name);\n}\nexport function resetInitCookies() {\n    initCookieParsed = undefined;\n}\nexport function deleteCookie(name, options) {\n    setCookie(name, '', 0, options);\n}\nexport function areCookiesAuthorized(options) {\n    if (document.cookie === undefined || document.cookie === null) {\n        return false;\n    }\n    try {\n        // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n        // the test cookie lifetime\n        const testCookieName = `dd_cookie_test_${generateUUID()}`;\n        const testCookieValue = 'test';\n        setCookie(testCookieName, testCookieValue, ONE_MINUTE, options);\n        const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue;\n        deleteCookie(testCookieName, options);\n        return isCookieCorrectlySet;\n    }\n    catch (error) {\n        display.error(error);\n        return false;\n    }\n}\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache;\nexport function getCurrentSite() {\n    if (getCurrentSiteCache === undefined) {\n        // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n        // the test cookie lifetime\n        const testCookieName = `dd_site_test_${generateUUID()}`;\n        const testCookieValue = 'test';\n        const domainLevels = window.location.hostname.split('.');\n        let candidateDomain = domainLevels.pop();\n        while (domainLevels.length && !getCookie(testCookieName)) {\n            candidateDomain = `${domainLevels.pop()}.${candidateDomain}`;\n            setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain });\n        }\n        deleteCookie(testCookieName, { domain: candidateDomain });\n        getCurrentSiteCache = candidateDomain;\n    }\n    return getCurrentSiteCache;\n}\n//# sourceMappingURL=cookie.js.map","export const SESSION_STORE_KEY = '_dd_s';\n//# sourceMappingURL=sessionStoreStrategy.js.map","export function findLast(array, predicate) {\n    for (let i = array.length - 1; i >= 0; i -= 1) {\n        const item = array[i];\n        if (predicate(item, i, array)) {\n            return item;\n        }\n    }\n    return undefined;\n}\n// Keep the following wrapper functions as it can be mangled and will result in smaller bundle size that using\n// the native Object.values and Object.entries directly\nexport function objectValues(object) {\n    return Object.values(object);\n}\nexport function objectEntries(object) {\n    return Object.entries(object);\n}\n//# sourceMappingURL=polyfills.js.map","import { ONE_HOUR, ONE_MINUTE, ONE_YEAR } from '../../tools/utils/timeUtils';\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR;\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE;\nexport const SESSION_COOKIE_EXPIRATION_DELAY = ONE_YEAR;\nexport const SessionPersistence = {\n    COOKIE: 'cookie',\n    LOCAL_STORAGE: 'local-storage',\n};\n//# sourceMappingURL=sessionConstants.js.map","export const SESSION_ENTRY_REGEXP = /^([a-zA-Z]+)=([a-z0-9-]+)$/;\nexport const SESSION_ENTRY_SEPARATOR = '&';\nexport function isValidSessionString(sessionString) {\n    return (!!sessionString &&\n        (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString)));\n}\n//# sourceMappingURL=sessionStateValidation.js.map","import { isEmptyObject } from '../../tools/utils/objectUtils';\nimport { objectEntries } from '../../tools/utils/polyfills';\nimport { dateNow } from '../../tools/utils/timeUtils';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY } from './sessionConstants';\nimport { isValidSessionString, SESSION_ENTRY_REGEXP, SESSION_ENTRY_SEPARATOR } from './sessionStateValidation';\nexport const EXPIRED = '1';\nexport function getExpiredSessionState(previousSessionState, configuration) {\n    const expiredSessionState = {\n        isExpired: EXPIRED,\n    };\n    if (configuration.trackAnonymousUser) {\n        if (previousSessionState === null || previousSessionState === void 0 ? void 0 : previousSessionState.anonymousId) {\n            expiredSessionState.anonymousId = previousSessionState === null || previousSessionState === void 0 ? void 0 : previousSessionState.anonymousId;\n        }\n        else {\n            expiredSessionState.anonymousId = generateUUID();\n        }\n    }\n    return expiredSessionState;\n}\nexport function isSessionInNotStartedState(session) {\n    return isEmptyObject(session);\n}\nexport function isSessionStarted(session) {\n    return !isSessionInNotStartedState(session);\n}\nexport function isSessionInExpiredState(session) {\n    return session.isExpired !== undefined || !isActiveSession(session);\n}\n// An active session is a session in either `Tracked` or `NotTracked` state\nfunction isActiveSession(sessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return ((sessionState.created === undefined || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) &&\n        (sessionState.expire === undefined || dateNow() < Number(sessionState.expire)));\n}\nexport function expandSessionState(session) {\n    session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY);\n}\nexport function toSessionString(session) {\n    return (objectEntries(session)\n        // we use `aid` as a key for anonymousId\n        .map(([key, value]) => (key === 'anonymousId' ? `aid=${value}` : `${key}=${value}`))\n        .join(SESSION_ENTRY_SEPARATOR));\n}\nexport function toSessionState(sessionString) {\n    const session = {};\n    if (isValidSessionString(sessionString)) {\n        sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n            const matches = SESSION_ENTRY_REGEXP.exec(entry);\n            if (matches !== null) {\n                const [, key, value] = matches;\n                if (key === 'aid') {\n                    // we use `aid` as a key for anonymousId\n                    session.anonymousId = value;\n                }\n                else {\n                    session[key] = value;\n                }\n            }\n        });\n    }\n    return session;\n}\n//# sourceMappingURL=sessionState.js.map","import { isChromium } from '../../../tools/utils/browserDetection';\nimport { getCurrentSite, areCookiesAuthorized, getCookie, setCookie } from '../../../browser/cookie';\nimport { tryOldCookiesMigration } from '../oldCookiesMigration';\nimport { SESSION_COOKIE_EXPIRATION_DELAY, SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY, SessionPersistence, } from '../sessionConstants';\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState';\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy';\nexport function selectCookieStrategy(initConfiguration) {\n    const cookieOptions = buildCookieOptions(initConfiguration);\n    return areCookiesAuthorized(cookieOptions) ? { type: SessionPersistence.COOKIE, cookieOptions } : undefined;\n}\nexport function initCookieStrategy(configuration, cookieOptions) {\n    const cookieStore = {\n        /**\n         * Lock strategy allows mitigating issues due to concurrent access to cookie.\n         * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.\n         */\n        isLockEnabled: isChromium(),\n        persistSession: persistSessionCookie(cookieOptions),\n        retrieveSession: retrieveSessionCookie,\n        expireSession: (sessionState) => expireSessionCookie(cookieOptions, sessionState, configuration),\n    };\n    tryOldCookiesMigration(cookieStore);\n    return cookieStore;\n}\nfunction persistSessionCookie(options) {\n    return (session) => {\n        setCookie(SESSION_STORE_KEY, toSessionString(session), SESSION_EXPIRATION_DELAY, options);\n    };\n}\nfunction expireSessionCookie(options, sessionState, configuration) {\n    const expiredSessionState = getExpiredSessionState(sessionState, configuration);\n    // we do not extend cookie expiration date\n    setCookie(SESSION_STORE_KEY, toSessionString(expiredSessionState), configuration.trackAnonymousUser ? SESSION_COOKIE_EXPIRATION_DELAY : SESSION_TIME_OUT_DELAY, options);\n}\nfunction retrieveSessionCookie() {\n    const sessionString = getCookie(SESSION_STORE_KEY);\n    const sessionState = toSessionState(sessionString);\n    return sessionState;\n}\nexport function buildCookieOptions(initConfiguration) {\n    const cookieOptions = {};\n    cookieOptions.secure =\n        !!initConfiguration.useSecureSessionCookie || !!initConfiguration.usePartitionedCrossSiteSessionCookie;\n    cookieOptions.crossSite = !!initConfiguration.usePartitionedCrossSiteSessionCookie;\n    cookieOptions.partitioned = !!initConfiguration.usePartitionedCrossSiteSessionCookie;\n    if (initConfiguration.trackSessionAcrossSubdomains) {\n        cookieOptions.domain = getCurrentSite();\n    }\n    return cookieOptions;\n}\n//# sourceMappingURL=sessionInCookie.js.map","import { getInitCookie } from '../../browser/cookie';\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy';\nimport { expandSessionState, isSessionStarted } from './sessionState';\nexport const OLD_SESSION_COOKIE_NAME = '_dd';\nexport const OLD_RUM_COOKIE_NAME = '_dd_r';\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l';\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum';\nexport const LOGS_SESSION_KEY = 'logs';\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(cookieStoreStrategy) {\n    const sessionString = getInitCookie(SESSION_STORE_KEY);\n    if (!sessionString) {\n        const oldSessionId = getInitCookie(OLD_SESSION_COOKIE_NAME);\n        const oldRumType = getInitCookie(OLD_RUM_COOKIE_NAME);\n        const oldLogsType = getInitCookie(OLD_LOGS_COOKIE_NAME);\n        const session = {};\n        if (oldSessionId) {\n            session.id = oldSessionId;\n        }\n        if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n            session[LOGS_SESSION_KEY] = oldLogsType;\n        }\n        if (oldRumType && /^[012]$/.test(oldRumType)) {\n            session[RUM_SESSION_KEY] = oldRumType;\n        }\n        if (isSessionStarted(session)) {\n            expandSessionState(session);\n            cookieStoreStrategy.persistSession(session);\n        }\n    }\n}\n//# sourceMappingURL=oldCookiesMigration.js.map","import { generateUUID } from '../../../tools/utils/stringUtils';\nimport { SessionPersistence } from '../sessionConstants';\nimport { toSessionString, toSessionState, getExpiredSessionState } from '../sessionState';\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy';\nconst LOCAL_STORAGE_TEST_KEY = '_dd_test_';\nexport function selectLocalStorageStrategy() {\n    try {\n        const id = generateUUID();\n        const testKey = `${LOCAL_STORAGE_TEST_KEY}${id}`;\n        localStorage.setItem(testKey, id);\n        const retrievedId = localStorage.getItem(testKey);\n        localStorage.removeItem(testKey);\n        return id === retrievedId ? { type: SessionPersistence.LOCAL_STORAGE } : undefined;\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\nexport function initLocalStorageStrategy(configuration) {\n    return {\n        isLockEnabled: false,\n        persistSession: persistInLocalStorage,\n        retrieveSession: retrieveSessionFromLocalStorage,\n        expireSession: (sessionState) => expireSessionFromLocalStorage(sessionState, configuration),\n    };\n}\nfunction persistInLocalStorage(sessionState) {\n    localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState));\n}\nfunction retrieveSessionFromLocalStorage() {\n    const sessionString = localStorage.getItem(SESSION_STORE_KEY);\n    return toSessionState(sessionString);\n}\nfunction expireSessionFromLocalStorage(previousSessionState, configuration) {\n    persistInLocalStorage(getExpiredSessionState(previousSessionState, configuration));\n}\n//# sourceMappingURL=sessionInLocalStorage.js.map","import { setTimeout } from '../../tools/timer';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { expandSessionState, isSessionInExpiredState } from './sessionState';\nexport const LOCK_RETRY_DELAY = 10;\nexport const LOCK_MAX_TRIES = 100;\nconst bufferedOperations = [];\nlet ongoingOperations;\nexport function processSessionStoreOperations(operations, sessionStoreStrategy, numberOfRetries = 0) {\n    var _a;\n    const { isLockEnabled, persistSession, expireSession } = sessionStoreStrategy;\n    const persistWithLock = (session) => persistSession({ ...session, lock: currentLock });\n    const retrieveStore = () => {\n        const session = sessionStoreStrategy.retrieveSession();\n        const lock = session.lock;\n        if (session.lock) {\n            delete session.lock;\n        }\n        return {\n            session,\n            lock,\n        };\n    };\n    if (!ongoingOperations) {\n        ongoingOperations = operations;\n    }\n    if (operations !== ongoingOperations) {\n        bufferedOperations.push(operations);\n        return;\n    }\n    if (isLockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n        next(sessionStoreStrategy);\n        return;\n    }\n    let currentLock;\n    let currentStore = retrieveStore();\n    if (isLockEnabled) {\n        // if someone has lock, retry later\n        if (currentStore.lock) {\n            retryLater(operations, sessionStoreStrategy, numberOfRetries);\n            return;\n        }\n        // acquire lock\n        currentLock = generateUUID();\n        persistWithLock(currentStore.session);\n        // if lock is not acquired, retry later\n        currentStore = retrieveStore();\n        if (currentStore.lock !== currentLock) {\n            retryLater(operations, sessionStoreStrategy, numberOfRetries);\n            return;\n        }\n    }\n    let processedSession = operations.process(currentStore.session);\n    if (isLockEnabled) {\n        // if lock corrupted after process, retry later\n        currentStore = retrieveStore();\n        if (currentStore.lock !== currentLock) {\n            retryLater(operations, sessionStoreStrategy, numberOfRetries);\n            return;\n        }\n    }\n    if (processedSession) {\n        if (isSessionInExpiredState(processedSession)) {\n            expireSession(processedSession);\n        }\n        else {\n            expandSessionState(processedSession);\n            if (isLockEnabled) {\n                persistWithLock(processedSession);\n            }\n            else {\n                persistSession(processedSession);\n            }\n        }\n    }\n    if (isLockEnabled) {\n        // correctly handle lock around expiration would require to handle this case properly at several levels\n        // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n        if (!(processedSession && isSessionInExpiredState(processedSession))) {\n            // if lock corrupted after persist, retry later\n            currentStore = retrieveStore();\n            if (currentStore.lock !== currentLock) {\n                retryLater(operations, sessionStoreStrategy, numberOfRetries);\n                return;\n            }\n            persistSession(currentStore.session);\n            processedSession = currentStore.session;\n        }\n    }\n    // call after even if session is not persisted in order to perform operations on\n    // up-to-date session state value => the value could have been modified by another tab\n    (_a = operations.after) === null || _a === void 0 ? void 0 : _a.call(operations, processedSession || currentStore.session);\n    next(sessionStoreStrategy);\n}\nfunction retryLater(operations, sessionStore, currentNumberOfRetries) {\n    setTimeout(() => {\n        processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1);\n    }, LOCK_RETRY_DELAY);\n}\nfunction next(sessionStore) {\n    ongoingOperations = undefined;\n    const nextOperations = bufferedOperations.shift();\n    if (nextOperations) {\n        processSessionStoreOperations(nextOperations, sessionStore);\n    }\n}\n//# sourceMappingURL=sessionStoreOperations.js.map","import { clearInterval, setInterval } from '../../tools/timer';\nimport { Observable } from '../../tools/observable';\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils';\nimport { throttle } from '../../tools/utils/functionUtils';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { display } from '../../tools/display';\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie';\nimport { getExpiredSessionState, isSessionInExpiredState, isSessionInNotStartedState, isSessionStarted, } from './sessionState';\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage';\nimport { processSessionStoreOperations } from './sessionStoreOperations';\nimport { SessionPersistence } from './sessionConstants';\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport const STORAGE_POLL_DELAY = ONE_SECOND;\n/**\n * Selects the correct session store strategy type based on the configuration and storage\n * availability.\n */\nexport function selectSessionStoreStrategyType(initConfiguration) {\n    switch (initConfiguration.sessionPersistence) {\n        case SessionPersistence.COOKIE:\n            return selectCookieStrategy(initConfiguration);\n        case SessionPersistence.LOCAL_STORAGE:\n            return selectLocalStorageStrategy();\n        case undefined: {\n            let sessionStoreStrategyType = selectCookieStrategy(initConfiguration);\n            if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n                sessionStoreStrategyType = selectLocalStorageStrategy();\n            }\n            return sessionStoreStrategyType;\n        }\n        default:\n            display.error(`Invalid session persistence '${String(initConfiguration.sessionPersistence)}'`);\n    }\n}\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore(sessionStoreStrategyType, configuration, productKey, computeSessionState) {\n    const renewObservable = new Observable();\n    const expireObservable = new Observable();\n    const sessionStateUpdateObservable = new Observable();\n    const sessionStoreStrategy = sessionStoreStrategyType.type === SessionPersistence.COOKIE\n        ? initCookieStrategy(configuration, sessionStoreStrategyType.cookieOptions)\n        : initLocalStorageStrategy(configuration);\n    const { expireSession } = sessionStoreStrategy;\n    const watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY);\n    let sessionCache;\n    startSession();\n    const { throttled: throttledExpandOrRenewSession, cancel: cancelExpandOrRenewSession } = throttle(() => {\n        processSessionStoreOperations({\n            process: (sessionState) => {\n                if (isSessionInNotStartedState(sessionState)) {\n                    return;\n                }\n                const synchronizedSession = synchronizeSession(sessionState);\n                expandOrRenewSessionState(synchronizedSession);\n                return synchronizedSession;\n            },\n            after: (sessionState) => {\n                if (isSessionStarted(sessionState) && !hasSessionInCache()) {\n                    renewSessionInCache(sessionState);\n                }\n                sessionCache = sessionState;\n            },\n        }, sessionStoreStrategy);\n    }, STORAGE_POLL_DELAY);\n    function expandSession() {\n        processSessionStoreOperations({\n            process: (sessionState) => (hasSessionInCache() ? synchronizeSession(sessionState) : undefined),\n        }, sessionStoreStrategy);\n    }\n    /**\n     * allows two behaviors:\n     * - if the session is active, synchronize the session cache without updating the session store\n     * - if the session is not active, clear the session store and expire the session cache\n     */\n    function watchSession() {\n        processSessionStoreOperations({\n            process: (sessionState) => isSessionInExpiredState(sessionState) ? getExpiredSessionState(sessionState, configuration) : undefined,\n            after: synchronizeSession,\n        }, sessionStoreStrategy);\n    }\n    function synchronizeSession(sessionState) {\n        if (isSessionInExpiredState(sessionState)) {\n            sessionState = getExpiredSessionState(sessionState, configuration);\n        }\n        if (hasSessionInCache()) {\n            if (isSessionInCacheOutdated(sessionState)) {\n                expireSessionInCache();\n            }\n            else {\n                sessionStateUpdateObservable.notify({ previousState: sessionCache, newState: sessionState });\n                sessionCache = sessionState;\n            }\n        }\n        return sessionState;\n    }\n    function startSession() {\n        processSessionStoreOperations({\n            process: (sessionState) => {\n                if (isSessionInNotStartedState(sessionState)) {\n                    return getExpiredSessionState(sessionState, configuration);\n                }\n            },\n            after: (sessionState) => {\n                sessionCache = sessionState;\n            },\n        }, sessionStoreStrategy);\n    }\n    function expandOrRenewSessionState(sessionState) {\n        if (isSessionInNotStartedState(sessionState)) {\n            return false;\n        }\n        const { trackingType, isTracked } = computeSessionState(sessionState[productKey]);\n        sessionState[productKey] = trackingType;\n        delete sessionState.isExpired;\n        if (isTracked && !sessionState.id) {\n            sessionState.id = generateUUID();\n            sessionState.created = String(dateNow());\n        }\n    }\n    function hasSessionInCache() {\n        return sessionCache[productKey] !== undefined;\n    }\n    function isSessionInCacheOutdated(sessionState) {\n        return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey];\n    }\n    function expireSessionInCache() {\n        sessionCache = getExpiredSessionState(sessionCache, configuration);\n        expireObservable.notify();\n    }\n    function renewSessionInCache(sessionState) {\n        sessionCache = sessionState;\n        renewObservable.notify();\n    }\n    function updateSessionState(partialSessionState) {\n        processSessionStoreOperations({\n            process: (sessionState) => ({ ...sessionState, ...partialSessionState }),\n            after: synchronizeSession,\n        }, sessionStoreStrategy);\n    }\n    return {\n        expandOrRenewSession: throttledExpandOrRenewSession,\n        expandSession,\n        getSession: () => sessionCache,\n        renewObservable,\n        expireObservable,\n        sessionStateUpdateObservable,\n        restartSession: startSession,\n        expire: () => {\n            cancelExpandOrRenewSession();\n            expireSession(sessionCache);\n            synchronizeSession(getExpiredSessionState(sessionCache, configuration));\n        },\n        stop: () => {\n            clearInterval(watchSessionTimeoutId);\n        },\n        updateSessionState,\n    };\n}\n//# sourceMappingURL=sessionStore.js.map","import { Observable } from '../tools/observable';\nexport const TrackingConsent = {\n    GRANTED: 'granted',\n    NOT_GRANTED: 'not-granted',\n};\nexport function createTrackingConsentState(currentConsent) {\n    const observable = new Observable();\n    return {\n        tryToInit(trackingConsent) {\n            if (!currentConsent) {\n                currentConsent = trackingConsent;\n            }\n        },\n        update(trackingConsent) {\n            currentConsent = trackingConsent;\n            observable.notify();\n        },\n        isGranted() {\n            return currentConsent === TrackingConsent.GRANTED;\n        },\n        observable,\n    };\n}\n//# sourceMappingURL=trackingConsent.js.map","import { noop } from '../utils/functionUtils';\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(value, replacer, space) {\n    if (typeof value !== 'object' || value === null) {\n        return JSON.stringify(value);\n    }\n    // Note: The order matter here. We need to detach toJSON methods on parent classes before their\n    // subclasses.\n    const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);\n    const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);\n    const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value));\n    const restoreValueToJson = detachToJsonMethod(value);\n    try {\n        return JSON.stringify(value, replacer, space);\n    }\n    catch (_a) {\n        return '<error: unable to serialize object>';\n    }\n    finally {\n        restoreObjectPrototypeToJson();\n        restoreArrayPrototypeToJson();\n        restoreValuePrototypeToJson();\n        restoreValueToJson();\n    }\n}\nexport function detachToJsonMethod(value) {\n    const object = value;\n    const objectToJson = object.toJSON;\n    if (objectToJson) {\n        delete object.toJSON;\n        return () => {\n            object.toJSON = objectToJson;\n        };\n    }\n    return noop;\n}\n//# sourceMappingURL=jsonStringify.js.map","import { jsonStringify } from '../serialisation/jsonStringify';\nexport function normalizeUrl(url) {\n    return buildUrl(url, location.href).href;\n}\nexport function isValidUrl(url) {\n    try {\n        return !!buildUrl(url);\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function getPathName(url) {\n    const pathname = buildUrl(url).pathname;\n    return pathname[0] === '/' ? pathname : `/${pathname}`;\n}\nexport function buildUrl(url, base) {\n    const supportedURL = getSupportedUrl();\n    if (supportedURL) {\n        try {\n            return base !== undefined ? new supportedURL(url, base) : new supportedURL(url);\n        }\n        catch (error) {\n            throw new Error(`Failed to construct URL: ${String(error)} ${jsonStringify({ url, base })}`);\n        }\n    }\n    if (base === undefined && !/:/.test(url)) {\n        throw new Error(`Invalid URL: '${url}'`);\n    }\n    let doc = document;\n    const anchorElement = doc.createElement('a');\n    if (base !== undefined) {\n        doc = document.implementation.createHTMLDocument('');\n        const baseElement = doc.createElement('base');\n        baseElement.href = base;\n        doc.head.appendChild(baseElement);\n        doc.body.appendChild(anchorElement);\n    }\n    anchorElement.href = url;\n    return anchorElement;\n}\nconst originalURL = URL;\nlet isURLSupported;\nfunction getSupportedUrl() {\n    if (isURLSupported === undefined) {\n        try {\n            const url = new originalURL('http://test/path');\n            isURLSupported = url.href === 'http://test/path';\n        }\n        catch (_a) {\n            isURLSupported = false;\n        }\n    }\n    return isURLSupported ? originalURL : undefined;\n}\n//# sourceMappingURL=urlPolyfill.js.map","export const INTAKE_SITE_STAGING = 'datad0g.com';\nexport const INTAKE_SITE_FED_STAGING = 'dd0g-gov.com';\nexport const INTAKE_SITE_US1 = 'datadoghq.com';\nexport const INTAKE_SITE_EU1 = 'datadoghq.eu';\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com';\nexport const PCI_INTAKE_HOST_US1 = 'pci.browser-intake-datadoghq.com';\nexport const INTAKE_URL_PARAMETERS = ['ddsource', 'ddtags'];\n//# sourceMappingURL=intakeSites.js.map","import { timeStampNow } from '../../tools/utils/timeUtils';\nimport { normalizeUrl } from '../../tools/utils/urlPolyfill';\nimport { generateUUID } from '../../tools/utils/stringUtils';\nimport { INTAKE_SITE_US1, INTAKE_SITE_FED_STAGING, PCI_INTAKE_HOST_US1 } from './intakeSites';\nexport function createEndpointBuilder(initConfiguration, trackType, configurationTags) {\n    const buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, trackType);\n    return {\n        build(api, payload) {\n            const parameters = buildEndpointParameters(initConfiguration, trackType, configurationTags, api, payload);\n            return buildUrlWithParameters(parameters);\n        },\n        urlPrefix: buildUrlWithParameters(''),\n        trackType,\n    };\n}\n/**\n * Create a function used to build a full endpoint url from provided parameters. The goal of this\n * function is to pre-compute some parts of the URL to avoid re-computing everything on every\n * request, as only parameters are changing.\n */\nfunction createEndpointUrlWithParametersBuilder(initConfiguration, trackType) {\n    const path = `/api/v2/${trackType}`;\n    const proxy = initConfiguration.proxy;\n    if (typeof proxy === 'string') {\n        const normalizedProxyUrl = normalizeUrl(proxy);\n        return (parameters) => `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`${path}?${parameters}`)}`;\n    }\n    if (typeof proxy === 'function') {\n        return (parameters) => proxy({ path, parameters });\n    }\n    const host = buildEndpointHost(trackType, initConfiguration);\n    return (parameters) => `https://${host}${path}?${parameters}`;\n}\nexport function buildEndpointHost(trackType, initConfiguration) {\n    const { site = INTAKE_SITE_US1, internalAnalyticsSubdomain } = initConfiguration;\n    if (trackType === 'logs' && initConfiguration.usePciIntake && site === INTAKE_SITE_US1) {\n        return PCI_INTAKE_HOST_US1;\n    }\n    if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {\n        return `${internalAnalyticsSubdomain}.${INTAKE_SITE_US1}`;\n    }\n    if (site === INTAKE_SITE_FED_STAGING) {\n        return `http-intake.logs.${site}`;\n    }\n    const domainParts = site.split('.');\n    const extension = domainParts.pop();\n    return `browser-intake-${domainParts.join('-')}.${extension}`;\n}\n/**\n * Build parameters to be used for an intake request. Parameters should be re-built for each\n * request, as they change randomly.\n */\nfunction buildEndpointParameters({ clientToken, internalAnalyticsSubdomain }, trackType, configurationTags, api, { retry, encoding }) {\n    const tags = [`sdk_version:${\"6.4.0\"}`, `api:${api}`].concat(configurationTags);\n    if (retry) {\n        tags.push(`retry_count:${retry.count}`, `retry_after:${retry.lastFailureStatus}`);\n    }\n    const parameters = [\n        'ddsource=browser',\n        `ddtags=${encodeURIComponent(tags.join(','))}`,\n        `dd-api-key=${clientToken}`,\n        `dd-evp-origin-version=${encodeURIComponent(\"6.4.0\")}`,\n        'dd-evp-origin=browser',\n        `dd-request-id=${generateUUID()}`,\n    ];\n    if (encoding) {\n        parameters.push(`dd-evp-encoding=${encoding}`);\n    }\n    if (trackType === 'rum') {\n        parameters.push(`batch_time=${timeStampNow()}`);\n    }\n    if (internalAnalyticsSubdomain) {\n        parameters.reverse();\n    }\n    return parameters.join('&');\n}\n//# sourceMappingURL=endpointBuilder.js.map","import { DOCS_ORIGIN, MORE_DETAILS, display } from '../../tools/display';\nexport const TAG_SIZE_LIMIT = 200;\nexport function buildTags(configuration) {\n    const { env, service, version, datacenter } = configuration;\n    const tags = [];\n    if (env) {\n        tags.push(buildTag('env', env));\n    }\n    if (service) {\n        tags.push(buildTag('service', service));\n    }\n    if (version) {\n        tags.push(buildTag('version', version));\n    }\n    if (datacenter) {\n        tags.push(buildTag('datacenter', datacenter));\n    }\n    return tags;\n}\nexport function buildTag(key, rawValue) {\n    // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n    // that the backend may not follow the exact same rules, so we only want to display an informal\n    // warning.\n    const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1;\n    if (rawValue.length > valueSizeLimit || hasForbiddenCharacters(rawValue)) {\n        display.warn(`${key} value doesn't meet tag requirements and will be sanitized. ${MORE_DETAILS} ${DOCS_ORIGIN}/getting_started/tagging/#defining-tags`);\n    }\n    // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n    // by forging a value containing commas.\n    const sanitizedValue = rawValue.replace(/,/g, '_');\n    return `${key}:${sanitizedValue}`;\n}\nfunction hasForbiddenCharacters(rawValue) {\n    // Unicode property escapes is not supported in all browsers, so we use a try/catch.\n    // Todo: Remove the try/catch when dropping support for Chrome 63 and Firefox 67\n    // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape#browser_compatibility\n    if (!supportUnicodePropertyEscapes()) {\n        return false;\n    }\n    // We use the Unicode property escapes to match any character that is a letter including other languages like Chinese, Japanese, etc.\n    // p{Ll} matches a lowercase letter.\n    // p{Lo} matches a letter that is neither uppercase nor lowercase (ex: Japanese characters).\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape#unicode_property_escapes_vs._character_classes\n    return new RegExp('[^\\\\p{Ll}\\\\p{Lo}0-9_:./-]', 'u').test(rawValue);\n}\nexport function supportUnicodePropertyEscapes() {\n    try {\n        new RegExp('[\\\\p{Ll}]', 'u');\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n//# sourceMappingURL=tags.js.map","import { createEndpointBuilder } from './endpointBuilder';\nimport { buildTags } from './tags';\nimport { INTAKE_SITE_US1, INTAKE_URL_PARAMETERS } from './intakeSites';\nexport function computeTransportConfiguration(initConfiguration) {\n    const site = initConfiguration.site || INTAKE_SITE_US1;\n    const tags = buildTags(initConfiguration);\n    const endpointBuilders = computeEndpointBuilders(initConfiguration, tags);\n    const replicaConfiguration = computeReplicaConfiguration(initConfiguration, tags);\n    return {\n        replica: replicaConfiguration,\n        site,\n        ...endpointBuilders,\n    };\n}\nfunction computeEndpointBuilders(initConfiguration, tags) {\n    return {\n        logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n        rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n        sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'replay', tags),\n    };\n}\nfunction computeReplicaConfiguration(initConfiguration, tags) {\n    if (!initConfiguration.replica) {\n        return;\n    }\n    const replicaConfiguration = {\n        ...initConfiguration,\n        site: INTAKE_SITE_US1,\n        clientToken: initConfiguration.replica.clientToken,\n    };\n    const replicaEndpointBuilders = {\n        logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n        rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n    };\n    return { applicationId: initConfiguration.replica.applicationId, ...replicaEndpointBuilders };\n}\nexport function isIntakeUrl(url) {\n    // check if tags is present in the query string\n    return INTAKE_URL_PARAMETERS.every((param) => url.includes(param));\n}\n//# sourceMappingURL=transportConfiguration.js.map","import { catchUserErrors } from '../../tools/catchUserErrors';\nimport { DOCS_ORIGIN, MORE_DETAILS, display } from '../../tools/display';\nimport { ONE_SECOND } from '../../tools/utils/timeUtils';\nimport { isPercentage } from '../../tools/utils/numberUtils';\nimport { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils';\nimport { objectHasValue } from '../../tools/utils/objectUtils';\nimport { selectSessionStoreStrategyType } from '../session/sessionStore';\nimport { TrackingConsent } from '../trackingConsent';\nimport { computeTransportConfiguration } from './transportConfiguration';\nexport const DefaultPrivacyLevel = {\n    ALLOW: 'allow',\n    MASK: 'mask',\n    MASK_USER_INPUT: 'mask-user-input',\n};\nexport const TraceContextInjection = {\n    ALL: 'all',\n    SAMPLED: 'sampled',\n};\nfunction isString(tag, tagName) {\n    if (tag !== undefined && tag !== null && typeof tag !== 'string') {\n        display.error(`${tagName} must be defined as a string`);\n        return false;\n    }\n    return true;\n}\nfunction isDatadogSite(site) {\n    if (site && typeof site === 'string' && !/(datadog|ddog|datad0g|dd0g)/.test(site)) {\n        display.error(`Site should be a valid Datadog site. ${MORE_DETAILS} ${DOCS_ORIGIN}/getting_started/site/.`);\n        return false;\n    }\n    return true;\n}\nexport function isSampleRate(sampleRate, name) {\n    if (sampleRate !== undefined && !isPercentage(sampleRate)) {\n        display.error(`${name} Sample Rate should be a number between 0 and 100`);\n        return false;\n    }\n    return true;\n}\nexport function validateAndBuildConfiguration(initConfiguration) {\n    var _a, _b, _c, _d, _e, _f;\n    if (!initConfiguration || !initConfiguration.clientToken) {\n        display.error('Client Token is not configured, we will not send any data.');\n        return;\n    }\n    if (!isDatadogSite(initConfiguration.site) ||\n        !isSampleRate(initConfiguration.sessionSampleRate, 'Session') ||\n        !isSampleRate(initConfiguration.telemetrySampleRate, 'Telemetry') ||\n        !isSampleRate(initConfiguration.telemetryConfigurationSampleRate, 'Telemetry Configuration') ||\n        !isSampleRate(initConfiguration.telemetryUsageSampleRate, 'Telemetry Usage') ||\n        !isString(initConfiguration.version, 'Version') ||\n        !isString(initConfiguration.env, 'Env') ||\n        !isString(initConfiguration.service, 'Service')) {\n        return;\n    }\n    if (initConfiguration.trackingConsent !== undefined &&\n        !objectHasValue(TrackingConsent, initConfiguration.trackingConsent)) {\n        display.error('Tracking Consent should be either \"granted\" or \"not-granted\"');\n        return;\n    }\n    return {\n        beforeSend: initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n        sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),\n        sessionSampleRate: (_a = initConfiguration.sessionSampleRate) !== null && _a !== void 0 ? _a : 100,\n        telemetrySampleRate: (_b = initConfiguration.telemetrySampleRate) !== null && _b !== void 0 ? _b : 20,\n        telemetryConfigurationSampleRate: (_c = initConfiguration.telemetryConfigurationSampleRate) !== null && _c !== void 0 ? _c : 5,\n        telemetryUsageSampleRate: (_d = initConfiguration.telemetryUsageSampleRate) !== null && _d !== void 0 ? _d : 5,\n        service: initConfiguration.service || undefined,\n        silentMultipleInit: !!initConfiguration.silentMultipleInit,\n        allowUntrustedEvents: !!initConfiguration.allowUntrustedEvents,\n        trackingConsent: (_e = initConfiguration.trackingConsent) !== null && _e !== void 0 ? _e : TrackingConsent.GRANTED,\n        trackAnonymousUser: (_f = initConfiguration.trackAnonymousUser) !== null && _f !== void 0 ? _f : true,\n        storeContextsAcrossPages: !!initConfiguration.storeContextsAcrossPages,\n        /**\n         * beacon payload max queue size implementation is 64kb\n         * ensure that we leave room for logs, rum and potential other users\n         */\n        batchBytesLimit: 16 * ONE_KIBI_BYTE,\n        eventRateLimiterThreshold: 3000,\n        maxTelemetryEventsPerPage: 15,\n        /**\n         * flush automatically, aim to be lower than ALB connection timeout\n         * to maximize connection reuse.\n         */\n        flushTimeout: (30 * ONE_SECOND),\n        /**\n         * Logs intake limit\n         */\n        batchMessagesLimit: 50,\n        messageBytesLimit: 256 * ONE_KIBI_BYTE,\n        ...computeTransportConfiguration(initConfiguration),\n    };\n}\nexport function serializeConfiguration(initConfiguration) {\n    return {\n        session_sample_rate: initConfiguration.sessionSampleRate,\n        telemetry_sample_rate: initConfiguration.telemetrySampleRate,\n        telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,\n        telemetry_usage_sample_rate: initConfiguration.telemetryUsageSampleRate,\n        use_before_send: !!initConfiguration.beforeSend,\n        use_partitioned_cross_site_session_cookie: initConfiguration.usePartitionedCrossSiteSessionCookie,\n        use_secure_session_cookie: initConfiguration.useSecureSessionCookie,\n        use_proxy: !!initConfiguration.proxy,\n        silent_multiple_init: initConfiguration.silentMultipleInit,\n        track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,\n        track_anonymous_user: initConfiguration.trackAnonymousUser,\n        session_persistence: initConfiguration.sessionPersistence,\n        allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage,\n        store_contexts_across_pages: !!initConfiguration.storeContextsAcrossPages,\n        allow_untrusted_events: !!initConfiguration.allowUntrustedEvents,\n        tracking_consent: initConfiguration.trackingConsent,\n    };\n}\n//# sourceMappingURL=configuration.js.map","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n *\n * FORMAT:\n * All feature flags should be snake_cased\n */\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected feature flag\nimport { objectHasValue } from './utils/objectUtils';\n// eslint-disable-next-line no-restricted-syntax\nexport var ExperimentalFeature;\n(function (ExperimentalFeature) {\n    ExperimentalFeature[\"WRITABLE_RESOURCE_GRAPHQL\"] = \"writable_resource_graphql\";\n    ExperimentalFeature[\"CONSISTENT_TRACE_SAMPLING\"] = \"consistent_trace_sampling\";\n    ExperimentalFeature[\"MISSING_URL_CONTEXT_TELEMETRY\"] = \"missing_url_context_telemetry\";\n})(ExperimentalFeature || (ExperimentalFeature = {}));\nconst enabledExperimentalFeatures = new Set();\nexport function initFeatureFlags(enableExperimentalFeatures) {\n    if (Array.isArray(enableExperimentalFeatures)) {\n        addExperimentalFeatures(enableExperimentalFeatures.filter((flag) => objectHasValue(ExperimentalFeature, flag)));\n    }\n}\nexport function addExperimentalFeatures(enabledFeatures) {\n    enabledFeatures.forEach((flag) => {\n        enabledExperimentalFeatures.add(flag);\n    });\n}\nexport function isExperimentalFeatureEnabled(featureName) {\n    return enabledExperimentalFeatures.has(featureName);\n}\nexport function resetExperimentalFeatures() {\n    enabledExperimentalFeatures.clear();\n}\nexport function getExperimentalFeatures() {\n    return enabledExperimentalFeatures;\n}\n//# sourceMappingURL=experimentalFeatures.js.map","/**\n * Cross-browser stack trace computation.\n *\n * Reference implementation: https://github.com/csnover/TraceKit/blob/04530298073c3823de72deb0b97e7b38ca7bcb59/tracekit.js\n */\nconst UNKNOWN_FUNCTION = '?';\nexport function computeStackTrace(ex) {\n    const stack = [];\n    let stackProperty = tryToGetString(ex, 'stack');\n    const exString = String(ex);\n    if (stackProperty && stackProperty.startsWith(exString)) {\n        stackProperty = stackProperty.slice(exString.length);\n    }\n    if (stackProperty) {\n        stackProperty.split('\\n').forEach((line) => {\n            const stackFrame = parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line);\n            if (stackFrame) {\n                if (!stackFrame.func && stackFrame.line) {\n                    stackFrame.func = UNKNOWN_FUNCTION;\n                }\n                stack.push(stackFrame);\n            }\n        });\n    }\n    return {\n        message: tryToGetString(ex, 'message'),\n        name: tryToGetString(ex, 'name'),\n        stack,\n    };\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|electron|native|eval|webpack|snippet|<anonymous>|\\\\w+\\\\.|\\\\/).*?)';\nconst filePosition = '(?::(\\\\d+))';\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i');\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`);\nfunction parseChromeLine(line) {\n    const parts = CHROME_LINE_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    const isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n    const submatch = CHROME_EVAL_RE.exec(parts[2]);\n    if (isEval && submatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = submatch[1]; // url\n        parts[3] = submatch[2]; // line\n        parts[4] = submatch[3]; // column\n    }\n    return {\n        args: isNative ? [parts[2]] : [],\n        column: parts[4] ? +parts[4] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: parts[3] ? +parts[3] : undefined,\n        url: !isNative ? parts[2] : undefined,\n    };\n}\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i');\nfunction parseChromeAnonymousLine(line) {\n    const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    return {\n        args: [],\n        column: parts[3] ? +parts[3] : undefined,\n        func: UNKNOWN_FUNCTION,\n        line: parts[2] ? +parts[2] : undefined,\n        url: parts[1],\n    };\n}\nconst WINJS_LINE_RE = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nfunction parseWinLine(line) {\n    const parts = WINJS_LINE_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    return {\n        args: [],\n        column: parts[4] ? +parts[4] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: +parts[3],\n        url: parts[2],\n    };\n}\nconst GECKO_LINE_RE = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nfunction parseGeckoLine(line) {\n    const parts = GECKO_LINE_RE.exec(line);\n    if (!parts) {\n        return;\n    }\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    const submatch = GECKO_EVAL_RE.exec(parts[3]);\n    if (isEval && submatch) {\n        // throw out eval line/column and use top-most line number\n        parts[3] = submatch[1];\n        parts[4] = submatch[2];\n        parts[5] = undefined; // no column when eval\n    }\n    return {\n        args: parts[2] ? parts[2].split(',') : [],\n        column: parts[5] ? +parts[5] : undefined,\n        func: parts[1] || UNKNOWN_FUNCTION,\n        line: parts[4] ? +parts[4] : undefined,\n        url: parts[3],\n    };\n}\nfunction tryToGetString(candidate, property) {\n    if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n        return undefined;\n    }\n    const value = candidate[property];\n    return typeof value === 'string' ? value : undefined;\n}\nexport function computeStackTraceFromOnErrorMessage(messageObj, url, line, column) {\n    const stack = [{ url, column, line }];\n    const { name, message } = tryToParseMessage(messageObj);\n    return {\n        name,\n        message,\n        stack,\n    };\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\\s\\S]*)$/;\nfunction tryToParseMessage(messageObj) {\n    let name;\n    let message;\n    if ({}.toString.call(messageObj) === '[object String]') {\n        ;\n        [, name, message] = ERROR_TYPES_RE.exec(messageObj);\n    }\n    return { name, message };\n}\n//# sourceMappingURL=computeStackTrace.js.map","import { callMonitored } from '../monitor';\nimport { computeStackTrace } from './computeStackTrace';\n/**\n * Creates a stacktrace without SDK internal frames.\n * Constraints:\n * - Has to be called at the utmost position of the call stack.\n * - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(type) {\n    /**\n     * Skip the two internal frames:\n     * - SDK API (console.error, ...)\n     * - this function\n     * in order to keep only the user calls\n     */\n    const internalFramesToSkip = 2;\n    const error = new Error(type);\n    error.name = 'HandlingStack';\n    let formattedStack;\n    callMonitored(() => {\n        const stackTrace = computeStackTrace(error);\n        stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip);\n        formattedStack = toStackTraceString(stackTrace);\n    });\n    return formattedStack;\n}\nexport function toStackTraceString(stack) {\n    let result = formatErrorMessage(stack);\n    stack.stack.forEach((frame) => {\n        const func = frame.func === '?' ? '<anonymous>' : frame.func;\n        const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : '';\n        const line = frame.line ? `:${frame.line}` : '';\n        const column = frame.line && frame.column ? `:${frame.column}` : '';\n        result += `\\n  at ${func}${args} @ ${frame.url}${line}${column}`;\n    });\n    return result;\n}\nexport function formatErrorMessage(stack) {\n    return `${stack.name || 'Error'}: ${stack.message}`;\n}\n//# sourceMappingURL=handlingStack.js.map","import { setTimeout } from './timer';\nimport { callMonitored } from './monitor';\nimport { noop } from './utils/functionUtils';\nimport { createHandlingStack } from './stackTrace/handlingStack';\n/**\n * Instruments a method on a object, calling the given callback before the original method is\n * invoked. The callback receives an object with information about the method call.\n *\n * This function makes sure that we are \"good citizens\" regarding third party instrumentations: when\n * removing the instrumentation, the original method is usually restored, but if a third party\n * instrumentation was set after ours, we keep it in place and just replace our instrumentation with\n * a noop.\n *\n * Note: it is generally better to instrument methods that are \"owned\" by the object instead of ones\n * that are inherited from the prototype chain. Example:\n * * do:    `instrumentMethod(Array.prototype, 'push', ...)`\n * * don't: `instrumentMethod([], 'push', ...)`\n *\n * This method is also used to set event handler properties (ex: window.onerror = ...), as it has\n * the same requirements as instrumenting a method:\n * * if the event handler is already set by a third party, we need to call it and not just blindly\n * override it.\n * * if the event handler is set by a third party after us, we need to keep it in place when\n * removing ours.\n *\n * @example\n *\n *  instrumentMethod(window, 'fetch', ({ target, parameters, onPostCall }) => {\n *    console.log('Before calling fetch on', target, 'with parameters', parameters)\n *\n *    onPostCall((result) => {\n *      console.log('After fetch calling on', target, 'with parameters', parameters, 'and result', result)\n *    })\n *  })\n */\nexport function instrumentMethod(targetPrototype, method, onPreCall, { computeHandlingStack } = {}) {\n    let original = targetPrototype[method];\n    if (typeof original !== 'function') {\n        if (method in targetPrototype && method.startsWith('on')) {\n            original = noop;\n        }\n        else {\n            return { stop: noop };\n        }\n    }\n    let stopped = false;\n    const instrumentation = function () {\n        if (stopped) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n            return original.apply(this, arguments);\n        }\n        const parameters = Array.from(arguments);\n        let postCallCallback;\n        callMonitored(onPreCall, null, [\n            {\n                target: this,\n                parameters,\n                onPostCall: (callback) => {\n                    postCallCallback = callback;\n                },\n                handlingStack: computeHandlingStack ? createHandlingStack('instrumented method') : undefined,\n            },\n        ]);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const result = original.apply(this, parameters);\n        if (postCallCallback) {\n            callMonitored(postCallCallback, null, [result]);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result;\n    };\n    targetPrototype[method] = instrumentation;\n    return {\n        stop: () => {\n            stopped = true;\n            // If the instrumentation has been removed by a third party, keep the last one\n            if (targetPrototype[method] === instrumentation) {\n                targetPrototype[method] = original;\n            }\n        },\n    };\n}\nexport function instrumentSetter(targetPrototype, property, after) {\n    const originalDescriptor = Object.getOwnPropertyDescriptor(targetPrototype, property);\n    if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n        return { stop: noop };\n    }\n    const stoppedInstrumentation = noop;\n    let instrumentation = (target, value) => {\n        // put hooked setter into event loop to avoid of set latency\n        setTimeout(() => {\n            if (instrumentation !== stoppedInstrumentation) {\n                after(target, value);\n            }\n        }, 0);\n    };\n    const instrumentationWrapper = function (value) {\n        originalDescriptor.set.call(this, value);\n        instrumentation(this, value);\n    };\n    Object.defineProperty(targetPrototype, property, {\n        set: instrumentationWrapper,\n    });\n    return {\n        stop: () => {\n            var _a;\n            if (((_a = Object.getOwnPropertyDescriptor(targetPrototype, property)) === null || _a === void 0 ? void 0 : _a.set) === instrumentationWrapper) {\n                Object.defineProperty(targetPrototype, property, originalDescriptor);\n            }\n            instrumentation = stoppedInstrumentation;\n        },\n    };\n}\n//# sourceMappingURL=instrumentMethod.js.map","import { display } from '../display';\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils';\nimport { detachToJsonMethod } from './jsonStringify';\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nconst SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE;\n// Symbol for the root element of the JSONPath used for visited objects\nconst JSON_PATH_ROOT_ELEMENT = '$';\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nconst KEY_DECORATION_LENGTH = 3;\nexport function sanitize(source, maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT) {\n    // Unbind any toJSON function we may have on [] or {} prototypes\n    const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);\n    const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);\n    // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n    const containerQueue = [];\n    const visitedObjectsWithPath = new WeakMap();\n    const sanitizedData = sanitizeProcessor(source, JSON_PATH_ROOT_ELEMENT, undefined, containerQueue, visitedObjectsWithPath);\n    const serializedSanitizedData = JSON.stringify(sanitizedData);\n    let accumulatedCharacterCount = serializedSanitizedData ? serializedSanitizedData.length : 0;\n    if (accumulatedCharacterCount > maxCharacterCount) {\n        warnOverCharacterLimit(maxCharacterCount, 'discarded', source);\n        return undefined;\n    }\n    while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n        const containerToProcess = containerQueue.shift();\n        let separatorLength = 0; // 0 for the first element, 1 for subsequent elements\n        // Arrays and Objects have to be handled distinctly to ensure\n        // we do not pick up non-numerical properties from Arrays\n        if (Array.isArray(containerToProcess.source)) {\n            for (let key = 0; key < containerToProcess.source.length; key++) {\n                const targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);\n                if (targetData !== undefined) {\n                    accumulatedCharacterCount += JSON.stringify(targetData).length;\n                }\n                else {\n                    // When an element of an Array (targetData) is undefined, it is serialized as null:\n                    // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n                    accumulatedCharacterCount += 4;\n                }\n                accumulatedCharacterCount += separatorLength;\n                separatorLength = 1;\n                if (accumulatedCharacterCount > maxCharacterCount) {\n                    warnOverCharacterLimit(maxCharacterCount, 'truncated', source);\n                    break;\n                }\n                ;\n                containerToProcess.target[key] = targetData;\n            }\n        }\n        else {\n            for (const key in containerToProcess.source) {\n                if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n                    const targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);\n                    // When a property of an object has an undefined value, it will be dropped during serialization:\n                    // JSON.stringify({a:undefined}) => '{}'\n                    if (targetData !== undefined) {\n                        accumulatedCharacterCount +=\n                            JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH;\n                        separatorLength = 1;\n                    }\n                    if (accumulatedCharacterCount > maxCharacterCount) {\n                        warnOverCharacterLimit(maxCharacterCount, 'truncated', source);\n                        break;\n                    }\n                    ;\n                    containerToProcess.target[key] = targetData;\n                }\n            }\n        }\n    }\n    // Rebind detached toJSON functions\n    restoreObjectPrototypeToJson();\n    restoreArrayPrototypeToJson();\n    return sanitizedData;\n}\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(source, parentPath, key, queue, visitedObjectsWithPath) {\n    // Start by handling toJSON, as we want to sanitize its output\n    const sourceToSanitize = tryToApplyToJSON(source);\n    if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n        return sanitizePrimitivesAndFunctions(sourceToSanitize);\n    }\n    const sanitizedSource = sanitizeObjects(sourceToSanitize);\n    if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n        return sanitizedSource;\n    }\n    // Handle potential cyclic references\n    // We need to use source as sourceToSanitize could be a reference to a new object\n    // At this stage, we know the source is an object type\n    const sourceAsObject = source;\n    if (visitedObjectsWithPath.has(sourceAsObject)) {\n        return `[Reference seen at ${visitedObjectsWithPath.get(sourceAsObject)}]`;\n    }\n    // Add processed source to queue\n    const currentPath = key !== undefined ? `${parentPath}.${key}` : parentPath;\n    const target = Array.isArray(sourceToSanitize) ? [] : {};\n    visitedObjectsWithPath.set(sourceAsObject, currentPath);\n    queue.push({ source: sourceToSanitize, target, path: currentPath });\n    return target;\n}\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value) {\n    // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n    if (typeof value === 'bigint') {\n        return `[BigInt] ${value.toString()}`;\n    }\n    // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n    // so it won't prevent stringify from serializing later\n    if (typeof value === 'function') {\n        return `[Function] ${value.name || 'unknown'}`;\n    }\n    // JSON.stringify() does not serialize symbols.\n    if (typeof value === 'symbol') {\n        return `[Symbol] ${value.description || value.toString()}`;\n    }\n    return value;\n}\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n */\nfunction sanitizeObjects(value) {\n    try {\n        if (value instanceof Event) {\n            return sanitizeEvent(value);\n        }\n        if (value instanceof RegExp) {\n            return `[RegExp] ${value.toString()}`;\n        }\n        // Handle all remaining object types in a generic way\n        const result = Object.prototype.toString.call(value);\n        const match = result.match(/\\[object (.*)\\]/);\n        if (match && match[1]) {\n            return `[${match[1]}]`;\n        }\n    }\n    catch (_a) {\n        // If the previous serialization attempts failed, and we cannot convert using\n        // Object.prototype.toString, declare the value unserializable\n    }\n    return '[Unserializable]';\n}\nfunction sanitizeEvent(event) {\n    return {\n        type: event.type,\n        isTrusted: event.isTrusted,\n        currentTarget: event.currentTarget ? sanitizeObjects(event.currentTarget) : null,\n        target: event.target ? sanitizeObjects(event.target) : null,\n    };\n}\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value) {\n    const object = value;\n    if (object && typeof object.toJSON === 'function') {\n        try {\n            return object.toJSON();\n        }\n        catch (_a) {\n            // If toJSON fails, we continue by trying to serialize the value manually\n        }\n    }\n    return value;\n}\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount, changeType, source) {\n    display.warn(`The data provided has been ${changeType} as it is over the limit of ${maxCharacterCount} characters:`, source);\n}\n//# sourceMappingURL=sanitize.js.map","import { sanitize } from '../../tools/serialisation/sanitize';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nexport const NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error';\nexport function computeRawError({ stackTrace, originalError, handlingStack, componentStack, startClocks, nonErrorPrefix, source, handling, }) {\n    const isErrorInstance = isError(originalError);\n    const message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError);\n    const stack = hasUsableStack(isErrorInstance, stackTrace)\n        ? toStackTraceString(stackTrace)\n        : NO_ERROR_STACK_PRESENT_MESSAGE;\n    const causes = isErrorInstance ? flattenErrorCauses(originalError, source) : undefined;\n    const type = stackTrace ? stackTrace.name : undefined;\n    const fingerprint = tryToGetFingerprint(originalError);\n    const context = tryToGetErrorContext(originalError);\n    return {\n        startClocks,\n        source,\n        handling,\n        handlingStack,\n        componentStack,\n        originalError,\n        type,\n        message,\n        stack,\n        causes,\n        fingerprint,\n        context,\n    };\n}\nfunction computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError) {\n    // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)\n    // TODO rework tracekit integration to avoid scattering error building logic\n    return (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.message) && (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name)\n        ? stackTrace.message\n        : !isErrorInstance\n            ? `${nonErrorPrefix} ${jsonStringify(sanitize(originalError))}`\n            : 'Empty message';\n}\nfunction hasUsableStack(isErrorInstance, stackTrace) {\n    if (stackTrace === undefined) {\n        return false;\n    }\n    if (isErrorInstance) {\n        return true;\n    }\n    // handle cases where tracekit return stack = [] or stack = [{url: undefined, line: undefined, column: undefined}]\n    // TODO rework tracekit integration to avoid generating those unusable stack\n    return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== undefined);\n}\nexport function tryToGetFingerprint(originalError) {\n    return isError(originalError) && 'dd_fingerprint' in originalError ? String(originalError.dd_fingerprint) : undefined;\n}\nexport function tryToGetErrorContext(originalError) {\n    if (originalError !== null && typeof originalError === 'object' && 'dd_context' in originalError) {\n        return originalError.dd_context;\n    }\n}\nexport function getFileFromStackTraceString(stack) {\n    var _a;\n    return (_a = /@ (.+)/.exec(stack)) === null || _a === void 0 ? void 0 : _a[1];\n}\nexport function isError(error) {\n    return error instanceof Error || Object.prototype.toString.call(error) === '[object Error]';\n}\nexport function flattenErrorCauses(error, parentSource) {\n    let currentError = error;\n    const causes = [];\n    while (isError(currentError === null || currentError === void 0 ? void 0 : currentError.cause) && causes.length < 10) {\n        const stackTrace = computeStackTrace(currentError.cause);\n        causes.push({\n            message: currentError.cause.message,\n            source: parentSource,\n            type: stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name,\n            stack: stackTrace && toStackTraceString(stackTrace),\n        });\n        currentError = currentError.cause;\n    }\n    return causes.length ? causes : undefined;\n}\n//# sourceMappingURL=error.js.map","export const ErrorSource = {\n    AGENT: 'agent',\n    CONSOLE: 'console',\n    CUSTOM: 'custom',\n    LOGGER: 'logger',\n    NETWORK: 'network',\n    SOURCE: 'source',\n    REPORT: 'report',\n};\n//# sourceMappingURL=error.types.js.map","import { instrumentMethod } from '../../tools/instrumentMethod';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nimport { computeStackTrace, computeStackTraceFromOnErrorMessage } from '../../tools/stackTrace/computeStackTrace';\nimport { computeRawError, isError } from './error';\nimport { ErrorSource } from './error.types';\nexport function trackRuntimeError(errorObservable) {\n    const handleRuntimeError = (stackTrace, originalError) => {\n        const rawError = computeRawError({\n            stackTrace,\n            originalError,\n            startClocks: clocksNow(),\n            nonErrorPrefix: \"Uncaught\" /* NonErrorPrefix.UNCAUGHT */,\n            source: ErrorSource.SOURCE,\n            handling: \"unhandled\" /* ErrorHandling.UNHANDLED */,\n        });\n        errorObservable.notify(rawError);\n    };\n    const { stop: stopInstrumentingOnError } = instrumentOnError(handleRuntimeError);\n    const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(handleRuntimeError);\n    return {\n        stop: () => {\n            stopInstrumentingOnError();\n            stopInstrumentingOnUnhandledRejection();\n        },\n    };\n}\nexport function instrumentOnError(callback) {\n    return instrumentMethod(window, 'onerror', ({ parameters: [messageObj, url, line, column, errorObj] }) => {\n        let stackTrace;\n        if (isError(errorObj)) {\n            stackTrace = computeStackTrace(errorObj);\n        }\n        else {\n            stackTrace = computeStackTraceFromOnErrorMessage(messageObj, url, line, column);\n        }\n        callback(stackTrace, errorObj !== null && errorObj !== void 0 ? errorObj : messageObj);\n    });\n}\nexport function instrumentUnhandledRejection(callback) {\n    return instrumentMethod(window, 'onunhandledrejection', ({ parameters: [e] }) => {\n        const reason = e.reason || 'Empty reason';\n        const stack = computeStackTrace(reason);\n        callback(stack, reason);\n    });\n}\n//# sourceMappingURL=trackRuntimeError.js.map","import { display } from '../tools/display';\nexport function displayAlreadyInitializedError(sdkName, initConfiguration) {\n    if (!initConfiguration.silentMultipleInit) {\n        display.error(`${sdkName} is already initialized.`);\n    }\n}\n//# sourceMappingURL=displayAlreadyInitializedError.js.map","import { monitor } from '../tools/monitor';\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue';\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener(configuration, eventTarget, eventName, listener, options) {\n    return addEventListeners(configuration, eventTarget, [eventName], listener, options);\n}\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners(configuration, eventTarget, eventNames, listener, { once, capture, passive } = {}) {\n    const listenerWithMonitor = monitor((event) => {\n        if (!event.isTrusted && !event.__ddIsTrusted && !configuration.allowUntrustedEvents) {\n            return;\n        }\n        if (once) {\n            stop();\n        }\n        listener(event);\n    });\n    const options = passive ? { capture, passive } : capture;\n    // Use the window.EventTarget.prototype when possible to avoid wrong overrides (e.g: https://github.com/salesforce/lwc/issues/1824)\n    const listenerTarget = window.EventTarget && eventTarget instanceof EventTarget ? window.EventTarget.prototype : eventTarget;\n    const add = getZoneJsOriginalValue(listenerTarget, 'addEventListener');\n    eventNames.forEach((eventName) => add.call(eventTarget, eventName, listenerWithMonitor, options));\n    function stop() {\n        const remove = getZoneJsOriginalValue(listenerTarget, 'removeEventListener');\n        eventNames.forEach((eventName) => remove.call(eventTarget, eventName, listenerWithMonitor, options));\n    }\n    return {\n        stop,\n    };\n}\n//# sourceMappingURL=addEventListener.js.map","import { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nimport { monitor } from '../../tools/monitor';\nimport { mergeObservables, Observable } from '../../tools/observable';\nimport { addEventListener } from '../../browser/addEventListener';\nimport { safeTruncate } from '../../tools/utils/stringUtils';\nimport { ErrorSource } from '../error/error.types';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nexport const RawReportType = {\n    intervention: 'intervention',\n    deprecation: 'deprecation',\n    cspViolation: 'csp_violation',\n};\nexport function initReportObservable(configuration, apis) {\n    const observables = [];\n    if (apis.includes(RawReportType.cspViolation)) {\n        observables.push(createCspViolationReportObservable(configuration));\n    }\n    const reportTypes = apis.filter((api) => api !== RawReportType.cspViolation);\n    if (reportTypes.length) {\n        observables.push(createReportObservable(reportTypes));\n    }\n    return mergeObservables(...observables);\n}\nfunction createReportObservable(reportTypes) {\n    return new Observable((observable) => {\n        if (!window.ReportingObserver) {\n            return;\n        }\n        const handleReports = monitor((reports, _) => reports.forEach((report) => observable.notify(buildRawReportErrorFromReport(report))));\n        const observer = new window.ReportingObserver(handleReports, {\n            types: reportTypes,\n            buffered: true,\n        });\n        observer.observe();\n        return () => {\n            observer.disconnect();\n        };\n    });\n}\nfunction createCspViolationReportObservable(configuration) {\n    return new Observable((observable) => {\n        const { stop } = addEventListener(configuration, document, \"securitypolicyviolation\" /* DOM_EVENT.SECURITY_POLICY_VIOLATION */, (event) => {\n            observable.notify(buildRawReportErrorFromCspViolation(event));\n        });\n        return stop;\n    });\n}\nfunction buildRawReportErrorFromReport(report) {\n    const { type, body } = report;\n    return buildRawReportError({\n        type: body.id,\n        message: `${type}: ${body.message}`,\n        originalError: report,\n        stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n    });\n}\nfunction buildRawReportErrorFromCspViolation(event) {\n    const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`;\n    return buildRawReportError({\n        type: event.effectiveDirective,\n        message: `${RawReportType.cspViolation}: ${message}`,\n        originalError: event,\n        csp: {\n            disposition: event.disposition,\n        },\n        stack: buildStack(event.effectiveDirective, event.originalPolicy\n            ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n            : 'no policy', event.sourceFile, event.lineNumber, event.columnNumber),\n    });\n}\nfunction buildRawReportError(partial) {\n    return {\n        startClocks: clocksNow(),\n        source: ErrorSource.REPORT,\n        handling: \"unhandled\" /* ErrorHandling.UNHANDLED */,\n        ...partial,\n    };\n}\nfunction buildStack(name, message, sourceFile, lineNumber, columnNumber) {\n    return sourceFile\n        ? toStackTraceString({\n            name,\n            message,\n            stack: [\n                {\n                    func: '?',\n                    url: sourceFile,\n                    line: lineNumber !== null && lineNumber !== void 0 ? lineNumber : undefined,\n                    column: columnNumber !== null && columnNumber !== void 0 ? columnNumber : undefined,\n                },\n            ],\n        })\n        : undefined;\n}\n//# sourceMappingURL=reportObservable.js.map","export function sendToExtension(type, payload) {\n    const callback = window.__ddBrowserSdkExtensionCallback;\n    if (callback) {\n        callback({ type, payload });\n    }\n}\n//# sourceMappingURL=sendToExtension.js.map","/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value) {\n    if (value === null) {\n        return 'null';\n    }\n    if (Array.isArray(value)) {\n        return 'array';\n    }\n    return typeof value;\n}\n//# sourceMappingURL=typeUtils.js.map","import { getType } from './utils/typeUtils';\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto(destination, source, circularReferenceChecker = createCircularReferenceChecker()) {\n    // ignore the source if it is undefined\n    if (source === undefined) {\n        return destination;\n    }\n    if (typeof source !== 'object' || source === null) {\n        // primitive values - just return source\n        return source;\n    }\n    else if (source instanceof Date) {\n        return new Date(source.getTime());\n    }\n    else if (source instanceof RegExp) {\n        const flags = source.flags ||\n            // old browsers compatibility\n            [\n                source.global ? 'g' : '',\n                source.ignoreCase ? 'i' : '',\n                source.multiline ? 'm' : '',\n                source.sticky ? 'y' : '',\n                source.unicode ? 'u' : '',\n            ].join('');\n        return new RegExp(source.source, flags);\n    }\n    if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n        // remove circular references\n        return undefined;\n    }\n    else if (Array.isArray(source)) {\n        const merged = Array.isArray(destination) ? destination : [];\n        for (let i = 0; i < source.length; ++i) {\n            merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker);\n        }\n        return merged;\n    }\n    const merged = getType(destination) === 'object' ? destination : {};\n    for (const key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker);\n        }\n    }\n    return merged;\n}\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone(value) {\n    return mergeInto(undefined, value);\n}\nexport function combine(...sources) {\n    let destination;\n    for (const source of sources) {\n        // Ignore any undefined or null sources.\n        if (source === undefined || source === null) {\n            continue;\n        }\n        destination = mergeInto(destination, source);\n    }\n    return destination;\n}\nfunction createCircularReferenceChecker() {\n    if (typeof WeakSet !== 'undefined') {\n        const set = new WeakSet();\n        return {\n            hasAlreadyBeenSeen(value) {\n                const has = set.has(value);\n                if (!has) {\n                    set.add(value);\n                }\n                return has;\n            },\n        };\n    }\n    const array = [];\n    return {\n        hasAlreadyBeenSeen(value) {\n            const has = array.indexOf(value) >= 0;\n            if (!has) {\n                array.push(value);\n            }\n            return has;\n        },\n    };\n}\n//# sourceMappingURL=mergeInto.js.map","export function getConnectivity() {\n    var _a;\n    const navigator = window.navigator;\n    return {\n        status: navigator.onLine ? 'connected' : 'not_connected',\n        interfaces: navigator.connection && navigator.connection.type ? [navigator.connection.type] : undefined,\n        effective_type: (_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.effectiveType,\n    };\n}\n//# sourceMappingURL=connectivity.js.map","export function removeDuplicates(array) {\n    const set = new Set();\n    array.forEach((item) => set.add(item));\n    return Array.from(set);\n}\nexport function removeItem(array, item) {\n    const index = array.indexOf(item);\n    if (index >= 0) {\n        array.splice(index, 1);\n    }\n}\n//# sourceMappingURL=arrayUtils.js.map","import { removeItem } from './utils/arrayUtils';\nconst BUFFER_LIMIT = 500;\nexport function createBoundedBuffer() {\n    const buffer = [];\n    const add = (callback) => {\n        const length = buffer.push(callback);\n        if (length > BUFFER_LIMIT) {\n            buffer.splice(0, 1);\n        }\n    };\n    const remove = (callback) => {\n        removeItem(buffer, callback);\n    };\n    const drain = (arg) => {\n        buffer.forEach((callback) => callback(arg));\n        buffer.length = 0;\n    };\n    return {\n        add,\n        remove,\n        drain,\n    };\n}\n//# sourceMappingURL=boundedBuffer.js.map","export const TelemetryType = {\n    log: 'log',\n    configuration: 'configuration',\n    usage: 'usage',\n};\n//# sourceMappingURL=rawTelemetryEvent.types.js.map","import { ConsoleApiName } from '../../tools/display';\nimport { NO_ERROR_STACK_PRESENT_MESSAGE, isError } from '../error/error';\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures';\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration';\nimport { Observable } from '../../tools/observable';\nimport { timeStampNow } from '../../tools/utils/timeUtils';\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor';\nimport { sendToExtension } from '../../tools/sendToExtension';\nimport { performDraw } from '../../tools/utils/numberUtils';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { combine } from '../../tools/mergeInto';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { getConnectivity } from '../connectivity';\nimport { createBoundedBuffer } from '../../tools/boundedBuffer';\nimport { TelemetryType } from './rawTelemetryEvent.types';\nconst ALLOWED_FRAME_URLS = [\n    'https://www.datadoghq-browser-agent.com',\n    'https://www.datad0g-browser-agent.com',\n    'https://d3uc069fcn7uxw.cloudfront.net',\n    'https://d20xtzwzcl0ceb.cloudfront.net',\n    'http://localhost',\n    '<anonymous>',\n];\nconst TELEMETRY_EXCLUDED_SITES = [INTAKE_SITE_US1_FED];\n// eslint-disable-next-line local-rules/disallow-side-effects\nlet preStartTelemetryBuffer = createBoundedBuffer();\nlet onRawTelemetryEventCollected = (event) => {\n    preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event));\n};\nexport function startTelemetry(telemetryService, configuration) {\n    let contextProvider;\n    const observable = new Observable();\n    const alreadySentEvents = new Set();\n    const telemetryEnabled = !TELEMETRY_EXCLUDED_SITES.includes(configuration.site) && performDraw(configuration.telemetrySampleRate);\n    const telemetryEnabledPerType = {\n        [TelemetryType.log]: telemetryEnabled,\n        [TelemetryType.configuration]: telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate),\n        [TelemetryType.usage]: telemetryEnabled && performDraw(configuration.telemetryUsageSampleRate),\n    };\n    const runtimeEnvInfo = getRuntimeEnvInfo();\n    onRawTelemetryEventCollected = (rawEvent) => {\n        const stringifiedEvent = jsonStringify(rawEvent);\n        if (telemetryEnabledPerType[rawEvent.type] &&\n            alreadySentEvents.size < configuration.maxTelemetryEventsPerPage &&\n            !alreadySentEvents.has(stringifiedEvent)) {\n            const event = toTelemetryEvent(telemetryService, rawEvent, runtimeEnvInfo);\n            observable.notify(event);\n            sendToExtension('telemetry', event);\n            alreadySentEvents.add(stringifiedEvent);\n        }\n    };\n    startMonitorErrorCollection(addTelemetryError);\n    function toTelemetryEvent(telemetryService, event, runtimeEnvInfo) {\n        return combine({\n            type: 'telemetry',\n            date: timeStampNow(),\n            service: telemetryService,\n            version: \"6.4.0\",\n            source: 'browser',\n            _dd: {\n                format_version: 2,\n            },\n            telemetry: combine(event, {\n                runtime_env: runtimeEnvInfo,\n                connectivity: getConnectivity(),\n                sdk_setup: \"npm\",\n            }),\n            experimental_features: Array.from(getExperimentalFeatures()),\n        }, contextProvider !== undefined ? contextProvider() : {});\n    }\n    return {\n        setContextProvider: (provider) => {\n            contextProvider = provider;\n        },\n        observable,\n        enabled: telemetryEnabled,\n    };\n}\nfunction getRuntimeEnvInfo() {\n    return {\n        is_local_file: window.location.protocol === 'file:',\n        is_worker: 'WorkerGlobalScope' in self,\n    };\n}\nexport function startFakeTelemetry() {\n    const events = [];\n    onRawTelemetryEventCollected = (event) => {\n        events.push(event);\n    };\n    return events;\n}\n// need to be called after telemetry context is provided and observers are registered\nexport function drainPreStartTelemetry() {\n    preStartTelemetryBuffer.drain();\n}\nexport function resetTelemetry() {\n    preStartTelemetryBuffer = createBoundedBuffer();\n    onRawTelemetryEventCollected = (event) => {\n        preStartTelemetryBuffer.add(() => onRawTelemetryEventCollected(event));\n    };\n}\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration) {\n    return configuration.site === INTAKE_SITE_STAGING;\n}\nexport function addTelemetryDebug(message, context) {\n    displayIfDebugEnabled(ConsoleApiName.debug, message, context);\n    onRawTelemetryEventCollected({\n        type: TelemetryType.log,\n        message,\n        status: \"debug\" /* StatusType.debug */,\n        ...context,\n    });\n}\nexport function addTelemetryError(e, context) {\n    onRawTelemetryEventCollected({\n        type: TelemetryType.log,\n        status: \"error\" /* StatusType.error */,\n        ...formatError(e),\n        ...context,\n    });\n}\nexport function addTelemetryConfiguration(configuration) {\n    onRawTelemetryEventCollected({\n        type: TelemetryType.configuration,\n        configuration,\n    });\n}\nexport function addTelemetryUsage(usage) {\n    onRawTelemetryEventCollected({\n        type: TelemetryType.usage,\n        usage,\n    });\n}\nexport function formatError(e) {\n    if (isError(e)) {\n        const stackTrace = computeStackTrace(e);\n        return {\n            error: {\n                kind: stackTrace.name,\n                stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n            },\n            message: stackTrace.message,\n        };\n    }\n    return {\n        error: {\n            stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n        },\n        message: `${\"Uncaught\" /* NonErrorPrefix.UNCAUGHT */} ${jsonStringify(e)}`,\n    };\n}\nexport function scrubCustomerFrames(stackTrace) {\n    stackTrace.stack = stackTrace.stack.filter((frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => frame.url.startsWith(allowedFrameUrl)));\n    return stackTrace;\n}\n//# sourceMappingURL=telemetry.js.map","import { setInterval, clearInterval } from './timer';\nimport { removeItem } from './utils/arrayUtils';\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils';\nconst END_OF_TIMES = Infinity;\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE;\nlet cleanupHistoriesInterval = null;\nconst cleanupTasks = new Set();\nfunction cleanupHistories() {\n    cleanupTasks.forEach((task) => task());\n}\nexport function createValueHistory({ expireDelay, maxEntries, }) {\n    let entries = [];\n    const deletedEntries = [];\n    if (!cleanupHistoriesInterval) {\n        cleanupHistoriesInterval = setInterval(() => cleanupHistories(), CLEAR_OLD_VALUES_INTERVAL);\n    }\n    const clearExpiredValues = () => {\n        const oldTimeThreshold = relativeNow() - expireDelay;\n        while (entries.length > 0 && entries[entries.length - 1].endTime < oldTimeThreshold) {\n            const entry = entries.pop();\n            if (entry) {\n                deletedEntries.push(entry.startTime);\n            }\n        }\n    };\n    cleanupTasks.add(clearExpiredValues);\n    /**\n     * Add a value to the history associated with a start time. Returns a reference to this newly\n     * added entry that can be removed or closed.\n     */\n    function add(value, startTime) {\n        const entry = {\n            value,\n            startTime,\n            endTime: END_OF_TIMES,\n            remove: () => {\n                removeItem(entries, entry);\n            },\n            close: (endTime) => {\n                entry.endTime = endTime;\n            },\n        };\n        if (maxEntries && entries.length >= maxEntries) {\n            entries.pop();\n        }\n        entries.unshift(entry);\n        return entry;\n    }\n    /**\n     * Return the latest value that was active during `startTime`, or the currently active value\n     * if no `startTime` is provided. This method assumes that entries are not overlapping.\n     *\n     * If `option.returnInactive` is true, returns the value at `startTime` (active or not).\n     */\n    function find(startTime = END_OF_TIMES, options = { returnInactive: false }) {\n        for (const entry of entries) {\n            if (entry.startTime <= startTime) {\n                if (options.returnInactive || startTime <= entry.endTime) {\n                    return entry.value;\n                }\n                break;\n            }\n        }\n    }\n    /**\n     * Helper function to close the currently active value, if any. This method assumes that entries\n     * are not overlapping.\n     */\n    function closeActive(endTime) {\n        const latestEntry = entries[0];\n        if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n            latestEntry.close(endTime);\n        }\n    }\n    /**\n     * Return all values with an active period overlapping with the duration,\n     * or all values that were active during `startTime` if no duration is provided,\n     * or all currently active values if no `startTime` is provided.\n     */\n    function findAll(startTime = END_OF_TIMES, duration = 0) {\n        const endTime = addDuration(startTime, duration);\n        return entries\n            .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n            .map((entry) => entry.value);\n    }\n    function getAllEntries() {\n        return entries.map(({ startTime, endTime, value }) => ({\n            startTime,\n            endTime: endTime === END_OF_TIMES ? 'Infinity' : endTime,\n            value,\n        }));\n    }\n    function getDeletedEntries() {\n        return deletedEntries;\n    }\n    /**\n     * Remove all entries from this collection.\n     */\n    function reset() {\n        entries = [];\n    }\n    /**\n     * Stop internal garbage collection of past entries.\n     */\n    function stop() {\n        cleanupTasks.delete(clearExpiredValues);\n        if (cleanupTasks.size === 0 && cleanupHistoriesInterval) {\n            clearInterval(cleanupHistoriesInterval);\n            cleanupHistoriesInterval = null;\n        }\n    }\n    return { add, find, closeActive, findAll, reset, stop, getAllEntries, getDeletedEntries };\n}\n//# sourceMappingURL=valueHistory.js.map","import { Observable } from '../../tools/observable';\nimport { createValueHistory } from '../../tools/valueHistory';\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils';\nimport { addEventListener, addEventListeners } from '../../browser/addEventListener';\nimport { clearInterval, setInterval } from '../../tools/timer';\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants';\nimport { startSessionStore } from './sessionStore';\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE;\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY;\nlet stopCallbacks = [];\nexport function startSessionManager(configuration, productKey, computeSessionState, trackingConsentState) {\n    const renewObservable = new Observable();\n    const expireObservable = new Observable();\n    // TODO - Improve configuration type and remove assertion\n    const sessionStore = startSessionStore(configuration.sessionStoreStrategyType, configuration, productKey, computeSessionState);\n    stopCallbacks.push(() => sessionStore.stop());\n    const sessionContextHistory = createValueHistory({\n        expireDelay: SESSION_CONTEXT_TIMEOUT_DELAY,\n    });\n    stopCallbacks.push(() => sessionContextHistory.stop());\n    sessionStore.renewObservable.subscribe(() => {\n        sessionContextHistory.add(buildSessionContext(), relativeNow());\n        renewObservable.notify();\n    });\n    sessionStore.expireObservable.subscribe(() => {\n        expireObservable.notify();\n        sessionContextHistory.closeActive(relativeNow());\n    });\n    // We expand/renew session unconditionally as tracking consent is always granted when the session\n    // manager is started.\n    sessionStore.expandOrRenewSession();\n    sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative);\n    trackingConsentState.observable.subscribe(() => {\n        if (trackingConsentState.isGranted()) {\n            sessionStore.expandOrRenewSession();\n        }\n        else {\n            sessionStore.expire();\n        }\n    });\n    trackActivity(configuration, () => {\n        if (trackingConsentState.isGranted()) {\n            sessionStore.expandOrRenewSession();\n        }\n    });\n    trackVisibility(configuration, () => sessionStore.expandSession());\n    trackResume(configuration, () => sessionStore.restartSession());\n    function buildSessionContext() {\n        return {\n            id: sessionStore.getSession().id,\n            trackingType: sessionStore.getSession()[productKey],\n            isReplayForced: !!sessionStore.getSession().forcedReplay,\n            anonymousId: sessionStore.getSession().anonymousId,\n        };\n    }\n    return {\n        findSession: (startTime, options) => sessionContextHistory.find(startTime, options),\n        renewObservable,\n        expireObservable,\n        sessionStateUpdateObservable: sessionStore.sessionStateUpdateObservable,\n        expire: sessionStore.expire,\n        updateSessionState: sessionStore.updateSessionState,\n    };\n}\nexport function stopSessionManager() {\n    stopCallbacks.forEach((e) => e());\n    stopCallbacks = [];\n}\nfunction trackActivity(configuration, expandOrRenewSession) {\n    const { stop } = addEventListeners(configuration, window, [\"click\" /* DOM_EVENT.CLICK */, \"touchstart\" /* DOM_EVENT.TOUCH_START */, \"keydown\" /* DOM_EVENT.KEY_DOWN */, \"scroll\" /* DOM_EVENT.SCROLL */], expandOrRenewSession, { capture: true, passive: true });\n    stopCallbacks.push(stop);\n}\nfunction trackVisibility(configuration, expandSession) {\n    const expandSessionWhenVisible = () => {\n        if (document.visibilityState === 'visible') {\n            expandSession();\n        }\n    };\n    const { stop } = addEventListener(configuration, document, \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, expandSessionWhenVisible);\n    stopCallbacks.push(stop);\n    const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY);\n    stopCallbacks.push(() => {\n        clearInterval(visibilityCheckInterval);\n    });\n}\nfunction trackResume(configuration, cb) {\n    const { stop } = addEventListener(configuration, window, \"resume\" /* DOM_EVENT.RESUME */, cb, { capture: true });\n    stopCallbacks.push(stop);\n}\n//# sourceMappingURL=sessionManager.js.map","import { setTimeout } from '../tools/timer';\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils';\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils';\nimport { isServerError } from '../tools/utils/responseUtils';\nimport { ErrorSource } from '../domain/error/error.types';\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE;\nexport const MAX_ONGOING_REQUESTS = 32;\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE;\nexport const MAX_BACKOFF_TIME = ONE_MINUTE;\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND;\nexport function sendWithRetryStrategy(payload, state, sendStrategy, trackType, reportError) {\n    if (state.transportStatus === 0 /* TransportStatus.UP */ &&\n        state.queuedPayloads.size() === 0 &&\n        state.bandwidthMonitor.canHandle(payload)) {\n        send(payload, state, sendStrategy, {\n            onSuccess: () => retryQueuedPayloads(0 /* RetryReason.AFTER_SUCCESS */, state, sendStrategy, trackType, reportError),\n            onFailure: () => {\n                state.queuedPayloads.enqueue(payload);\n                scheduleRetry(state, sendStrategy, trackType, reportError);\n            },\n        });\n    }\n    else {\n        state.queuedPayloads.enqueue(payload);\n    }\n}\nfunction scheduleRetry(state, sendStrategy, trackType, reportError) {\n    if (state.transportStatus !== 2 /* TransportStatus.DOWN */) {\n        return;\n    }\n    setTimeout(() => {\n        const payload = state.queuedPayloads.first();\n        send(payload, state, sendStrategy, {\n            onSuccess: () => {\n                state.queuedPayloads.dequeue();\n                state.currentBackoffTime = INITIAL_BACKOFF_TIME;\n                retryQueuedPayloads(1 /* RetryReason.AFTER_RESUME */, state, sendStrategy, trackType, reportError);\n            },\n            onFailure: () => {\n                state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);\n                scheduleRetry(state, sendStrategy, trackType, reportError);\n            },\n        });\n    }, state.currentBackoffTime);\n}\nfunction send(payload, state, sendStrategy, { onSuccess, onFailure }) {\n    state.bandwidthMonitor.add(payload);\n    sendStrategy(payload, (response) => {\n        state.bandwidthMonitor.remove(payload);\n        if (!shouldRetryRequest(response)) {\n            state.transportStatus = 0 /* TransportStatus.UP */;\n            onSuccess();\n        }\n        else {\n            // do not consider transport down if another ongoing request could succeed\n            state.transportStatus =\n                state.bandwidthMonitor.ongoingRequestCount > 0 ? 1 /* TransportStatus.FAILURE_DETECTED */ : 2 /* TransportStatus.DOWN */;\n            payload.retry = {\n                count: payload.retry ? payload.retry.count + 1 : 1,\n                lastFailureStatus: response.status,\n            };\n            onFailure();\n        }\n    });\n}\nfunction retryQueuedPayloads(reason, state, sendStrategy, trackType, reportError) {\n    if (reason === 0 /* RetryReason.AFTER_SUCCESS */ && state.queuedPayloads.isFull() && !state.queueFullReported) {\n        reportError({\n            message: `Reached max ${trackType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n        });\n        state.queueFullReported = true;\n    }\n    const previousQueue = state.queuedPayloads;\n    state.queuedPayloads = newPayloadQueue();\n    while (previousQueue.size() > 0) {\n        sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, trackType, reportError);\n    }\n}\nfunction shouldRetryRequest(response) {\n    return (response.type !== 'opaque' &&\n        ((response.status === 0 && !navigator.onLine) ||\n            response.status === 408 ||\n            response.status === 429 ||\n            isServerError(response.status)));\n}\nexport function newRetryState() {\n    return {\n        transportStatus: 0 /* TransportStatus.UP */,\n        currentBackoffTime: INITIAL_BACKOFF_TIME,\n        bandwidthMonitor: newBandwidthMonitor(),\n        queuedPayloads: newPayloadQueue(),\n        queueFullReported: false,\n    };\n}\nfunction newPayloadQueue() {\n    const queue = [];\n    return {\n        bytesCount: 0,\n        enqueue(payload) {\n            if (this.isFull()) {\n                return;\n            }\n            queue.push(payload);\n            this.bytesCount += payload.bytesCount;\n        },\n        first() {\n            return queue[0];\n        },\n        dequeue() {\n            const payload = queue.shift();\n            if (payload) {\n                this.bytesCount -= payload.bytesCount;\n            }\n            return payload;\n        },\n        size() {\n            return queue.length;\n        },\n        isFull() {\n            return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;\n        },\n    };\n}\nfunction newBandwidthMonitor() {\n    return {\n        ongoingRequestCount: 0,\n        ongoingByteCount: 0,\n        canHandle(payload) {\n            return (this.ongoingRequestCount === 0 ||\n                (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n                    this.ongoingRequestCount < MAX_ONGOING_REQUESTS));\n        },\n        add(payload) {\n            this.ongoingRequestCount += 1;\n            this.ongoingByteCount += payload.bytesCount;\n        },\n        remove(payload) {\n            this.ongoingRequestCount -= 1;\n            this.ongoingByteCount -= payload.bytesCount;\n        },\n    };\n}\n//# sourceMappingURL=sendWithRetryStrategy.js.map","export function isServerError(status) {\n    return status >= 500;\n}\nexport function tryToClone(response) {\n    try {\n        return response.clone();\n    }\n    catch (_a) {\n        // clone can throw if the response has already been used by another instrumentation or is disturbed\n        return;\n    }\n}\n//# sourceMappingURL=responseUtils.js.map","import { addTelemetryError } from '../domain/telemetry';\nimport { monitor } from '../tools/monitor';\nimport { addEventListener } from '../browser/addEventListener';\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy';\nexport function createHttpRequest(endpointBuilder, bytesLimit, reportError) {\n    const retryState = newRetryState();\n    const sendStrategyForRetry = (payload, onResponse) => fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);\n    return {\n        send: (payload) => {\n            sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.trackType, reportError);\n        },\n        /**\n         * Since fetch keepalive behaves like regular fetch on Firefox,\n         * keep using sendBeaconStrategy on exit\n         */\n        sendOnExit: (payload) => {\n            sendBeaconStrategy(endpointBuilder, bytesLimit, payload);\n        },\n    };\n}\nfunction sendBeaconStrategy(endpointBuilder, bytesLimit, payload) {\n    const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit;\n    if (canUseBeacon) {\n        try {\n            const beaconUrl = endpointBuilder.build('beacon', payload);\n            const isQueued = navigator.sendBeacon(beaconUrl, payload.data);\n            if (isQueued) {\n                return;\n            }\n        }\n        catch (e) {\n            reportBeaconError(e);\n        }\n    }\n    const xhrUrl = endpointBuilder.build('xhr', payload);\n    sendXHR(xhrUrl, payload.data);\n}\nlet hasReportedBeaconError = false;\nfunction reportBeaconError(e) {\n    if (!hasReportedBeaconError) {\n        hasReportedBeaconError = true;\n        addTelemetryError(e);\n    }\n}\nexport function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse) {\n    const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit;\n    if (canUseKeepAlive) {\n        const fetchUrl = endpointBuilder.build('fetch', payload);\n        fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' }).then(monitor((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })), monitor(() => {\n            const xhrUrl = endpointBuilder.build('xhr', payload);\n            // failed to queue the request\n            sendXHR(xhrUrl, payload.data, onResponse);\n        }));\n    }\n    else {\n        const xhrUrl = endpointBuilder.build('xhr', payload);\n        sendXHR(xhrUrl, payload.data, onResponse);\n    }\n}\nfunction isKeepAliveSupported() {\n    // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n    try {\n        return window.Request && 'keepalive' in new Request('http://a');\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function sendXHR(url, data, onResponse) {\n    const request = new XMLHttpRequest();\n    request.open('POST', url, true);\n    if (data instanceof Blob) {\n        // When using a Blob instance, IE does not use its 'type' to define the 'Content-Type' header\n        // automatically, so the intake request ends up being rejected with an HTTP status 415\n        // Defining the header manually fixes this issue.\n        request.setRequestHeader('Content-Type', data.type);\n    }\n    addEventListener(\n    // allow untrusted event to acount for synthetic event dispatched by third party xhr wrapper\n    { allowUntrustedEvents: true }, request, 'loadend', () => {\n        onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: request.status });\n    }, {\n        // prevent multiple onResponse callbacks\n        // if the xhr instance is reused by a third party\n        once: true,\n    });\n    request.send(data);\n}\n//# sourceMappingURL=httpRequest.js.map","import { getGlobalObject } from '../tools/getGlobalObject';\nexport function getEventBridge() {\n    const eventBridgeGlobal = getEventBridgeGlobal();\n    if (!eventBridgeGlobal) {\n        return;\n    }\n    return {\n        getCapabilities() {\n            var _a;\n            return JSON.parse(((_a = eventBridgeGlobal.getCapabilities) === null || _a === void 0 ? void 0 : _a.call(eventBridgeGlobal)) || '[]');\n        },\n        getPrivacyLevel() {\n            var _a;\n            return (_a = eventBridgeGlobal.getPrivacyLevel) === null || _a === void 0 ? void 0 : _a.call(eventBridgeGlobal);\n        },\n        getAllowedWebViewHosts() {\n            return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts());\n        },\n        send(eventType, event, viewId) {\n            const view = viewId ? { id: viewId } : undefined;\n            eventBridgeGlobal.send(JSON.stringify({ eventType, event, view }));\n        },\n    };\n}\nexport function bridgeSupports(capability) {\n    const bridge = getEventBridge();\n    return !!bridge && bridge.getCapabilities().includes(capability);\n}\nexport function canUseEventBridge(currentHost) {\n    var _a;\n    if (currentHost === void 0) { currentHost = (_a = getGlobalObject().location) === null || _a === void 0 ? void 0 : _a.hostname; }\n    const bridge = getEventBridge();\n    return (!!bridge &&\n        bridge\n            .getAllowedWebViewHosts()\n            .some((allowedHost) => currentHost === allowedHost || currentHost.endsWith(`.${allowedHost}`)));\n}\nfunction getEventBridgeGlobal() {\n    return getGlobalObject().DatadogEventBridge;\n}\n//# sourceMappingURL=eventBridge.js.map","import { Observable } from '../tools/observable';\nimport { objectValues } from '../tools/utils/polyfills';\nimport { addEventListeners, addEventListener } from './addEventListener';\nexport const PageExitReason = {\n    HIDDEN: 'visibility_hidden',\n    UNLOADING: 'before_unload',\n    PAGEHIDE: 'page_hide',\n    FROZEN: 'page_frozen',\n};\nexport function createPageExitObservable(configuration) {\n    return new Observable((observable) => {\n        const { stop: stopListeners } = addEventListeners(configuration, window, [\"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, \"freeze\" /* DOM_EVENT.FREEZE */], (event) => {\n            if (event.type === \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */ && document.visibilityState === 'hidden') {\n                /**\n                 * Only event that guarantee to fire on mobile devices when the page transitions to background state\n                 * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n                 */\n                observable.notify({ reason: PageExitReason.HIDDEN });\n            }\n            else if (event.type === \"freeze\" /* DOM_EVENT.FREEZE */) {\n                /**\n                 * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n                 * Allow to collect events happening between hidden and frozen state.\n                 */\n                observable.notify({ reason: PageExitReason.FROZEN });\n            }\n        }, { capture: true });\n        const stopBeforeUnloadListener = addEventListener(configuration, window, \"beforeunload\" /* DOM_EVENT.BEFORE_UNLOAD */, () => {\n            observable.notify({ reason: PageExitReason.UNLOADING });\n        }).stop;\n        return () => {\n            stopListeners();\n            stopBeforeUnloadListener();\n        };\n    });\n}\nexport function isPageExitReason(reason) {\n    return objectValues(PageExitReason).includes(reason);\n}\n//# sourceMappingURL=pageExitObservable.js.map","import { DOCS_TROUBLESHOOTING, MORE_DETAILS, display } from '../tools/display';\nimport { objectValues } from '../tools/utils/polyfills';\nimport { isPageExitReason } from '../browser/pageExitObservable';\nimport { jsonStringify } from '../tools/serialisation/jsonStringify';\nimport { computeBytesCount } from '../tools/utils/byteUtils';\nexport function createBatch({ encoder, request, flushController, messageBytesLimit, }) {\n    let upsertBuffer = {};\n    const flushSubscription = flushController.flushObservable.subscribe((event) => flush(event));\n    function push(serializedMessage, estimatedMessageBytesCount, key) {\n        flushController.notifyBeforeAddMessage(estimatedMessageBytesCount);\n        if (key !== undefined) {\n            upsertBuffer[key] = serializedMessage;\n            flushController.notifyAfterAddMessage();\n        }\n        else {\n            encoder.write(encoder.isEmpty ? serializedMessage : `\\n${serializedMessage}`, (realMessageBytesCount) => {\n                flushController.notifyAfterAddMessage(realMessageBytesCount - estimatedMessageBytesCount);\n            });\n        }\n    }\n    function hasMessageFor(key) {\n        return key !== undefined && upsertBuffer[key] !== undefined;\n    }\n    function remove(key) {\n        const removedMessage = upsertBuffer[key];\n        delete upsertBuffer[key];\n        const messageBytesCount = encoder.estimateEncodedBytesCount(removedMessage);\n        flushController.notifyAfterRemoveMessage(messageBytesCount);\n    }\n    function addOrUpdate(message, key) {\n        const serializedMessage = jsonStringify(message);\n        const estimatedMessageBytesCount = encoder.estimateEncodedBytesCount(serializedMessage);\n        if (estimatedMessageBytesCount >= messageBytesLimit) {\n            display.warn(`Discarded a message whose size was bigger than the maximum allowed size ${messageBytesLimit}KB. ${MORE_DETAILS} ${DOCS_TROUBLESHOOTING}/#technical-limitations`);\n            return;\n        }\n        if (hasMessageFor(key)) {\n            remove(key);\n        }\n        push(serializedMessage, estimatedMessageBytesCount, key);\n    }\n    function flush(event) {\n        const upsertMessages = objectValues(upsertBuffer).join('\\n');\n        upsertBuffer = {};\n        const isPageExit = isPageExitReason(event.reason);\n        const send = isPageExit ? request.sendOnExit : request.send;\n        if (isPageExit &&\n            // Note: checking that the encoder is async is not strictly needed, but it's an optimization:\n            // if the encoder is async we need to send two requests in some cases (one for encoded data\n            // and the other for non-encoded data). But if it's not async, we don't have to worry about\n            // it and always send a single request.\n            encoder.isAsync) {\n            const encoderResult = encoder.finishSync();\n            // Send encoded messages\n            if (encoderResult.outputBytesCount) {\n                send(formatPayloadFromEncoder(encoderResult));\n            }\n            // Send messages that are not yet encoded at this point\n            const pendingMessages = [encoderResult.pendingData, upsertMessages].filter(Boolean).join('\\n');\n            if (pendingMessages) {\n                send({\n                    data: pendingMessages,\n                    bytesCount: computeBytesCount(pendingMessages),\n                });\n            }\n        }\n        else {\n            if (upsertMessages) {\n                encoder.write(encoder.isEmpty ? upsertMessages : `\\n${upsertMessages}`);\n            }\n            encoder.finish((encoderResult) => {\n                send(formatPayloadFromEncoder(encoderResult));\n            });\n        }\n    }\n    return {\n        flushController,\n        add: addOrUpdate,\n        upsert: addOrUpdate,\n        stop: flushSubscription.unsubscribe,\n    };\n}\nfunction formatPayloadFromEncoder(encoderResult) {\n    let data;\n    if (typeof encoderResult.output === 'string') {\n        data = encoderResult.output;\n    }\n    else {\n        data = new Blob([encoderResult.output], {\n            // This will set the 'Content-Type: text/plain' header. Reasoning:\n            // * The intake rejects the request if there is no content type.\n            // * The browser will issue CORS preflight requests if we set it to 'application/json', which\n            // could induce higher intake load (and maybe has other impacts).\n            // * Also it's not quite JSON, since we are concatenating multiple JSON objects separated by\n            // new lines.\n            type: 'text/plain',\n        });\n    }\n    return {\n        data,\n        bytesCount: encoderResult.outputBytesCount,\n        encoding: encoderResult.encoding,\n    };\n}\n//# sourceMappingURL=batch.js.map","import { Observable } from '../tools/observable';\nimport { clearTimeout, setTimeout } from '../tools/timer';\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({ messagesLimit, bytesLimit, durationLimit, pageExitObservable, sessionExpireObservable, }) {\n    const pageExitSubscription = pageExitObservable.subscribe((event) => flush(event.reason));\n    const sessionExpireSubscription = sessionExpireObservable.subscribe(() => flush('session_expire'));\n    const flushObservable = new Observable(() => () => {\n        pageExitSubscription.unsubscribe();\n        sessionExpireSubscription.unsubscribe();\n    });\n    let currentBytesCount = 0;\n    let currentMessagesCount = 0;\n    function flush(flushReason) {\n        if (currentMessagesCount === 0) {\n            return;\n        }\n        const messagesCount = currentMessagesCount;\n        const bytesCount = currentBytesCount;\n        currentMessagesCount = 0;\n        currentBytesCount = 0;\n        cancelDurationLimitTimeout();\n        flushObservable.notify({\n            reason: flushReason,\n            messagesCount,\n            bytesCount,\n        });\n    }\n    let durationLimitTimeoutId;\n    function scheduleDurationLimitTimeout() {\n        if (durationLimitTimeoutId === undefined) {\n            durationLimitTimeoutId = setTimeout(() => {\n                flush('duration_limit');\n            }, durationLimit);\n        }\n    }\n    function cancelDurationLimitTimeout() {\n        clearTimeout(durationLimitTimeoutId);\n        durationLimitTimeoutId = undefined;\n    }\n    return {\n        flushObservable,\n        get messagesCount() {\n            return currentMessagesCount;\n        },\n        /**\n         * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n         *\n         * This function needs to be called synchronously, right before adding the message, so no flush\n         * event can happen after `notifyBeforeAddMessage` and before adding the message.\n         *\n         * @param estimatedMessageBytesCount: an estimation of the message bytes count once it is\n         * actually added.\n         */\n        notifyBeforeAddMessage(estimatedMessageBytesCount) {\n            if (currentBytesCount + estimatedMessageBytesCount >= bytesLimit) {\n                flush('bytes_limit');\n            }\n            // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n            // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n            // to notify when a flush is needed (for example on page exit).\n            currentMessagesCount += 1;\n            currentBytesCount += estimatedMessageBytesCount;\n            scheduleDurationLimitTimeout();\n        },\n        /**\n         * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n         *\n         * This function can be called asynchronously after the message was added, but in this case it\n         * should not be called if a flush event occurred in between.\n         *\n         * @param messageBytesCountDiff: the difference between the estimated message bytes count and\n         * its actual bytes count once added to the pool.\n         */\n        notifyAfterAddMessage(messageBytesCountDiff = 0) {\n            currentBytesCount += messageBytesCountDiff;\n            if (currentMessagesCount >= messagesLimit) {\n                flush('messages_limit');\n            }\n            else if (currentBytesCount >= bytesLimit) {\n                flush('bytes_limit');\n            }\n        },\n        /**\n         * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n         *\n         * This function needs to be called synchronously, right after removing the message, so no flush\n         * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n         *\n         * @param messageBytesCount: the message bytes count that was added to the pool. Should\n         * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and\n         * `notifyAfterAddMessage`.\n         */\n        notifyAfterRemoveMessage(messageBytesCount) {\n            currentBytesCount -= messageBytesCount;\n            currentMessagesCount -= 1;\n            if (currentMessagesCount === 0) {\n                cancelDurationLimitTimeout();\n            }\n        },\n    };\n}\n//# sourceMappingURL=flushController.js.map","import { computeBytesCount } from './utils/byteUtils';\nexport function createIdentityEncoder() {\n    let output = '';\n    let outputBytesCount = 0;\n    return {\n        isAsync: false,\n        get isEmpty() {\n            return !output;\n        },\n        write(data, callback) {\n            const additionalEncodedBytesCount = computeBytesCount(data);\n            outputBytesCount += additionalEncodedBytesCount;\n            output += data;\n            if (callback) {\n                callback(additionalEncodedBytesCount);\n            }\n        },\n        finish(callback) {\n            callback(this.finishSync());\n        },\n        finishSync() {\n            const result = {\n                output,\n                outputBytesCount,\n                rawBytesCount: outputBytesCount,\n                pendingData: '',\n            };\n            output = '';\n            outputBytesCount = 0;\n            return result;\n        },\n        estimateEncodedBytesCount(data) {\n            return data.length;\n        },\n    };\n}\n//# sourceMappingURL=encoder.js.map","import { setTimeout } from '../../tools/timer';\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils';\nimport { ErrorSource } from '../error/error.types';\nexport function createEventRateLimiter(eventType, limit, onLimitReached) {\n    let eventCount = 0;\n    let allowNextEvent = false;\n    return {\n        isLimitReached() {\n            if (eventCount === 0) {\n                setTimeout(() => {\n                    eventCount = 0;\n                }, ONE_MINUTE);\n            }\n            eventCount += 1;\n            if (eventCount <= limit || allowNextEvent) {\n                allowNextEvent = false;\n                return false;\n            }\n            if (eventCount === limit + 1) {\n                allowNextEvent = true;\n                try {\n                    onLimitReached({\n                        message: `Reached max number of ${eventType}s by minute: ${limit}`,\n                        source: ErrorSource.AGENT,\n                        startClocks: clocksNow(),\n                    });\n                }\n                finally {\n                    allowNextEvent = false;\n                }\n            }\n            return true;\n        },\n    };\n}\n//# sourceMappingURL=createEventRateLimiter.js.map","import { noop } from '../tools/utils/functionUtils';\nimport { addEventListener } from './addEventListener';\nexport function runOnReadyState(configuration, expectedReadyState, callback) {\n    if (document.readyState === expectedReadyState || document.readyState === 'complete') {\n        callback();\n        return { stop: noop };\n    }\n    const eventName = expectedReadyState === 'complete' ? \"load\" /* DOM_EVENT.LOAD */ : \"DOMContentLoaded\" /* DOM_EVENT.DOM_CONTENT_LOADED */;\n    return addEventListener(configuration, window, eventName, callback, { once: true });\n}\nexport function asyncRunOnReadyState(configuration, expectedReadyState) {\n    return new Promise((resolve) => {\n        runOnReadyState(configuration, expectedReadyState, resolve);\n    });\n}\n//# sourceMappingURL=runOnReadyState.js.map","import { instrumentMethod } from '../tools/instrumentMethod';\nimport { Observable } from '../tools/observable';\nimport { elapsed, clocksNow, timeStampNow } from '../tools/utils/timeUtils';\nimport { normalizeUrl } from '../tools/utils/urlPolyfill';\nimport { shallowClone } from '../tools/utils/objectUtils';\nimport { addEventListener } from './addEventListener';\nlet xhrObservable;\nconst xhrContexts = new WeakMap();\nexport function initXhrObservable(configuration) {\n    if (!xhrObservable) {\n        xhrObservable = createXhrObservable(configuration);\n    }\n    return xhrObservable;\n}\nfunction createXhrObservable(configuration) {\n    return new Observable((observable) => {\n        const { stop: stopInstrumentingStart } = instrumentMethod(XMLHttpRequest.prototype, 'open', openXhr);\n        const { stop: stopInstrumentingSend } = instrumentMethod(XMLHttpRequest.prototype, 'send', (call) => {\n            sendXhr(call, configuration, observable);\n        }, { computeHandlingStack: true });\n        const { stop: stopInstrumentingAbort } = instrumentMethod(XMLHttpRequest.prototype, 'abort', abortXhr);\n        return () => {\n            stopInstrumentingStart();\n            stopInstrumentingSend();\n            stopInstrumentingAbort();\n        };\n    });\n}\nfunction openXhr({ target: xhr, parameters: [method, url] }) {\n    xhrContexts.set(xhr, {\n        state: 'open',\n        method: String(method).toUpperCase(),\n        url: normalizeUrl(String(url)),\n    });\n}\nfunction sendXhr({ target: xhr, handlingStack }, configuration, observable) {\n    const context = xhrContexts.get(xhr);\n    if (!context) {\n        return;\n    }\n    const startContext = context;\n    startContext.state = 'start';\n    startContext.startClocks = clocksNow();\n    startContext.isAborted = false;\n    startContext.xhr = xhr;\n    startContext.handlingStack = handlingStack;\n    let hasBeenReported = false;\n    const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethod(xhr, 'onreadystatechange', () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n            // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n            // application during a future event. For example, Angular is calling .abort() on\n            // completed requests during an onreadystatechange event, so the status becomes '0'\n            // before the request is collected.\n            onEnd();\n        }\n    });\n    const onEnd = () => {\n        unsubscribeLoadEndListener();\n        stopInstrumentingOnReadyStateChange();\n        if (hasBeenReported) {\n            return;\n        }\n        hasBeenReported = true;\n        const completeContext = context;\n        completeContext.state = 'complete';\n        completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow());\n        completeContext.status = xhr.status;\n        observable.notify(shallowClone(completeContext));\n    };\n    const { stop: unsubscribeLoadEndListener } = addEventListener(configuration, xhr, 'loadend', onEnd);\n    observable.notify(startContext);\n}\nfunction abortXhr({ target: xhr }) {\n    const context = xhrContexts.get(xhr);\n    if (context) {\n        context.isAborted = true;\n    }\n}\n//# sourceMappingURL=xhrObservable.js.map","import { instrumentMethod } from '../tools/instrumentMethod';\nimport { monitor } from '../tools/monitor';\nimport { Observable } from '../tools/observable';\nimport { clocksNow } from '../tools/utils/timeUtils';\nimport { normalizeUrl } from '../tools/utils/urlPolyfill';\nlet fetchObservable;\nexport function initFetchObservable() {\n    if (!fetchObservable) {\n        fetchObservable = createFetchObservable();\n    }\n    return fetchObservable;\n}\nexport function resetFetchObservable() {\n    fetchObservable = undefined;\n}\nfunction createFetchObservable() {\n    return new Observable((observable) => {\n        if (!window.fetch) {\n            return;\n        }\n        const { stop } = instrumentMethod(window, 'fetch', (call) => beforeSend(call, observable), {\n            computeHandlingStack: true,\n        });\n        return stop;\n    });\n}\nfunction beforeSend({ parameters, onPostCall, handlingStack }, observable) {\n    const [input, init] = parameters;\n    let methodFromParams = init && init.method;\n    if (methodFromParams === undefined && input instanceof Request) {\n        methodFromParams = input.method;\n    }\n    const method = methodFromParams !== undefined ? String(methodFromParams).toUpperCase() : 'GET';\n    const url = input instanceof Request ? input.url : normalizeUrl(String(input));\n    const startClocks = clocksNow();\n    const context = {\n        state: 'start',\n        init,\n        input,\n        method,\n        startClocks,\n        url,\n        handlingStack,\n    };\n    observable.notify(context);\n    // Those properties can be changed by observable subscribers\n    parameters[0] = context.input;\n    parameters[1] = context.init;\n    onPostCall((responsePromise) => afterSend(observable, responsePromise, context));\n}\nfunction afterSend(observable, responsePromise, startContext) {\n    const context = startContext;\n    function reportFetch(partialContext) {\n        context.state = 'resolve';\n        Object.assign(context, partialContext);\n        observable.notify(context);\n    }\n    responsePromise.then(monitor((response) => {\n        reportFetch({\n            response,\n            responseType: response.type,\n            status: response.status,\n            isAborted: false,\n        });\n    }), monitor((error) => {\n        var _a, _b;\n        reportFetch({\n            status: 0,\n            isAborted: ((_b = (_a = context.init) === null || _a === void 0 ? void 0 : _a.signal) === null || _b === void 0 ? void 0 : _b.aborted) || (error instanceof DOMException && error.code === DOMException.ABORT_ERR),\n            error,\n        });\n    }));\n}\n//# sourceMappingURL=fetchObservable.js.map","import { setTimeout, clearTimeout } from './timer';\nimport { monitor } from './monitor';\nimport { dateNow } from './utils/timeUtils';\n/**\n * 'requestIdleCallback' with a shim.\n */\nexport function requestIdleCallback(callback, opts) {\n    // Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.\n    if (window.requestIdleCallback && window.cancelIdleCallback) {\n        const id = window.requestIdleCallback(monitor(callback), opts);\n        return () => window.cancelIdleCallback(id);\n    }\n    return requestIdleCallbackShim(callback);\n}\nexport const MAX_TASK_TIME = 50;\n/*\n * Shim from https://developer.chrome.com/blog/using-requestidlecallback#checking_for_requestidlecallback\n * Note: there is no simple way to support the \"timeout\" option, so we ignore it.\n */\nexport function requestIdleCallbackShim(callback) {\n    const start = dateNow();\n    const timeoutId = setTimeout(() => {\n        callback({\n            didTimeout: false,\n            timeRemaining: () => Math.max(0, MAX_TASK_TIME - (dateNow() - start)),\n        });\n    }, 0);\n    return () => clearTimeout(timeoutId);\n}\n//# sourceMappingURL=requestIdleCallback.js.map","import { flattenErrorCauses, isError, tryToGetFingerprint, tryToGetErrorContext } from '../error/error';\nimport { mergeObservables, Observable } from '../../tools/observable';\nimport { ConsoleApiName, globalConsole } from '../../tools/display';\nimport { callMonitored } from '../../tools/monitor';\nimport { sanitize } from '../../tools/serialisation/sanitize';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { ErrorSource } from '../error/error.types';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { createHandlingStack, toStackTraceString, formatErrorMessage } from '../../tools/stackTrace/handlingStack';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nlet consoleObservablesByApi = {};\nexport function initConsoleObservable(apis) {\n    const consoleObservables = apis.map((api) => {\n        if (!consoleObservablesByApi[api]) {\n            consoleObservablesByApi[api] = createConsoleObservable(api); // we are sure that the observable created for this api will yield the expected ConsoleLog type\n        }\n        return consoleObservablesByApi[api];\n    });\n    return mergeObservables(...consoleObservables);\n}\nexport function resetConsoleObservable() {\n    consoleObservablesByApi = {};\n}\nfunction createConsoleObservable(api) {\n    return new Observable((observable) => {\n        const originalConsoleApi = globalConsole[api];\n        globalConsole[api] = (...params) => {\n            originalConsoleApi.apply(console, params);\n            const handlingStack = createHandlingStack('console error');\n            callMonitored(() => {\n                observable.notify(buildConsoleLog(params, api, handlingStack));\n            });\n        };\n        return () => {\n            globalConsole[api] = originalConsoleApi;\n        };\n    });\n}\nfunction buildConsoleLog(params, api, handlingStack) {\n    const message = params.map((param) => formatConsoleParameters(param)).join(' ');\n    let error;\n    if (api === ConsoleApiName.error) {\n        const firstErrorParam = params.find(isError);\n        error = {\n            stack: firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined,\n            fingerprint: tryToGetFingerprint(firstErrorParam),\n            causes: firstErrorParam ? flattenErrorCauses(firstErrorParam, 'console') : undefined,\n            startClocks: clocksNow(),\n            message,\n            source: ErrorSource.CONSOLE,\n            handling: \"handled\" /* ErrorHandling.HANDLED */,\n            handlingStack,\n            context: tryToGetErrorContext(firstErrorParam),\n        };\n    }\n    return {\n        api,\n        message,\n        error,\n        handlingStack,\n    };\n}\nfunction formatConsoleParameters(param) {\n    if (typeof param === 'string') {\n        return sanitize(param);\n    }\n    if (isError(param)) {\n        return formatErrorMessage(computeStackTrace(param));\n    }\n    return jsonStringify(sanitize(param), undefined, 2);\n}\n//# sourceMappingURL=consoleObservable.js.map","import { deepClone } from '../../tools/mergeInto';\nimport { sanitize } from '../../tools/serialisation/sanitize';\nimport { Observable } from '../../tools/observable';\nimport { display } from '../../tools/display';\nimport { checkContext } from './contextUtils';\nfunction ensureProperties(context, propertiesConfig, name) {\n    const newContext = { ...context };\n    for (const [key, { required, type }] of Object.entries(propertiesConfig)) {\n        /**\n         * Ensure specified properties are strings as defined here:\n         * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n         */\n        if (type === 'string' && key in newContext) {\n            /* eslint-disable @typescript-eslint/no-base-to-string */\n            newContext[key] = String(newContext[key]);\n        }\n        if (required && !(key in context)) {\n            display.warn(`The property ${key} of ${name} is required; context will not be sent to the intake.`);\n        }\n    }\n    return newContext;\n}\nexport function createContextManager(name = '', { customerDataTracker, propertiesConfig = {}, } = {}) {\n    let context = {};\n    const changeObservable = new Observable();\n    const contextManager = {\n        getContext: () => deepClone(context),\n        setContext: (newContext) => {\n            if (checkContext(newContext)) {\n                context = sanitize(ensureProperties(newContext, propertiesConfig, name));\n                customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.updateCustomerData(context);\n            }\n            else {\n                contextManager.clearContext();\n            }\n            changeObservable.notify();\n        },\n        setContextProperty: (key, property) => {\n            context[key] = sanitize(ensureProperties({ [key]: property }, propertiesConfig, name)[key]);\n            customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.updateCustomerData(context);\n            changeObservable.notify();\n        },\n        removeContextProperty: (key) => {\n            delete context[key];\n            customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.updateCustomerData(context);\n            ensureProperties(context, propertiesConfig, name);\n            changeObservable.notify();\n        },\n        clearContext: () => {\n            context = {};\n            customerDataTracker === null || customerDataTracker === void 0 ? void 0 : customerDataTracker.resetCustomerData();\n            changeObservable.notify();\n        },\n        changeObservable,\n    };\n    return contextManager;\n}\n//# sourceMappingURL=contextManager.js.map","import { display } from '../../tools/display';\nimport { getType } from '../../tools/utils/typeUtils';\n/**\n * Simple check to ensure an object is a valid context\n */\nexport function checkContext(maybeContext) {\n    const isValid = getType(maybeContext) === 'object';\n    if (!isValid) {\n        display.error('Unsupported context:', maybeContext);\n    }\n    return isValid;\n}\n//# sourceMappingURL=contextUtils.js.map","import { addEventListener } from '../../browser/addEventListener';\nimport { combine } from '../../tools/mergeInto';\nconst CONTEXT_STORE_KEY_PREFIX = '_dd_c';\nconst storageListeners = [];\nexport function storeContextManager(configuration, contextManager, productKey, customerDataType) {\n    const storageKey = buildStorageKey(productKey, customerDataType);\n    storageListeners.push(addEventListener(configuration, window, \"storage\" /* DOM_EVENT.STORAGE */, ({ key }) => {\n        if (storageKey === key) {\n            synchronizeWithStorage();\n        }\n    }));\n    contextManager.changeObservable.subscribe(dumpToStorage);\n    contextManager.setContext(combine(getFromStorage(), contextManager.getContext()));\n    function synchronizeWithStorage() {\n        contextManager.setContext(getFromStorage());\n    }\n    function dumpToStorage() {\n        localStorage.setItem(storageKey, JSON.stringify(contextManager.getContext()));\n    }\n    function getFromStorage() {\n        const rawContext = localStorage.getItem(storageKey);\n        return rawContext !== null ? JSON.parse(rawContext) : {};\n    }\n}\nexport function buildStorageKey(productKey, customerDataType) {\n    return `${CONTEXT_STORE_KEY_PREFIX}_${productKey}_${customerDataType}`;\n}\nexport function removeStorageListeners() {\n    storageListeners.map((listener) => listener.stop());\n}\n//# sourceMappingURL=storeContextManager.js.map","import { ONE_KIBI_BYTE, computeBytesCount } from '../../tools/utils/byteUtils';\nimport { throttle } from '../../tools/utils/functionUtils';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { DOCS_TROUBLESHOOTING, MORE_DETAILS, display } from '../../tools/display';\nimport { isEmptyObject } from '../../tools/utils/objectUtils';\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport const CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE;\n// We observed that the compression ratio is around 8 in general, but we also want to keep a margin\n// because some data might not be compressed (ex: last view update on page exit). We chose 16KiB\n// because it is also the limit of the 'batchBytesCount' that we use for RUM and Logs data, but this\n// is a bit arbitrary.\nexport const CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT = 16 * ONE_KIBI_BYTE;\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200;\nexport function createCustomerDataTrackerManager(compressionStatus = 2 /* CustomerDataCompressionStatus.Disabled */) {\n    const customerDataTrackers = new Map();\n    let alreadyWarned = false;\n    function checkCustomerDataLimit(initialBytesCount = 0) {\n        if (alreadyWarned || compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {\n            return;\n        }\n        const bytesCountLimit = compressionStatus === 2 /* CustomerDataCompressionStatus.Disabled */\n            ? CUSTOMER_DATA_BYTES_LIMIT\n            : CUSTOMER_COMPRESSED_DATA_BYTES_LIMIT;\n        let bytesCount = initialBytesCount;\n        customerDataTrackers.forEach((tracker) => {\n            bytesCount += tracker.getBytesCount();\n        });\n        if (bytesCount > bytesCountLimit) {\n            displayCustomerDataLimitReachedWarning(bytesCountLimit);\n            alreadyWarned = true;\n        }\n    }\n    return {\n        /**\n         * Creates a detached tracker. The manager will not store a reference to that tracker, and the\n         * bytes count will be counted independently from other detached trackers.\n         *\n         * This is particularly useful when we don't know when the tracker will be unused, so we don't\n         * leak memory (ex: when used in Logger instances).\n         */\n        createDetachedTracker: () => {\n            const tracker = createCustomerDataTracker(() => checkCustomerDataLimit(tracker.getBytesCount()));\n            return tracker;\n        },\n        /**\n         * Creates a tracker if it doesn't exist, and returns it.\n         */\n        getOrCreateTracker: (type) => {\n            if (!customerDataTrackers.has(type)) {\n                customerDataTrackers.set(type, createCustomerDataTracker(checkCustomerDataLimit));\n            }\n            return customerDataTrackers.get(type);\n        },\n        setCompressionStatus: (newCompressionStatus) => {\n            if (compressionStatus === 0 /* CustomerDataCompressionStatus.Unknown */) {\n                compressionStatus = newCompressionStatus;\n                checkCustomerDataLimit();\n            }\n        },\n        getCompressionStatus: () => compressionStatus,\n        stop: () => {\n            customerDataTrackers.forEach((tracker) => tracker.stop());\n            customerDataTrackers.clear();\n        },\n    };\n}\nexport function createCustomerDataTracker(checkCustomerDataLimit) {\n    let bytesCountCache = 0;\n    // Throttle the bytes computation to minimize the impact on performance.\n    // Especially useful if the user call context APIs synchronously multiple times in a row\n    const { throttled: computeBytesCountThrottled, cancel: cancelComputeBytesCount } = throttle((context) => {\n        bytesCountCache = computeBytesCount(jsonStringify(context));\n        checkCustomerDataLimit();\n    }, BYTES_COMPUTATION_THROTTLING_DELAY);\n    const resetBytesCount = () => {\n        cancelComputeBytesCount();\n        bytesCountCache = 0;\n    };\n    return {\n        updateCustomerData: (context) => {\n            if (isEmptyObject(context)) {\n                resetBytesCount();\n            }\n            else {\n                computeBytesCountThrottled(context);\n            }\n        },\n        resetCustomerData: resetBytesCount,\n        getBytesCount: () => bytesCountCache,\n        stop: () => {\n            cancelComputeBytesCount();\n        },\n    };\n}\nfunction displayCustomerDataLimitReachedWarning(bytesCountLimit) {\n    display.warn(`Customer data exceeds the recommended ${bytesCountLimit / ONE_KIBI_BYTE}KiB threshold. ${MORE_DETAILS} ${DOCS_TROUBLESHOOTING}/#customer-data-exceeds-the-recommended-threshold-warning`);\n}\n//# sourceMappingURL=customerDataTracker.js.map","import { getInitCookie } from '../../browser/cookie';\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id';\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id';\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum';\nexport function willSyntheticsInjectRum() {\n    return Boolean(window._DATADOG_SYNTHETICS_INJECTS_RUM || getInitCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME));\n}\nexport function getSyntheticsTestId() {\n    const value = window._DATADOG_SYNTHETICS_PUBLIC_ID || getInitCookie(SYNTHETICS_TEST_ID_COOKIE_NAME);\n    return typeof value === 'string' ? value : undefined;\n}\nexport function getSyntheticsResultId() {\n    const value = window._DATADOG_SYNTHETICS_RESULT_ID || getInitCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME);\n    return typeof value === 'string' ? value : undefined;\n}\n//# sourceMappingURL=syntheticsWorkerValues.js.map","import { display } from './display';\nimport { getType } from './utils/typeUtils';\nexport function isMatchOption(item) {\n    const itemType = getType(item);\n    return itemType === 'string' || itemType === 'function' || item instanceof RegExp;\n}\n/**\n * Returns true if value can be matched by at least one of the provided MatchOptions.\n * When comparing strings, setting useStartsWith to true will compare the value with the start of\n * the option, instead of requiring an exact match.\n */\nexport function matchList(list, value, useStartsWith = false) {\n    return list.some((item) => {\n        try {\n            if (typeof item === 'function') {\n                return item(value);\n            }\n            else if (item instanceof RegExp) {\n                return item.test(value);\n            }\n            else if (typeof item === 'string') {\n                return useStartsWith ? value.startsWith(item) : item === value;\n            }\n        }\n        catch (e) {\n            display.error(e);\n        }\n        return false;\n    });\n}\n//# sourceMappingURL=matchOption.js.map","import { clocksNow, combine, elapsed, generateUUID, toServerDuration } from '@datadog/browser-core';\nexport function createCustomVitalsState() {\n    const vitalsByName = new Map();\n    const vitalsByReference = new WeakMap();\n    return { vitalsByName, vitalsByReference };\n}\nexport function startVitalCollection(lifeCycle, pageStateHistory, customVitalsState) {\n    function isValid(vital) {\n        return !pageStateHistory.wasInPageStateDuringPeriod(\"frozen\" /* PageState.FROZEN */, vital.startClocks.relative, vital.duration);\n    }\n    function addDurationVital(vital) {\n        if (isValid(vital)) {\n            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processVital(vital, true));\n        }\n    }\n    return {\n        addDurationVital,\n        startDurationVital: (name, options = {}) => startDurationVital(customVitalsState, name, options),\n        stopDurationVital: (nameOrRef, options = {}) => {\n            stopDurationVital(addDurationVital, customVitalsState, nameOrRef, options);\n        },\n    };\n}\nexport function startDurationVital({ vitalsByName, vitalsByReference }, name, options = {}) {\n    const vital = {\n        name,\n        startClocks: clocksNow(),\n        context: options.context,\n        description: options.description,\n    };\n    // To avoid leaking implementation details of the vital, we return a reference to it.\n    const reference = { __dd_vital_reference: true };\n    vitalsByName.set(name, vital);\n    // To avoid memory leaks caused by the creation of numerous references (e.g., from improper useEffect implementations), we use a WeakMap.\n    vitalsByReference.set(reference, vital);\n    return reference;\n}\nexport function stopDurationVital(stopCallback, { vitalsByName, vitalsByReference }, nameOrRef, options = {}) {\n    const vitalStart = typeof nameOrRef === 'string' ? vitalsByName.get(nameOrRef) : vitalsByReference.get(nameOrRef);\n    if (!vitalStart) {\n        return;\n    }\n    stopCallback(buildDurationVital(vitalStart, vitalStart.startClocks, options, clocksNow()));\n    if (typeof nameOrRef === 'string') {\n        vitalsByName.delete(nameOrRef);\n    }\n    else {\n        vitalsByReference.delete(nameOrRef);\n    }\n}\nfunction buildDurationVital(vitalStart, startClocks, stopOptions, stopClocks) {\n    var _a;\n    return {\n        name: vitalStart.name,\n        type: \"duration\" /* VitalType.DURATION */,\n        startClocks,\n        duration: elapsed(startClocks.timeStamp, stopClocks.timeStamp),\n        context: combine(vitalStart.context, stopOptions.context),\n        description: (_a = stopOptions.description) !== null && _a !== void 0 ? _a : vitalStart.description,\n    };\n}\nfunction processVital(vital, valueComputedBySdk) {\n    const rawRumEvent = {\n        date: vital.startClocks.timeStamp,\n        vital: {\n            id: generateUUID(),\n            type: vital.type,\n            name: vital.name,\n            duration: toServerDuration(vital.duration),\n            description: vital.description,\n        },\n        type: \"vital\" /* RumEventType.VITAL */,\n    };\n    if (valueComputedBySdk) {\n        rawRumEvent._dd = {\n            vital: {\n                computed_value: true,\n            },\n        };\n    }\n    return {\n        rawRumEvent,\n        startTime: vital.startClocks.relative,\n        customerContext: vital.context,\n        domainContext: {},\n    };\n}\n//# sourceMappingURL=vitalCollection.js.map","export function callPluginsMethod(plugins, methodName, parameter) {\n    if (!plugins) {\n        return;\n    }\n    for (const plugin of plugins) {\n        const method = plugin[methodName];\n        if (method) {\n            method(parameter);\n        }\n    }\n}\n//# sourceMappingURL=plugins.js.map","export function createTraceIdentifier() {\n    return createIdentifier(64);\n}\nexport function createSpanIdentifier() {\n    return createIdentifier(63);\n}\nfunction createIdentifier(bits) {\n    const buffer = crypto.getRandomValues(new Uint32Array(2));\n    if (bits === 63) {\n        // eslint-disable-next-line no-bitwise\n        buffer[buffer.length - 1] >>>= 1; // force 63-bit\n    }\n    // The `.toString` function is intentionally similar to Number and BigInt `.toString` method.\n    //\n    // JavaScript numbers can represent integers up to 48 bits, this is why we need two of them to\n    // represent a 64 bits identifier. But BigInts don't have this limitation and can represent larger\n    // integer values.\n    //\n    // In the future, when we drop browsers without BigInts support, we could use BigInts directly\n    // represent identifiers by simply returning a BigInt from this function (as all we need is a\n    // value with a `.toString` method).\n    //\n    // Examples:\n    //   const buffer = getCrypto().getRandomValues(new Uint32Array(2))\n    //   return BigInt(buffer[0]) + BigInt(buffer[1]) << 32n\n    //\n    //   // Alternative with BigUint64Array (different Browser support than plain bigints!):\n    //   return crypto.getRandomValues(new BigUint64Array(1))[0]\n    //\n    // For now, let's keep using two plain numbers as having two different implementations (one for\n    // browsers with BigInt support and one for older browsers) don't bring much value.\n    return {\n        toString(radix = 10) {\n            let high = buffer[1];\n            let low = buffer[0];\n            let str = '';\n            do {\n                const mod = (high % radix) * 4294967296 + low;\n                high = Math.floor(high / radix);\n                low = Math.floor(mod / radix);\n                str = (mod % radix).toString(radix) + str;\n            } while (high || low);\n            return str;\n        },\n    };\n}\nexport function toPaddedHexadecimalString(id) {\n    return id.toString(16).padStart(16, '0');\n}\n//# sourceMappingURL=identifier.js.map","import { ExperimentalFeature, isExperimentalFeatureEnabled, performDraw } from '@datadog/browser-core';\nlet sampleDecisionCache;\nexport function isTraceSampled(sessionId, sampleRate) {\n    // Shortcuts for common cases. This is not strictly necessary, but it makes the code faster for\n    // customers willing to ingest all traces.\n    if (sampleRate === 100) {\n        return true;\n    }\n    if (sampleRate === 0) {\n        return false;\n    }\n    if (!isExperimentalFeatureEnabled(ExperimentalFeature.CONSISTENT_TRACE_SAMPLING)) {\n        return performDraw(sampleRate);\n    }\n    if (sampleDecisionCache && sessionId === sampleDecisionCache.sessionId) {\n        return sampleDecisionCache.decision;\n    }\n    let decision;\n    // @ts-expect-error BigInt might not be defined in every browser we support\n    if (window.BigInt) {\n        decision = sampleUsingKnuthFactor(BigInt(`0x${sessionId.split('-')[4]}`), sampleRate);\n    }\n    else {\n        // For simplicity, we don't use consistent sampling for browser without BigInt support\n        // TODO: remove this when all browser we support have BigInt support\n        decision = performDraw(sampleRate);\n    }\n    sampleDecisionCache = { sessionId, decision };\n    return decision;\n}\n// Exported for tests\nexport function resetSampleDecisionCache() {\n    sampleDecisionCache = undefined;\n}\n/**\n * Perform sampling using the Knuth factor method. This method offer consistent sampling result\n * based on the provided identifier.\n *\n * @param identifier The identifier to use for sampling.\n * @param sampleRate The sample rate in percentage between 0 and 100.\n */\nexport function sampleUsingKnuthFactor(identifier, sampleRate) {\n    // The formula is:\n    //\n    //   (identifier * knuthFactor) % 2^64 < sampleRate * 2^64\n    //\n    // Because JavaScript numbers are 64-bit floats, we can't represent 64-bit integers, and the\n    // modulo would be incorrect. Thus, we are using BigInts here.\n    //\n    // Implementation in other languages:\n    // * Go     https://github.com/DataDog/dd-trace-go/blob/ec6fbb1f2d517b7b8e69961052adf7136f3af773/ddtrace/tracer/sampler.go#L86-L91\n    // * Python https://github.com/DataDog/dd-trace-py/blob/0cee2f066fb6e79aa15947c1514c0f406dea47c5/ddtrace/sampling_rule.py#L197\n    // * Ruby   https://github.com/DataDog/dd-trace-rb/blob/1a6e255cdcb7e7e22235ea5955f90f6dfa91045d/lib/datadog/tracing/sampling/rate_sampler.rb#L42\n    // * C++    https://github.com/DataDog/dd-trace-cpp/blob/159629edc438ae45f2bb318eb7bd51abd05e94b5/src/datadog/trace_sampler.cpp#L58\n    // * Java   https://github.com/DataDog/dd-trace-java/blob/896dd6b380533216e0bdee59614606c8272d313e/dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java#L48\n    //\n    // Note: All implementations have slight variations. Some of them use '<=' instead of '<', and\n    // use `sampleRate * 2^64 - 1` instead of `sampleRate * 2^64`. The following implementation\n    // should adhere to the spec and is a bit simpler than using a 2^64-1 limit as there are less\n    // BigInt arithmetic to write. In practice this does not matter, as we are using floating point\n    // numbers in the end, and Number(2n**64n-1n) === Number(2n**64n).\n    const knuthFactor = BigInt('1111111111111111111');\n    const twoPow64 = BigInt('0x10000000000000000'); // 2n ** 64n\n    const hash = (identifier * knuthFactor) % twoPow64;\n    return Number(hash) <= (sampleRate / 100) * Number(twoPow64);\n}\n//# sourceMappingURL=sampler.js.map","import { objectEntries, shallowClone, getType, isMatchOption, matchList, TraceContextInjection, } from '@datadog/browser-core';\nimport { createSpanIdentifier, createTraceIdentifier, toPaddedHexadecimalString } from './identifier';\nimport { isTraceSampled } from './sampler';\nexport function isTracingOption(item) {\n    const expectedItem = item;\n    return (getType(expectedItem) === 'object' &&\n        isMatchOption(expectedItem.match) &&\n        Array.isArray(expectedItem.propagatorTypes));\n}\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context) {\n    if (context.status === 0 && !context.isAborted) {\n        context.traceId = undefined;\n        context.spanId = undefined;\n        context.traceSampled = undefined;\n    }\n}\nexport function startTracer(configuration, sessionManager) {\n    return {\n        clearTracingIfNeeded,\n        traceFetch: (context) => injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders) => {\n            var _a;\n            if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {\n                context.input = new Request(context.input);\n                Object.keys(tracingHeaders).forEach((key) => {\n                    ;\n                    context.input.headers.append(key, tracingHeaders[key]);\n                });\n            }\n            else {\n                context.init = shallowClone(context.init);\n                const headers = [];\n                if (context.init.headers instanceof Headers) {\n                    context.init.headers.forEach((value, key) => {\n                        headers.push([key, value]);\n                    });\n                }\n                else if (Array.isArray(context.init.headers)) {\n                    context.init.headers.forEach((header) => {\n                        headers.push(header);\n                    });\n                }\n                else if (context.init.headers) {\n                    Object.keys(context.init.headers).forEach((key) => {\n                        headers.push([key, context.init.headers[key]]);\n                    });\n                }\n                context.init.headers = headers.concat(objectEntries(tracingHeaders));\n            }\n        }),\n        traceXhr: (context, xhr) => injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders) => {\n            Object.keys(tracingHeaders).forEach((name) => {\n                xhr.setRequestHeader(name, tracingHeaders[name]);\n            });\n        }),\n    };\n}\nfunction injectHeadersIfTracingAllowed(configuration, context, sessionManager, inject) {\n    const session = sessionManager.findTrackedSession();\n    if (!session) {\n        return;\n    }\n    const tracingOption = configuration.allowedTracingUrls.find((tracingOption) => matchList([tracingOption.match], context.url, true));\n    if (!tracingOption) {\n        return;\n    }\n    const traceSampled = isTraceSampled(session.id, configuration.traceSampleRate);\n    const shouldInjectHeaders = traceSampled || configuration.traceContextInjection === TraceContextInjection.ALL;\n    if (!shouldInjectHeaders) {\n        return;\n    }\n    context.traceSampled = traceSampled;\n    context.traceId = createTraceIdentifier();\n    context.spanId = createSpanIdentifier();\n    inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, tracingOption.propagatorTypes));\n}\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(traceId, spanId, traceSampled, propagatorTypes) {\n    const tracingHeaders = {};\n    propagatorTypes.forEach((propagatorType) => {\n        switch (propagatorType) {\n            case 'datadog': {\n                Object.assign(tracingHeaders, {\n                    'x-datadog-origin': 'rum',\n                    'x-datadog-parent-id': spanId.toString(),\n                    'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n                    'x-datadog-trace-id': traceId.toString(),\n                });\n                break;\n            }\n            // https://www.w3.org/TR/trace-context/\n            case 'tracecontext': {\n                Object.assign(tracingHeaders, {\n                    traceparent: `00-0000000000000000${toPaddedHexadecimalString(traceId)}-${toPaddedHexadecimalString(spanId)}-0${traceSampled ? '1' : '0'}`,\n                    tracestate: `dd=s:${traceSampled ? '1' : '0'};o:rum`,\n                });\n                break;\n            }\n            // https://github.com/openzipkin/b3-propagation\n            case 'b3': {\n                Object.assign(tracingHeaders, {\n                    b3: `${toPaddedHexadecimalString(traceId)}-${toPaddedHexadecimalString(spanId)}-${traceSampled ? '1' : '0'}`,\n                });\n                break;\n            }\n            case 'b3multi': {\n                Object.assign(tracingHeaders, {\n                    'X-B3-TraceId': toPaddedHexadecimalString(traceId),\n                    'X-B3-SpanId': toPaddedHexadecimalString(spanId),\n                    'X-B3-Sampled': traceSampled ? '1' : '0',\n                });\n                break;\n            }\n        }\n    });\n    return tracingHeaders;\n}\n//# sourceMappingURL=tracer.js.map","import { getType, isMatchOption, serializeConfiguration, DefaultPrivacyLevel, TraceContextInjection, display, objectHasValue, validateAndBuildConfiguration, isSampleRate, isNumber, } from '@datadog/browser-core';\nimport { isTracingOption } from '../tracing/tracer';\nexport const DEFAULT_PROPAGATOR_TYPES = ['tracecontext', 'datadog'];\nexport function validateAndBuildRumConfiguration(initConfiguration) {\n    var _a, _b, _c, _d, _e, _f;\n    if (initConfiguration.trackFeatureFlagsForEvents !== undefined &&\n        !Array.isArray(initConfiguration.trackFeatureFlagsForEvents)) {\n        display.warn('trackFeatureFlagsForEvents should be an array');\n    }\n    if (!initConfiguration.applicationId) {\n        display.error('Application ID is not configured, no RUM data will be collected.');\n        return;\n    }\n    if (!isSampleRate(initConfiguration.sessionReplaySampleRate, 'Session Replay') ||\n        !isSampleRate(initConfiguration.traceSampleRate, 'Trace')) {\n        return;\n    }\n    if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {\n        display.error('Excluded Activity Urls should be an array');\n        return;\n    }\n    const allowedTracingUrls = validateAndBuildTracingOptions(initConfiguration);\n    if (!allowedTracingUrls) {\n        return;\n    }\n    const baseConfiguration = validateAndBuildConfiguration(initConfiguration);\n    if (!baseConfiguration) {\n        return;\n    }\n    const sessionReplaySampleRate = (_a = initConfiguration.sessionReplaySampleRate) !== null && _a !== void 0 ? _a : 0;\n    return {\n        applicationId: initConfiguration.applicationId,\n        version: initConfiguration.version || undefined,\n        actionNameAttribute: initConfiguration.actionNameAttribute,\n        sessionReplaySampleRate,\n        startSessionReplayRecordingManually: initConfiguration.startSessionReplayRecordingManually !== undefined\n            ? !!initConfiguration.startSessionReplayRecordingManually\n            : sessionReplaySampleRate === 0,\n        traceSampleRate: (_b = initConfiguration.traceSampleRate) !== null && _b !== void 0 ? _b : 100,\n        rulePsr: isNumber(initConfiguration.traceSampleRate) ? initConfiguration.traceSampleRate / 100 : undefined,\n        allowedTracingUrls,\n        excludedActivityUrls: (_c = initConfiguration.excludedActivityUrls) !== null && _c !== void 0 ? _c : [],\n        workerUrl: initConfiguration.workerUrl,\n        compressIntakeRequests: !!initConfiguration.compressIntakeRequests,\n        trackUserInteractions: !!((_d = initConfiguration.trackUserInteractions) !== null && _d !== void 0 ? _d : true),\n        trackViewsManually: !!initConfiguration.trackViewsManually,\n        trackResources: !!((_e = initConfiguration.trackResources) !== null && _e !== void 0 ? _e : true),\n        trackLongTasks: !!((_f = initConfiguration.trackLongTasks) !== null && _f !== void 0 ? _f : true),\n        subdomain: initConfiguration.subdomain,\n        defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel)\n            ? initConfiguration.defaultPrivacyLevel\n            : DefaultPrivacyLevel.MASK,\n        enablePrivacyForActionName: !!initConfiguration.enablePrivacyForActionName,\n        customerDataTelemetrySampleRate: 1,\n        traceContextInjection: objectHasValue(TraceContextInjection, initConfiguration.traceContextInjection)\n            ? initConfiguration.traceContextInjection\n            : TraceContextInjection.SAMPLED,\n        plugins: initConfiguration.plugins || [],\n        trackFeatureFlagsForEvents: initConfiguration.trackFeatureFlagsForEvents || [],\n        ...baseConfiguration,\n    };\n}\n/**\n * Validates allowedTracingUrls and converts match options to tracing options\n */\nfunction validateAndBuildTracingOptions(initConfiguration) {\n    if (initConfiguration.allowedTracingUrls === undefined) {\n        return [];\n    }\n    if (!Array.isArray(initConfiguration.allowedTracingUrls)) {\n        display.error('Allowed Tracing URLs should be an array');\n        return;\n    }\n    if (initConfiguration.allowedTracingUrls.length !== 0 && initConfiguration.service === undefined) {\n        display.error('Service needs to be configured when tracing is enabled');\n        return;\n    }\n    // Convert from (MatchOption | TracingOption) to TracingOption, remove unknown properties\n    const tracingOptions = [];\n    initConfiguration.allowedTracingUrls.forEach((option) => {\n        if (isMatchOption(option)) {\n            tracingOptions.push({ match: option, propagatorTypes: DEFAULT_PROPAGATOR_TYPES });\n        }\n        else if (isTracingOption(option)) {\n            tracingOptions.push(option);\n        }\n        else {\n            display.warn('Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter', option);\n        }\n    });\n    return tracingOptions;\n}\n/**\n * Combines the selected tracing propagators from the different options in allowedTracingUrls\n */\nfunction getSelectedTracingPropagators(configuration) {\n    const usedTracingPropagators = new Set();\n    if (Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0) {\n        configuration.allowedTracingUrls.forEach((option) => {\n            if (isMatchOption(option)) {\n                DEFAULT_PROPAGATOR_TYPES.forEach((propagatorType) => usedTracingPropagators.add(propagatorType));\n            }\n            else if (getType(option) === 'object' && Array.isArray(option.propagatorTypes)) {\n                // Ensure we have an array, as we cannot rely on types yet (configuration is provided by users)\n                option.propagatorTypes.forEach((propagatorType) => usedTracingPropagators.add(propagatorType));\n            }\n        });\n    }\n    return Array.from(usedTracingPropagators);\n}\nexport function serializeRumConfiguration(configuration) {\n    var _a;\n    const baseSerializedConfiguration = serializeConfiguration(configuration);\n    return {\n        session_replay_sample_rate: configuration.sessionReplaySampleRate,\n        start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,\n        trace_sample_rate: configuration.traceSampleRate,\n        trace_context_injection: configuration.traceContextInjection,\n        action_name_attribute: configuration.actionNameAttribute,\n        use_allowed_tracing_urls: Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0,\n        selected_tracing_propagators: getSelectedTracingPropagators(configuration),\n        default_privacy_level: configuration.defaultPrivacyLevel,\n        enable_privacy_for_action_name: configuration.enablePrivacyForActionName,\n        use_excluded_activity_urls: Array.isArray(configuration.excludedActivityUrls) && configuration.excludedActivityUrls.length > 0,\n        use_worker_url: !!configuration.workerUrl,\n        compress_intake_requests: configuration.compressIntakeRequests,\n        track_views_manually: configuration.trackViewsManually,\n        track_user_interactions: configuration.trackUserInteractions,\n        track_resources: configuration.trackResources,\n        track_long_task: configuration.trackLongTasks,\n        plugins: (_a = configuration.plugins) === null || _a === void 0 ? void 0 : _a.map((plugin) => {\n            var _a;\n            return ({\n                name: plugin.name,\n                ...(_a = plugin.getConfigurationTelemetry) === null || _a === void 0 ? void 0 : _a.call(plugin),\n            });\n        }),\n        track_feature_flags_for_events: configuration.trackFeatureFlagsForEvents,\n        ...baseSerializedConfiguration,\n    };\n}\n//# sourceMappingURL=configuration.js.map","import { display, addEventListener, buildEndpointHost } from '@datadog/browser-core';\nconst REMOTE_CONFIGURATION_VERSION = 'v1';\nexport function fetchAndApplyRemoteConfiguration(initConfiguration, callback) {\n    fetchRemoteConfiguration(initConfiguration, (remoteInitConfiguration) => {\n        callback(applyRemoteConfiguration(initConfiguration, remoteInitConfiguration));\n    });\n}\nexport function applyRemoteConfiguration(initConfiguration, remoteInitConfiguration) {\n    return { ...initConfiguration, ...remoteInitConfiguration };\n}\nexport function fetchRemoteConfiguration(configuration, callback) {\n    const xhr = new XMLHttpRequest();\n    addEventListener(configuration, xhr, 'load', function () {\n        if (xhr.status === 200) {\n            const remoteConfiguration = JSON.parse(xhr.responseText);\n            callback(remoteConfiguration.rum);\n        }\n        else {\n            displayRemoteConfigurationFetchingError();\n        }\n    });\n    addEventListener(configuration, xhr, 'error', function () {\n        displayRemoteConfigurationFetchingError();\n    });\n    xhr.open('GET', buildEndpoint(configuration));\n    xhr.send();\n}\nexport function buildEndpoint(configuration) {\n    return `https://sdk-configuration.${buildEndpointHost('rum', configuration)}/${REMOTE_CONFIGURATION_VERSION}/${encodeURIComponent(configuration.remoteConfigurationId)}.json`;\n}\nfunction displayRemoteConfigurationFetchingError() {\n    display.error('Error fetching the remote configuration.');\n}\n//# sourceMappingURL=remoteConfiguration.js.map","import { createBoundedBuffer, display, canUseEventBridge, displayAlreadyInitializedError, willSyntheticsInjectRum, noop, timeStampNow, clocksNow, getEventBridge, initFeatureFlags, addTelemetryConfiguration, initFetchObservable, } from '@datadog/browser-core';\nimport { validateAndBuildRumConfiguration, } from '../domain/configuration';\nimport { startDurationVital, stopDurationVital } from '../domain/vital/vitalCollection';\nimport { fetchAndApplyRemoteConfiguration, serializeRumConfiguration } from '../domain/configuration';\nimport { callPluginsMethod } from '../domain/plugins';\nexport function createPreStartStrategy({ ignoreInitIfSyntheticsWillInjectRum, startDeflateWorker }, getCommonContext, trackingConsentState, customVitalsState, doStartRum) {\n    const bufferApiCalls = createBoundedBuffer();\n    let firstStartViewCall;\n    let deflateWorker;\n    let cachedInitConfiguration;\n    let cachedConfiguration;\n    const trackingConsentStateSubscription = trackingConsentState.observable.subscribe(tryStartRum);\n    const emptyContext = {};\n    function tryStartRum() {\n        if (!cachedInitConfiguration || !cachedConfiguration || !trackingConsentState.isGranted()) {\n            return;\n        }\n        trackingConsentStateSubscription.unsubscribe();\n        let initialViewOptions;\n        if (cachedConfiguration.trackViewsManually) {\n            if (!firstStartViewCall) {\n                return;\n            }\n            // An initial view is always created when starting RUM.\n            // When tracking views automatically, any startView call before RUM start creates an extra\n            // view.\n            // When tracking views manually, we use the ViewOptions from the first startView call as the\n            // initial view options, and we remove the actual startView call so we don't create an extra\n            // view.\n            bufferApiCalls.remove(firstStartViewCall.callback);\n            initialViewOptions = firstStartViewCall.options;\n        }\n        const startRumResult = doStartRum(cachedConfiguration, deflateWorker, initialViewOptions);\n        bufferApiCalls.drain(startRumResult);\n    }\n    function doInit(initConfiguration) {\n        const eventBridgeAvailable = canUseEventBridge();\n        if (eventBridgeAvailable) {\n            initConfiguration = overrideInitConfigurationForBridge(initConfiguration);\n        }\n        // Update the exposed initConfiguration to reflect the bridge and remote configuration overrides\n        cachedInitConfiguration = initConfiguration;\n        addTelemetryConfiguration(serializeRumConfiguration(initConfiguration));\n        if (cachedConfiguration) {\n            displayAlreadyInitializedError('DD_RUM', initConfiguration);\n            return;\n        }\n        const configuration = validateAndBuildRumConfiguration(initConfiguration);\n        if (!configuration) {\n            return;\n        }\n        if (!eventBridgeAvailable && !configuration.sessionStoreStrategyType) {\n            display.warn('No storage available for session. We will not send any data.');\n            return;\n        }\n        if (configuration.compressIntakeRequests && !eventBridgeAvailable && startDeflateWorker) {\n            deflateWorker = startDeflateWorker(configuration, 'Datadog RUM', \n            // Worker initialization can fail asynchronously, especially in Firefox where even CSP\n            // issues are reported asynchronously. For now, the SDK will continue its execution even if\n            // data won't be sent to Datadog. We could improve this behavior in the future.\n            noop);\n            if (!deflateWorker) {\n                // `startDeflateWorker` should have logged an error message explaining the issue\n                return;\n            }\n        }\n        cachedConfiguration = configuration;\n        // Instrumuent fetch to track network requests\n        // This is needed in case the consent is not granted and some cutsomer\n        // library (Apollo Client) is storing uninstrumented fetch to be used later\n        // The subscrption is needed so that the instrumentation process is completed\n        initFetchObservable().subscribe(noop);\n        trackingConsentState.tryToInit(configuration.trackingConsent);\n        tryStartRum();\n    }\n    const addDurationVital = (vital) => {\n        bufferApiCalls.add((startRumResult) => startRumResult.addDurationVital(vital));\n    };\n    const strategy = {\n        init(initConfiguration, publicApi) {\n            if (!initConfiguration) {\n                display.error('Missing configuration');\n                return;\n            }\n            // Set the experimental feature flags as early as possible, so we can use them in most places\n            initFeatureFlags(initConfiguration.enableExperimentalFeatures);\n            // Expose the initial configuration regardless of initialization success.\n            cachedInitConfiguration = initConfiguration;\n            // If we are in a Synthetics test configured to automatically inject a RUM instance, we want\n            // to completely discard the customer application RUM instance by ignoring their init() call.\n            // But, we should not ignore the init() call from the Synthetics-injected RUM instance, so the\n            // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.\n            if (ignoreInitIfSyntheticsWillInjectRum && willSyntheticsInjectRum()) {\n                return;\n            }\n            callPluginsMethod(initConfiguration.plugins, 'onInit', { initConfiguration, publicApi });\n            if (initConfiguration.remoteConfigurationId) {\n                fetchAndApplyRemoteConfiguration(initConfiguration, doInit);\n            }\n            else {\n                doInit(initConfiguration);\n            }\n        },\n        get initConfiguration() {\n            return cachedInitConfiguration;\n        },\n        getInternalContext: noop,\n        stopSession: noop,\n        addTiming(name, time = timeStampNow()) {\n            bufferApiCalls.add((startRumResult) => startRumResult.addTiming(name, time));\n        },\n        startView(options, startClocks = clocksNow()) {\n            const callback = (startRumResult) => {\n                startRumResult.startView(options, startClocks);\n            };\n            bufferApiCalls.add(callback);\n            if (!firstStartViewCall) {\n                firstStartViewCall = { options, callback };\n                tryStartRum();\n            }\n        },\n        setViewName(name) {\n            bufferApiCalls.add((startRumResult) => startRumResult.setViewName(name));\n        },\n        setViewContext(context) {\n            bufferApiCalls.add((startRumResult) => startRumResult.setViewContext(context));\n        },\n        setViewContextProperty(key, value) {\n            bufferApiCalls.add((startRumResult) => startRumResult.setViewContextProperty(key, value));\n        },\n        getViewContext: () => emptyContext,\n        addAction(action, commonContext = getCommonContext()) {\n            bufferApiCalls.add((startRumResult) => startRumResult.addAction(action, commonContext));\n        },\n        addError(providedError, commonContext = getCommonContext()) {\n            bufferApiCalls.add((startRumResult) => startRumResult.addError(providedError, commonContext));\n        },\n        addFeatureFlagEvaluation(key, value) {\n            bufferApiCalls.add((startRumResult) => startRumResult.addFeatureFlagEvaluation(key, value));\n        },\n        startDurationVital(name, options) {\n            return startDurationVital(customVitalsState, name, options);\n        },\n        stopDurationVital(name, options) {\n            stopDurationVital(addDurationVital, customVitalsState, name, options);\n        },\n        addDurationVital,\n    };\n    return strategy;\n}\nfunction overrideInitConfigurationForBridge(initConfiguration) {\n    var _a, _b;\n    return {\n        ...initConfiguration,\n        applicationId: '00000000-aaaa-0000-aaaa-000000000000',\n        clientToken: 'empty',\n        sessionSampleRate: 100,\n        defaultPrivacyLevel: (_a = initConfiguration.defaultPrivacyLevel) !== null && _a !== void 0 ? _a : (_b = getEventBridge()) === null || _b === void 0 ? void 0 : _b.getPrivacyLevel(),\n    };\n}\n//# sourceMappingURL=preStartRum.js.map","import { addTelemetryUsage, createContextManager, deepClone, makePublicApi, monitor, clocksNow, callMonitored, createHandlingStack, sanitize, createIdentityEncoder, createCustomerDataTrackerManager, storeContextManager, displayAlreadyInitializedError, createTrackingConsentState, timeStampToClocks, } from '@datadog/browser-core';\nimport { buildCommonContext } from '../domain/contexts/commonContext';\nimport { createCustomVitalsState } from '../domain/vital/vitalCollection';\nimport { callPluginsMethod } from '../domain/plugins';\nimport { createPreStartStrategy } from './preStartRum';\nconst RUM_STORAGE_KEY = 'rum';\nexport function makeRumPublicApi(startRumImpl, recorderApi, options = {}) {\n    const customerDataTrackerManager = createCustomerDataTrackerManager(0 /* CustomerDataCompressionStatus.Unknown */);\n    const globalContextManager = createContextManager('global context', {\n        customerDataTracker: customerDataTrackerManager.getOrCreateTracker(2 /* CustomerDataType.GlobalContext */),\n    });\n    const userContextManager = createContextManager('user', {\n        customerDataTracker: customerDataTrackerManager.getOrCreateTracker(1 /* CustomerDataType.User */),\n        propertiesConfig: {\n            id: { type: 'string' },\n            name: { type: 'string' },\n            email: { type: 'string' },\n        },\n    });\n    const accountContextManager = createContextManager('account', {\n        customerDataTracker: customerDataTrackerManager.getOrCreateTracker(1 /* CustomerDataType.User */),\n        propertiesConfig: {\n            id: { type: 'string', required: true },\n            name: { type: 'string' },\n        },\n    });\n    const trackingConsentState = createTrackingConsentState();\n    const customVitalsState = createCustomVitalsState();\n    function getCommonContext() {\n        return buildCommonContext(globalContextManager, userContextManager, accountContextManager, recorderApi);\n    }\n    let strategy = createPreStartStrategy(options, getCommonContext, trackingConsentState, customVitalsState, (configuration, deflateWorker, initialViewOptions) => {\n        if (configuration.storeContextsAcrossPages) {\n            storeContextManager(configuration, globalContextManager, RUM_STORAGE_KEY, 2 /* CustomerDataType.GlobalContext */);\n            storeContextManager(configuration, userContextManager, RUM_STORAGE_KEY, 1 /* CustomerDataType.User */);\n            storeContextManager(configuration, accountContextManager, RUM_STORAGE_KEY, 4 /* CustomerDataType.Account */);\n        }\n        customerDataTrackerManager.setCompressionStatus(deflateWorker ? 1 /* CustomerDataCompressionStatus.Enabled */ : 2 /* CustomerDataCompressionStatus.Disabled */);\n        const startRumResult = startRumImpl(configuration, recorderApi, customerDataTrackerManager, getCommonContext, initialViewOptions, deflateWorker && options.createDeflateEncoder\n            ? (streamId) => options.createDeflateEncoder(configuration, deflateWorker, streamId)\n            : createIdentityEncoder, trackingConsentState, customVitalsState);\n        recorderApi.onRumStart(startRumResult.lifeCycle, configuration, startRumResult.session, startRumResult.viewHistory, deflateWorker);\n        strategy = createPostStartStrategy(strategy, startRumResult);\n        callPluginsMethod(configuration.plugins, 'onRumStart', { strategy });\n        return startRumResult;\n    });\n    const startView = monitor((options) => {\n        const sanitizedOptions = typeof options === 'object' ? options : { name: options };\n        if (sanitizedOptions.context) {\n            customerDataTrackerManager.getOrCreateTracker(3 /* CustomerDataType.View */).updateCustomerData(sanitizedOptions.context);\n        }\n        strategy.startView(sanitizedOptions);\n        addTelemetryUsage({ feature: 'start-view' });\n    });\n    const rumPublicApi = makePublicApi({\n        init: monitor((initConfiguration) => {\n            strategy.init(initConfiguration, rumPublicApi);\n        }),\n        setTrackingConsent: monitor((trackingConsent) => {\n            trackingConsentState.update(trackingConsent);\n            addTelemetryUsage({ feature: 'set-tracking-consent', tracking_consent: trackingConsent });\n        }),\n        setViewName: monitor((name) => {\n            strategy.setViewName(name);\n            addTelemetryUsage({ feature: 'set-view-name' });\n        }),\n        setViewContext: monitor((context) => {\n            strategy.setViewContext(context);\n            addTelemetryUsage({ feature: 'set-view-context' });\n        }),\n        setViewContextProperty: monitor((key, value) => {\n            strategy.setViewContextProperty(key, value);\n            addTelemetryUsage({ feature: 'set-view-context-property' });\n        }),\n        getViewContext: monitor(() => {\n            addTelemetryUsage({ feature: 'set-view-context-property' });\n            return strategy.getViewContext();\n        }),\n        setGlobalContext: monitor((context) => {\n            globalContextManager.setContext(context);\n            addTelemetryUsage({ feature: 'set-global-context' });\n        }),\n        getGlobalContext: monitor(() => globalContextManager.getContext()),\n        setGlobalContextProperty: monitor((key, value) => {\n            globalContextManager.setContextProperty(key, value);\n            addTelemetryUsage({ feature: 'set-global-context' });\n        }),\n        removeGlobalContextProperty: monitor((key) => globalContextManager.removeContextProperty(key)),\n        clearGlobalContext: monitor(() => globalContextManager.clearContext()),\n        getInternalContext: monitor((startTime) => strategy.getInternalContext(startTime)),\n        getInitConfiguration: monitor(() => deepClone(strategy.initConfiguration)),\n        addAction: (name, context) => {\n            const handlingStack = createHandlingStack('action');\n            callMonitored(() => {\n                strategy.addAction({\n                    name: sanitize(name),\n                    context: sanitize(context),\n                    startClocks: clocksNow(),\n                    type: \"custom\" /* ActionType.CUSTOM */,\n                    handlingStack,\n                });\n                addTelemetryUsage({ feature: 'add-action' });\n            });\n        },\n        addError: (error, context) => {\n            const handlingStack = createHandlingStack('error');\n            callMonitored(() => {\n                strategy.addError({\n                    error, // Do not sanitize error here, it is needed unserialized by computeRawError()\n                    handlingStack,\n                    context: sanitize(context),\n                    startClocks: clocksNow(),\n                });\n                addTelemetryUsage({ feature: 'add-error' });\n            });\n        },\n        addTiming: monitor((name, time) => {\n            // TODO: next major decide to drop relative time support or update its behaviour\n            strategy.addTiming(sanitize(name), time);\n        }),\n        setUser: monitor((newUser) => {\n            userContextManager.setContext(newUser);\n            addTelemetryUsage({ feature: 'set-user' });\n        }),\n        getUser: monitor(userContextManager.getContext),\n        setUserProperty: monitor((key, property) => {\n            userContextManager.setContextProperty(key, property);\n            addTelemetryUsage({ feature: 'set-user' });\n        }),\n        removeUserProperty: monitor(userContextManager.removeContextProperty),\n        clearUser: monitor(userContextManager.clearContext),\n        setAccount: monitor(accountContextManager.setContext),\n        getAccount: monitor(accountContextManager.getContext),\n        setAccountProperty: monitor(accountContextManager.setContextProperty),\n        removeAccountProperty: monitor(accountContextManager.removeContextProperty),\n        clearAccount: monitor(accountContextManager.clearContext),\n        startView,\n        stopSession: monitor(() => {\n            strategy.stopSession();\n            addTelemetryUsage({ feature: 'stop-session' });\n        }),\n        addFeatureFlagEvaluation: monitor((key, value) => {\n            strategy.addFeatureFlagEvaluation(sanitize(key), sanitize(value));\n            addTelemetryUsage({ feature: 'add-feature-flag-evaluation' });\n        }),\n        getSessionReplayLink: monitor(() => recorderApi.getSessionReplayLink()),\n        startSessionReplayRecording: monitor((options) => {\n            recorderApi.start(options);\n            addTelemetryUsage({ feature: 'start-session-replay-recording', force: options && options.force });\n        }),\n        stopSessionReplayRecording: monitor(() => recorderApi.stop()),\n        addDurationVital: monitor((name, options) => {\n            addTelemetryUsage({ feature: 'add-duration-vital' });\n            strategy.addDurationVital({\n                name: sanitize(name),\n                type: \"duration\" /* VitalType.DURATION */,\n                startClocks: timeStampToClocks(options.startTime),\n                duration: options.duration,\n                context: sanitize(options && options.context),\n                description: sanitize(options && options.description),\n            });\n        }),\n        startDurationVital: monitor((name, options) => {\n            addTelemetryUsage({ feature: 'start-duration-vital' });\n            return strategy.startDurationVital(sanitize(name), {\n                context: sanitize(options && options.context),\n                description: sanitize(options && options.description),\n            });\n        }),\n        stopDurationVital: monitor((nameOrRef, options) => {\n            addTelemetryUsage({ feature: 'stop-duration-vital' });\n            strategy.stopDurationVital(typeof nameOrRef === 'string' ? sanitize(nameOrRef) : nameOrRef, {\n                context: sanitize(options && options.context),\n                description: sanitize(options && options.description),\n            });\n        }),\n    });\n    return rumPublicApi;\n}\nfunction createPostStartStrategy(preStartStrategy, startRumResult) {\n    return {\n        init: (initConfiguration) => {\n            displayAlreadyInitializedError('DD_RUM', initConfiguration);\n        },\n        initConfiguration: preStartStrategy.initConfiguration,\n        ...startRumResult,\n    };\n}\n//# sourceMappingURL=rumPublicApi.js.map","import { monitor, noop, Observable, getZoneJsOriginalValue } from '@datadog/browser-core';\nexport function createDOMMutationObservable() {\n    const MutationObserver = getMutationObserverConstructor();\n    return new Observable((observable) => {\n        if (!MutationObserver) {\n            return;\n        }\n        const observer = new MutationObserver(monitor(() => observable.notify()));\n        observer.observe(document, {\n            attributes: true,\n            characterData: true,\n            childList: true,\n            subtree: true,\n        });\n        return () => observer.disconnect();\n    });\n}\nexport function getMutationObserverConstructor() {\n    let constructor;\n    const browserWindow = window;\n    // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n    // global MutationObserver constructor with a patched version to support the context propagation.\n    // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n    // component: on some occasions, the callback is being called in an infinite loop, causing the\n    // page to freeze (even if the callback is completely empty).\n    //\n    // To work around this issue, we try to get the original MutationObserver constructor stored by\n    // Zone.js.\n    //\n    // [1] https://github.com/angular/angular/issues/26948\n    // [2] https://github.com/angular/angular/issues/31712\n    if (browserWindow.Zone) {\n        // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n        //\n        // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n        constructor = getZoneJsOriginalValue(browserWindow, 'MutationObserver');\n        if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {\n            // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n            // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n            // instance in its properties[4]. Let's get the original MutationObserver constructor from\n            // there.\n            //\n            // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n            const patchedInstance = new browserWindow.MutationObserver(noop);\n            const originalInstance = getZoneJsOriginalValue(patchedInstance, 'originalInstance');\n            constructor = originalInstance && originalInstance.constructor;\n        }\n    }\n    if (!constructor) {\n        constructor = browserWindow.MutationObserver;\n    }\n    return constructor;\n}\n//# sourceMappingURL=domMutationObservable.js.map","import { sanitize, deepClone, getType, objectEntries } from '@datadog/browser-core';\n/**\n * Allows declaring and enforcing modifications to specific fields of an object.\n * Only supports modifying properties of an object (even if nested in an array).\n * Does not support array manipulation (adding/removing items).\n */\nexport function limitModification(object, modifiableFieldPaths, modifier) {\n    const clone = deepClone(object);\n    const result = modifier(clone);\n    objectEntries(modifiableFieldPaths).forEach(([fieldPath, fieldType]) => \n    // Traverse both object and clone simultaneously up to the path and apply the modification from the clone to the original object when the type is valid\n    setValueAtPath(object, clone, fieldPath.split(/\\.|(?=\\[\\])/), fieldType));\n    return result;\n}\nfunction setValueAtPath(object, clone, pathSegments, fieldType) {\n    const [field, ...restPathSegments] = pathSegments;\n    if (field === '[]') {\n        if (Array.isArray(object) && Array.isArray(clone)) {\n            object.forEach((item, i) => setValueAtPath(item, clone[i], restPathSegments, fieldType));\n        }\n        return;\n    }\n    if (!isValidObject(object) || !isValidObject(clone)) {\n        return;\n    }\n    if (restPathSegments.length > 0) {\n        return setValueAtPath(object[field], clone[field], restPathSegments, fieldType);\n    }\n    setNestedValue(object, field, clone[field], fieldType);\n}\nfunction setNestedValue(object, field, value, fieldType) {\n    const newType = getType(value);\n    if (newType === fieldType) {\n        object[field] = sanitize(value);\n    }\n    else if (fieldType === 'object' && (newType === 'undefined' || newType === 'null')) {\n        object[field] = {};\n    }\n}\nfunction isValidObject(object) {\n    return getType(object) === 'object';\n}\n//# sourceMappingURL=limitModification.js.map","import { combine, isEmptyObject, timeStampNow, currentDrift, display, createEventRateLimiter, canUseEventBridge, round, isExperimentalFeatureEnabled, ExperimentalFeature, getConnectivity, addTelemetryDebug, } from '@datadog/browser-core';\nimport { limitModification } from './limitModification';\nconst VIEW_MODIFIABLE_FIELD_PATHS = {\n    'view.name': 'string',\n    'view.url': 'string',\n    'view.referrer': 'string',\n};\nconst USER_CUSTOMIZABLE_FIELD_PATHS = {\n    context: 'object',\n};\nconst ROOT_MODIFIABLE_FIELD_PATHS = {\n    service: 'string',\n    version: 'string',\n};\nlet modifiableFieldPathsByEvent;\nexport function startRumAssembly(configuration, lifeCycle, hooks, sessionManager, viewHistory, urlContexts, displayContext, getCommonContext, reportError) {\n    modifiableFieldPathsByEvent = {\n        [\"view\" /* RumEventType.VIEW */]: {\n            'view.performance.lcp.resource_url': 'string',\n            ...USER_CUSTOMIZABLE_FIELD_PATHS,\n            ...VIEW_MODIFIABLE_FIELD_PATHS,\n        },\n        [\"error\" /* RumEventType.ERROR */]: {\n            'error.message': 'string',\n            'error.stack': 'string',\n            'error.resource.url': 'string',\n            'error.fingerprint': 'string',\n            ...USER_CUSTOMIZABLE_FIELD_PATHS,\n            ...VIEW_MODIFIABLE_FIELD_PATHS,\n            ...ROOT_MODIFIABLE_FIELD_PATHS,\n        },\n        [\"resource\" /* RumEventType.RESOURCE */]: {\n            'resource.url': 'string',\n            ...(isExperimentalFeatureEnabled(ExperimentalFeature.WRITABLE_RESOURCE_GRAPHQL)\n                ? { 'resource.graphql': 'object' }\n                : {}),\n            ...USER_CUSTOMIZABLE_FIELD_PATHS,\n            ...VIEW_MODIFIABLE_FIELD_PATHS,\n            ...ROOT_MODIFIABLE_FIELD_PATHS,\n        },\n        [\"action\" /* RumEventType.ACTION */]: {\n            'action.target.name': 'string',\n            ...USER_CUSTOMIZABLE_FIELD_PATHS,\n            ...VIEW_MODIFIABLE_FIELD_PATHS,\n            ...ROOT_MODIFIABLE_FIELD_PATHS,\n        },\n        [\"long_task\" /* RumEventType.LONG_TASK */]: {\n            'long_task.scripts[].source_url': 'string',\n            'long_task.scripts[].invoker': 'string',\n            ...USER_CUSTOMIZABLE_FIELD_PATHS,\n            ...VIEW_MODIFIABLE_FIELD_PATHS,\n        },\n        [\"vital\" /* RumEventType.VITAL */]: {\n            ...USER_CUSTOMIZABLE_FIELD_PATHS,\n            ...VIEW_MODIFIABLE_FIELD_PATHS,\n        },\n    };\n    const eventRateLimiters = {\n        [\"error\" /* RumEventType.ERROR */]: createEventRateLimiter(\"error\" /* RumEventType.ERROR */, configuration.eventRateLimiterThreshold, reportError),\n        [\"action\" /* RumEventType.ACTION */]: createEventRateLimiter(\"action\" /* RumEventType.ACTION */, configuration.eventRateLimiterThreshold, reportError),\n        [\"vital\" /* RumEventType.VITAL */]: createEventRateLimiter(\"vital\" /* RumEventType.VITAL */, configuration.eventRateLimiterThreshold, reportError),\n    };\n    lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, ({ startTime, rawRumEvent, domainContext, savedCommonContext, customerContext }) => {\n        const viewHistoryEntry = viewHistory.findView(startTime);\n        const urlContext = urlContexts.findUrl(startTime);\n        const session = sessionManager.findTrackedSession(startTime);\n        if (session &&\n            viewHistoryEntry &&\n            !urlContext &&\n            isExperimentalFeatureEnabled(ExperimentalFeature.MISSING_URL_CONTEXT_TELEMETRY)) {\n            addTelemetryDebug('Missing URL entry', {\n                debug: {\n                    eventType: rawRumEvent.type,\n                    startTime,\n                    urlEntries: urlContexts.getAllEntries(),\n                    urlDeletedEntries: urlContexts.getDeletedEntries(),\n                    viewEntries: viewHistory.getAllEntries(),\n                    viewDeletedEntries: viewHistory.getDeletedEntries(),\n                },\n            });\n        }\n        if (session && viewHistoryEntry && urlContext) {\n            const commonContext = savedCommonContext || getCommonContext();\n            const rumContext = {\n                _dd: {\n                    format_version: 2,\n                    drift: currentDrift(),\n                    configuration: {\n                        session_sample_rate: round(configuration.sessionSampleRate, 3),\n                        session_replay_sample_rate: round(configuration.sessionReplaySampleRate, 3),\n                    },\n                    browser_sdk_version: canUseEventBridge() ? \"6.4.0\" : undefined,\n                },\n                application: {\n                    id: configuration.applicationId,\n                },\n                date: timeStampNow(),\n                source: 'browser',\n                session: {\n                    id: session.id,\n                    type: \"user\" /* SessionType.USER */,\n                },\n                display: displayContext.get(),\n                connectivity: getConnectivity(),\n                context: commonContext.context,\n            };\n            const serverRumEvent = combine(rumContext, hooks.triggerHook(0 /* HookNames.Assemble */, { eventType: rawRumEvent.type, startTime }), { context: customerContext }, rawRumEvent);\n            if (!('has_replay' in serverRumEvent.session)) {\n                ;\n                serverRumEvent.session.has_replay = commonContext.hasReplay;\n            }\n            if (serverRumEvent.type === 'view') {\n                ;\n                serverRumEvent.session.sampled_for_replay =\n                    session.sessionReplay === 1 /* SessionReplayState.SAMPLED */;\n            }\n            if (session.anonymousId && !commonContext.user.anonymous_id && !!configuration.trackAnonymousUser) {\n                commonContext.user.anonymous_id = session.anonymousId;\n            }\n            if (!isEmptyObject(commonContext.user)) {\n                ;\n                serverRumEvent.usr = commonContext.user;\n            }\n            if (!isEmptyObject(commonContext.account) && commonContext.account.id) {\n                ;\n                serverRumEvent.account = commonContext.account;\n            }\n            if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {\n                if (isEmptyObject(serverRumEvent.context)) {\n                    delete serverRumEvent.context;\n                }\n                lifeCycle.notify(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, serverRumEvent);\n            }\n        }\n    });\n}\nfunction shouldSend(event, beforeSend, domainContext, eventRateLimiters) {\n    var _a;\n    if (beforeSend) {\n        const result = limitModification(event, modifiableFieldPathsByEvent[event.type], (event) => beforeSend(event, domainContext));\n        if (result === false && event.type !== \"view\" /* RumEventType.VIEW */) {\n            return false;\n        }\n        if (result === false) {\n            display.warn(\"Can't dismiss view events using beforeSend!\");\n        }\n    }\n    const rateLimitReached = (_a = eventRateLimiters[event.type]) === null || _a === void 0 ? void 0 : _a.isLimitReached();\n    return !rateLimitReached;\n}\n//# sourceMappingURL=assembly.js.map","import { AbstractLifeCycle } from '@datadog/browser-core';\nexport const LifeCycle = (AbstractLifeCycle);\n//# sourceMappingURL=lifeCycle.js.map","// eslint-disable-next-line no-restricted-syntax\nexport class AbstractLifeCycle {\n    constructor() {\n        this.callbacks = {};\n    }\n    notify(eventType, data) {\n        const eventCallbacks = this.callbacks[eventType];\n        if (eventCallbacks) {\n            eventCallbacks.forEach((callback) => callback(data));\n        }\n    }\n    subscribe(eventType, callback) {\n        if (!this.callbacks[eventType]) {\n            this.callbacks[eventType] = [];\n        }\n        this.callbacks[eventType].push(callback);\n        return {\n            unsubscribe: () => {\n                this.callbacks[eventType] = this.callbacks[eventType].filter((other) => callback !== other);\n            },\n        };\n    }\n}\n//# sourceMappingURL=abstractLifeCycle.js.map","import { SESSION_TIME_OUT_DELAY, createValueHistory } from '@datadog/browser-core';\nexport const VIEW_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;\nexport function startViewHistory(lifeCycle) {\n    const viewValueHistory = createValueHistory({ expireDelay: VIEW_CONTEXT_TIME_OUT_DELAY });\n    lifeCycle.subscribe(1 /* LifeCycleEventType.BEFORE_VIEW_CREATED */, (view) => {\n        viewValueHistory.add(buildViewHistoryEntry(view), view.startClocks.relative);\n    });\n    lifeCycle.subscribe(6 /* LifeCycleEventType.AFTER_VIEW_ENDED */, ({ endClocks }) => {\n        viewValueHistory.closeActive(endClocks.relative);\n    });\n    lifeCycle.subscribe(3 /* LifeCycleEventType.BEFORE_VIEW_UPDATED */, (viewUpdate) => {\n        const currentView = viewValueHistory.find(viewUpdate.startClocks.relative);\n        if (currentView && viewUpdate.name) {\n            currentView.name = viewUpdate.name;\n        }\n        if (currentView && viewUpdate.context) {\n            currentView.context = viewUpdate.context;\n        }\n    });\n    lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, () => {\n        viewValueHistory.reset();\n    });\n    function buildViewHistoryEntry(view) {\n        return {\n            service: view.service,\n            version: view.version,\n            context: view.context,\n            id: view.id,\n            name: view.name,\n            startClocks: view.startClocks,\n        };\n    }\n    return {\n        findView: (startTime) => viewValueHistory.find(startTime),\n        getAllEntries: () => viewValueHistory.getAllEntries(),\n        getDeletedEntries: () => viewValueHistory.getDeletedEntries(),\n        stop: () => {\n            viewValueHistory.stop();\n        },\n    };\n}\n//# sourceMappingURL=viewHistory.js.map","import { addTelemetryDebug, elapsed, getPathName, isValidUrl, toServerDuration, isIntakeUrl, } from '@datadog/browser-core';\nexport const FAKE_INITIAL_DOCUMENT = 'initial_document';\nconst RESOURCE_TYPES = [\n    [\"document\" /* ResourceType.DOCUMENT */, (initiatorType) => FAKE_INITIAL_DOCUMENT === initiatorType],\n    [\"xhr\" /* ResourceType.XHR */, (initiatorType) => 'xmlhttprequest' === initiatorType],\n    [\"fetch\" /* ResourceType.FETCH */, (initiatorType) => 'fetch' === initiatorType],\n    [\"beacon\" /* ResourceType.BEACON */, (initiatorType) => 'beacon' === initiatorType],\n    [\"css\" /* ResourceType.CSS */, (_, path) => /\\.css$/i.test(path)],\n    [\"js\" /* ResourceType.JS */, (_, path) => /\\.js$/i.test(path)],\n    [\n        \"image\" /* ResourceType.IMAGE */,\n        (initiatorType, path) => ['image', 'img', 'icon'].includes(initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null,\n    ],\n    [\"font\" /* ResourceType.FONT */, (_, path) => /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null],\n    [\n        \"media\" /* ResourceType.MEDIA */,\n        (initiatorType, path) => ['audio', 'video'].includes(initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null,\n    ],\n];\nexport function computeResourceEntryType(entry) {\n    const url = entry.name;\n    if (!isValidUrl(url)) {\n        addTelemetryDebug(`Failed to construct URL for \"${entry.name}\"`);\n        return \"other\" /* ResourceType.OTHER */;\n    }\n    const path = getPathName(url);\n    for (const [type, isType] of RESOURCE_TYPES) {\n        if (isType(entry.initiatorType, path)) {\n            return type;\n        }\n    }\n    return \"other\" /* ResourceType.OTHER */;\n}\nfunction areInOrder(...numbers) {\n    for (let i = 1; i < numbers.length; i += 1) {\n        if (numbers[i - 1] > numbers[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function isResourceEntryRequestType(entry) {\n    return entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch';\n}\nexport function computeResourceEntryDuration(entry) {\n    const { duration, startTime, responseEnd } = entry;\n    // Safari duration is always 0 on timings blocked by cross origin policies.\n    if (duration === 0 && startTime < responseEnd) {\n        return toServerDuration(elapsed(startTime, responseEnd));\n    }\n    return toServerDuration(duration);\n}\nexport function computeResourceEntryDetails(entry) {\n    if (!hasValidResourceEntryTimings(entry)) {\n        return undefined;\n    }\n    const { startTime, fetchStart, workerStart, redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, secureConnectionStart, connectEnd, requestStart, responseStart, responseEnd, } = entry;\n    const details = {\n        download: formatTiming(startTime, responseStart, responseEnd),\n        first_byte: formatTiming(startTime, requestStart, responseStart),\n    };\n    // Make sure a worker processing time is recorded\n    if (0 < workerStart && workerStart < fetchStart) {\n        details.worker = formatTiming(startTime, workerStart, fetchStart);\n    }\n    // Make sure a connection occurred\n    if (fetchStart < connectEnd) {\n        details.connect = formatTiming(startTime, connectStart, connectEnd);\n        // Make sure a secure connection occurred\n        if (connectStart <= secureConnectionStart && secureConnectionStart <= connectEnd) {\n            details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);\n        }\n    }\n    // Make sure a domain lookup occurred\n    if (fetchStart < domainLookupEnd) {\n        details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);\n    }\n    // Make sure a redirection occurred\n    if (startTime < redirectEnd) {\n        details.redirect = formatTiming(startTime, redirectStart, redirectEnd);\n    }\n    return details;\n}\n/**\n * Entries with negative duration are unexpected and should be dismissed. The intake will ignore RUM\n * Resource events with negative durations anyway.\n * Since Chromium 128, more entries have unexpected negative durations, see\n * https://issues.chromium.org/issues/363031537\n */\nexport function hasValidResourceEntryDuration(entry) {\n    return entry.duration >= 0;\n}\nexport function hasValidResourceEntryTimings(entry) {\n    // Ensure timings are in the right order. On top of filtering out potential invalid\n    // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n    // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n    // it.\n    const areCommonTimingsInOrder = areInOrder(entry.startTime, entry.fetchStart, entry.domainLookupStart, entry.domainLookupEnd, entry.connectStart, entry.connectEnd, entry.requestStart, entry.responseStart, entry.responseEnd);\n    const areRedirectionTimingsInOrder = hasRedirection(entry)\n        ? areInOrder(entry.startTime, entry.redirectStart, entry.redirectEnd, entry.fetchStart)\n        : true;\n    return areCommonTimingsInOrder && areRedirectionTimingsInOrder;\n}\nfunction hasRedirection(entry) {\n    return entry.redirectEnd > entry.startTime;\n}\nfunction formatTiming(origin, start, end) {\n    if (origin <= start && start <= end) {\n        return {\n            duration: toServerDuration(elapsed(start, end)),\n            start: toServerDuration(elapsed(origin, start)),\n        };\n    }\n}\n/**\n * The 'nextHopProtocol' is an empty string for cross-origin resources without CORS headers,\n * meaning the protocol is unknown, and we shouldn't report it.\n * https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/nextHopProtocol#cross-origin_resources\n */\nexport function computeResourceEntryProtocol(entry) {\n    return entry.nextHopProtocol === '' ? undefined : entry.nextHopProtocol;\n}\n/**\n * Handles the 'deliveryType' property to distinguish between supported values ('cache', 'navigational-prefetch'),\n * undefined (unsupported in some browsers), and other cases ('other' for unknown or unrecognized values).\n * see: https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/deliveryType\n */\nexport function computeResourceEntryDeliveryType(entry) {\n    return entry.deliveryType === '' ? 'other' : entry.deliveryType;\n}\nexport function computeResourceEntrySize(entry) {\n    // Make sure a request actually occurred\n    if (entry.startTime < entry.responseStart) {\n        const { encodedBodySize, decodedBodySize, transferSize } = entry;\n        return {\n            size: decodedBodySize,\n            encoded_body_size: encodedBodySize,\n            decoded_body_size: decodedBodySize,\n            transfer_size: transferSize,\n        };\n    }\n    return {\n        size: undefined,\n        encoded_body_size: undefined,\n        decoded_body_size: undefined,\n        transfer_size: undefined,\n    };\n}\nexport function isAllowedRequestUrl(url) {\n    return url && !isIntakeUrl(url);\n}\nconst DATA_URL_REGEX = /data:(.+)?(;base64)?,/g;\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 24000;\nexport function isLongDataUrl(url) {\n    if (url.length <= MAX_ATTRIBUTE_VALUE_CHAR_LENGTH) {\n        return false;\n    }\n    else if (url.substring(0, 5) === 'data:') {\n        // Avoid String.match RangeError: Maximum call stack size exceeded\n        url = url.substring(0, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH);\n        return true;\n    }\n    return false;\n}\nexport function sanitizeDataUrl(url) {\n    return `${url.match(DATA_URL_REGEX)[0]}[...]`;\n}\n//# sourceMappingURL=resourceUtils.js.map","import { initFetchObservable, initXhrObservable, readBytesFromStream, elapsed, timeStampNow, tryToClone, } from '@datadog/browser-core';\nimport { isAllowedRequestUrl } from './resource/resourceUtils';\nimport { startTracer } from './tracing/tracer';\nlet nextRequestIndex = 1;\nexport function startRequestCollection(lifeCycle, configuration, sessionManager) {\n    const tracer = startTracer(configuration, sessionManager);\n    trackXhr(lifeCycle, configuration, tracer);\n    trackFetch(lifeCycle, tracer);\n}\nexport function trackXhr(lifeCycle, configuration, tracer) {\n    const subscription = initXhrObservable(configuration).subscribe((rawContext) => {\n        const context = rawContext;\n        if (!isAllowedRequestUrl(context.url)) {\n            return;\n        }\n        switch (context.state) {\n            case 'start':\n                tracer.traceXhr(context, context.xhr);\n                context.requestIndex = getNextRequestIndex();\n                lifeCycle.notify(7 /* LifeCycleEventType.REQUEST_STARTED */, {\n                    requestIndex: context.requestIndex,\n                    url: context.url,\n                });\n                break;\n            case 'complete':\n                tracer.clearTracingIfNeeded(context);\n                lifeCycle.notify(8 /* LifeCycleEventType.REQUEST_COMPLETED */, {\n                    duration: context.duration,\n                    method: context.method,\n                    requestIndex: context.requestIndex,\n                    spanId: context.spanId,\n                    startClocks: context.startClocks,\n                    status: context.status,\n                    traceId: context.traceId,\n                    traceSampled: context.traceSampled,\n                    type: \"xhr\" /* RequestType.XHR */,\n                    url: context.url,\n                    xhr: context.xhr,\n                    isAborted: context.isAborted,\n                    handlingStack: context.handlingStack,\n                });\n                break;\n        }\n    });\n    return { stop: () => subscription.unsubscribe() };\n}\nexport function trackFetch(lifeCycle, tracer) {\n    const subscription = initFetchObservable().subscribe((rawContext) => {\n        const context = rawContext;\n        if (!isAllowedRequestUrl(context.url)) {\n            return;\n        }\n        switch (context.state) {\n            case 'start':\n                tracer.traceFetch(context);\n                context.requestIndex = getNextRequestIndex();\n                lifeCycle.notify(7 /* LifeCycleEventType.REQUEST_STARTED */, {\n                    requestIndex: context.requestIndex,\n                    url: context.url,\n                });\n                break;\n            case 'resolve':\n                waitForResponseToComplete(context, (duration) => {\n                    tracer.clearTracingIfNeeded(context);\n                    lifeCycle.notify(8 /* LifeCycleEventType.REQUEST_COMPLETED */, {\n                        duration,\n                        method: context.method,\n                        requestIndex: context.requestIndex,\n                        responseType: context.responseType,\n                        spanId: context.spanId,\n                        startClocks: context.startClocks,\n                        status: context.status,\n                        traceId: context.traceId,\n                        traceSampled: context.traceSampled,\n                        type: \"fetch\" /* RequestType.FETCH */,\n                        url: context.url,\n                        response: context.response,\n                        init: context.init,\n                        input: context.input,\n                        isAborted: context.isAborted,\n                        handlingStack: context.handlingStack,\n                    });\n                });\n                break;\n        }\n    });\n    return { stop: () => subscription.unsubscribe() };\n}\nfunction getNextRequestIndex() {\n    const result = nextRequestIndex;\n    nextRequestIndex += 1;\n    return result;\n}\nfunction waitForResponseToComplete(context, callback) {\n    const clonedResponse = context.response && tryToClone(context.response);\n    if (!clonedResponse || !clonedResponse.body) {\n        // do not try to wait for the response if the clone failed, fetch error or null body\n        callback(elapsed(context.startClocks.timeStamp, timeStampNow()));\n    }\n    else {\n        readBytesFromStream(clonedResponse.body, () => {\n            callback(elapsed(context.startClocks.timeStamp, timeStampNow()));\n        }, {\n            bytesLimit: Number.POSITIVE_INFINITY,\n            collectStreamBody: false,\n        });\n    }\n}\n//# sourceMappingURL=requestCollection.js.map","import { monitor } from './monitor';\nimport { noop } from './utils/functionUtils';\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(stream, callback, options) {\n    const reader = stream.getReader();\n    const chunks = [];\n    let readBytesCount = 0;\n    readMore();\n    function readMore() {\n        reader.read().then(monitor((result) => {\n            if (result.done) {\n                onDone();\n                return;\n            }\n            if (options.collectStreamBody) {\n                chunks.push(result.value);\n            }\n            readBytesCount += result.value.length;\n            if (readBytesCount > options.bytesLimit) {\n                onDone();\n            }\n            else {\n                readMore();\n            }\n        }), monitor((error) => callback(error)));\n    }\n    function onDone() {\n        reader.cancel().catch(\n        // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n        // as an unhandled rejection\n        noop);\n        let bytes;\n        let limitExceeded;\n        if (options.collectStreamBody) {\n            let completeBuffer;\n            if (chunks.length === 1) {\n                // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n                // use it directly.\n                completeBuffer = chunks[0];\n            }\n            else {\n                // else, we need to copy buffers into a larger buffer to concatenate them.\n                completeBuffer = new Uint8Array(readBytesCount);\n                let offset = 0;\n                chunks.forEach((chunk) => {\n                    completeBuffer.set(chunk, offset);\n                    offset += chunk.length;\n                });\n            }\n            bytes = completeBuffer.slice(0, options.bytesLimit);\n            limitExceeded = completeBuffer.length > options.bytesLimit;\n        }\n        callback(undefined, bytes, limitExceeded);\n    }\n}\n//# sourceMappingURL=readBytesFromStream.js.map","import { isNumber } from '@datadog/browser-core';\nexport function discardNegativeDuration(duration) {\n    return isNumber(duration) && duration < 0 ? undefined : duration;\n}\n//# sourceMappingURL=discardNegativeDuration.js.map","import { noop } from '@datadog/browser-core';\nexport function trackEventCounts({ lifeCycle, isChildEvent, onChange: callback = noop, }) {\n    const eventCounts = {\n        errorCount: 0,\n        longTaskCount: 0,\n        resourceCount: 0,\n        actionCount: 0,\n        frustrationCount: 0,\n    };\n    const subscription = lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, (event) => {\n        var _a;\n        if (event.type === 'view' || event.type === 'vital' || !isChildEvent(event)) {\n            return;\n        }\n        switch (event.type) {\n            case \"error\" /* RumEventType.ERROR */:\n                eventCounts.errorCount += 1;\n                callback();\n                break;\n            case \"action\" /* RumEventType.ACTION */:\n                eventCounts.actionCount += 1;\n                if (event.action.frustration) {\n                    eventCounts.frustrationCount += event.action.frustration.type.length;\n                }\n                callback();\n                break;\n            case \"long_task\" /* RumEventType.LONG_TASK */:\n                eventCounts.longTaskCount += 1;\n                callback();\n                break;\n            case \"resource\" /* RumEventType.RESOURCE */:\n                if (!((_a = event._dd) === null || _a === void 0 ? void 0 : _a.discarded)) {\n                    eventCounts.resourceCount += 1;\n                    callback();\n                }\n                break;\n        }\n    });\n    return {\n        stop: () => {\n            subscription.unsubscribe();\n        },\n        eventCounts,\n    };\n}\n//# sourceMappingURL=trackEventCounts.js.map","import { addEventListeners, dateNow, relativeNow } from '@datadog/browser-core';\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nexport function retrieveFirstInputTiming(configuration, callback) {\n    const startTimeStamp = dateNow();\n    let timingSent = false;\n    const { stop: removeEventListeners } = addEventListeners(configuration, window, [\"click\" /* DOM_EVENT.CLICK */, \"mousedown\" /* DOM_EVENT.MOUSE_DOWN */, \"keydown\" /* DOM_EVENT.KEY_DOWN */, \"touchstart\" /* DOM_EVENT.TOUCH_START */, \"pointerdown\" /* DOM_EVENT.POINTER_DOWN */], (evt) => {\n        // Only count cancelable events, which should trigger behavior important to the user.\n        if (!evt.cancelable) {\n            return;\n        }\n        // This timing will be used to compute the \"first Input delay\", which is the delta between\n        // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n        // (e.g. performance.now()).\n        const timing = {\n            entryType: 'first-input',\n            processingStart: relativeNow(),\n            processingEnd: relativeNow(),\n            startTime: evt.timeStamp,\n            duration: 0, // arbitrary value to avoid nullable duration and simplify INP logic\n            name: '',\n            cancelable: false,\n            target: null,\n            toJSON: () => ({}),\n        };\n        if (evt.type === \"pointerdown\" /* DOM_EVENT.POINTER_DOWN */) {\n            sendTimingIfPointerIsNotCancelled(configuration, timing);\n        }\n        else {\n            sendTiming(timing);\n        }\n    }, { passive: true, capture: true });\n    return { stop: removeEventListeners };\n    /**\n     * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n     * We differentiate these cases based on whether or not we see a pointercancel event, which are\n     * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n     * scrolling and pinch/zooming.\n     */\n    function sendTimingIfPointerIsNotCancelled(configuration, timing) {\n        addEventListeners(configuration, window, [\"pointerup\" /* DOM_EVENT.POINTER_UP */, \"pointercancel\" /* DOM_EVENT.POINTER_CANCEL */], (event) => {\n            if (event.type === \"pointerup\" /* DOM_EVENT.POINTER_UP */) {\n                sendTiming(timing);\n            }\n        }, { once: true });\n    }\n    function sendTiming(timing) {\n        if (!timingSent) {\n            timingSent = true;\n            removeEventListeners();\n            // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n            // the time between now and when the page was loaded.\n            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n            const delay = timing.processingStart - timing.startTime;\n            if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n                callback(timing);\n            }\n        }\n    }\n}\n//# sourceMappingURL=firstInputPolyfill.js.map","import { addEventListener, Observable, setTimeout, clearTimeout, monitor } from '@datadog/browser-core';\nimport { hasValidResourceEntryDuration, isAllowedRequestUrl } from '../domain/resource/resourceUtils';\nimport { retrieveFirstInputTiming } from './firstInputPolyfill';\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected performance entry\n// eslint-disable-next-line no-restricted-syntax\nexport var RumPerformanceEntryType;\n(function (RumPerformanceEntryType) {\n    RumPerformanceEntryType[\"EVENT\"] = \"event\";\n    RumPerformanceEntryType[\"FIRST_INPUT\"] = \"first-input\";\n    RumPerformanceEntryType[\"LARGEST_CONTENTFUL_PAINT\"] = \"largest-contentful-paint\";\n    RumPerformanceEntryType[\"LAYOUT_SHIFT\"] = \"layout-shift\";\n    RumPerformanceEntryType[\"LONG_TASK\"] = \"longtask\";\n    RumPerformanceEntryType[\"LONG_ANIMATION_FRAME\"] = \"long-animation-frame\";\n    RumPerformanceEntryType[\"NAVIGATION\"] = \"navigation\";\n    RumPerformanceEntryType[\"PAINT\"] = \"paint\";\n    RumPerformanceEntryType[\"RESOURCE\"] = \"resource\";\n})(RumPerformanceEntryType || (RumPerformanceEntryType = {}));\nexport function createPerformanceObservable(configuration, options) {\n    return new Observable((observable) => {\n        if (!window.PerformanceObserver) {\n            return;\n        }\n        const handlePerformanceEntries = (entries) => {\n            const rumPerformanceEntries = filterRumPerformanceEntries(entries);\n            if (rumPerformanceEntries.length > 0) {\n                observable.notify(rumPerformanceEntries);\n            }\n        };\n        let timeoutId;\n        let isObserverInitializing = true;\n        const observer = new PerformanceObserver(monitor((entries) => {\n            // In Safari the performance observer callback is synchronous.\n            // Because the buffered performance entry list can be quite large we delay the computation to prevent the SDK from blocking the main thread on init\n            if (isObserverInitializing) {\n                timeoutId = setTimeout(() => handlePerformanceEntries(entries.getEntries()));\n            }\n            else {\n                handlePerformanceEntries(entries.getEntries());\n            }\n        }));\n        try {\n            observer.observe(options);\n        }\n        catch (_a) {\n            // Some old browser versions (<= chrome 74 ) don't support the PerformanceObserver type and buffered options\n            // In these cases, fallback to getEntriesByType and PerformanceObserver with entryTypes\n            // TODO: remove this fallback in the next major version\n            const fallbackSupportedEntryTypes = [\n                RumPerformanceEntryType.RESOURCE,\n                RumPerformanceEntryType.NAVIGATION,\n                RumPerformanceEntryType.LONG_TASK,\n                RumPerformanceEntryType.PAINT,\n            ];\n            if (fallbackSupportedEntryTypes.includes(options.type)) {\n                if (options.buffered) {\n                    timeoutId = setTimeout(() => handlePerformanceEntries(performance.getEntriesByType(options.type)));\n                }\n                try {\n                    observer.observe({ entryTypes: [options.type] });\n                }\n                catch (_b) {\n                    // Old versions of Safari are throwing \"entryTypes contained only unsupported types\"\n                    // errors when observing only unsupported entry types.\n                    //\n                    // We could use `supportPerformanceTimingEvent` to make sure we don't invoke\n                    // `observer.observe` with an unsupported entry type, but Safari 11 and 12 don't support\n                    // `Performance.supportedEntryTypes`, so doing so would lose support for these versions\n                    // even if they do support the entry type.\n                    return;\n                }\n            }\n        }\n        isObserverInitializing = false;\n        manageResourceTimingBufferFull(configuration);\n        let stopFirstInputTiming;\n        if (!supportPerformanceTimingEvent(RumPerformanceEntryType.FIRST_INPUT) &&\n            options.type === RumPerformanceEntryType.FIRST_INPUT) {\n            ;\n            ({ stop: stopFirstInputTiming } = retrieveFirstInputTiming(configuration, (timing) => {\n                handlePerformanceEntries([timing]);\n            }));\n        }\n        return () => {\n            observer.disconnect();\n            if (stopFirstInputTiming) {\n                stopFirstInputTiming();\n            }\n            clearTimeout(timeoutId);\n        };\n    });\n}\nlet resourceTimingBufferFullListener;\nfunction manageResourceTimingBufferFull(configuration) {\n    if (!resourceTimingBufferFullListener && supportPerformanceObject() && 'addEventListener' in performance) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n        resourceTimingBufferFullListener = addEventListener(configuration, performance, 'resourcetimingbufferfull', () => {\n            performance.clearResourceTimings();\n        });\n    }\n    return () => {\n        resourceTimingBufferFullListener === null || resourceTimingBufferFullListener === void 0 ? void 0 : resourceTimingBufferFullListener.stop();\n    };\n}\nfunction supportPerformanceObject() {\n    return window.performance !== undefined && 'getEntries' in performance;\n}\nexport function supportPerformanceTimingEvent(entryType) {\n    return (window.PerformanceObserver &&\n        PerformanceObserver.supportedEntryTypes !== undefined &&\n        PerformanceObserver.supportedEntryTypes.includes(entryType));\n}\nfunction filterRumPerformanceEntries(entries) {\n    return entries.filter((entry) => !isForbiddenResource(entry));\n}\nfunction isForbiddenResource(entry) {\n    return (entry.entryType === RumPerformanceEntryType.RESOURCE &&\n        (!isAllowedRequestUrl(entry.name) || !hasValidResourceEntryDuration(entry)));\n}\n//# sourceMappingURL=performanceObservable.js.map","import { matchList, monitor, Observable, timeStampNow, setTimeout, clearTimeout } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../browser/performanceObservable';\n// Delay to wait for a page activity to validate the tracking process\nexport const PAGE_ACTIVITY_VALIDATION_DELAY = 100;\n// Delay to wait after a page activity to end the tracking process\nexport const PAGE_ACTIVITY_END_DELAY = 100;\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, pageActivityEndCallback, maxDuration) {\n    const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, windowOpenObservable, configuration);\n    return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration);\n}\nexport function doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration) {\n    let pageActivityEndTimeoutId;\n    let hasCompleted = false;\n    const validationTimeoutId = setTimeout(monitor(() => complete({ hadActivity: false })), PAGE_ACTIVITY_VALIDATION_DELAY);\n    const maxDurationTimeoutId = maxDuration !== undefined\n        ? setTimeout(monitor(() => complete({ hadActivity: true, end: timeStampNow() })), maxDuration)\n        : undefined;\n    const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {\n        clearTimeout(validationTimeoutId);\n        clearTimeout(pageActivityEndTimeoutId);\n        const lastChangeTime = timeStampNow();\n        if (!isBusy) {\n            pageActivityEndTimeoutId = setTimeout(monitor(() => complete({ hadActivity: true, end: lastChangeTime })), PAGE_ACTIVITY_END_DELAY);\n        }\n    });\n    const stop = () => {\n        hasCompleted = true;\n        clearTimeout(validationTimeoutId);\n        clearTimeout(pageActivityEndTimeoutId);\n        clearTimeout(maxDurationTimeoutId);\n        pageActivitySubscription.unsubscribe();\n    };\n    function complete(event) {\n        if (hasCompleted) {\n            return;\n        }\n        stop();\n        pageActivityEndCallback(event);\n    }\n    return { stop };\n}\nexport function createPageActivityObservable(lifeCycle, domMutationObservable, windowOpenObservable, configuration) {\n    return new Observable((observable) => {\n        const subscriptions = [];\n        let firstRequestIndex;\n        let pendingRequestsCount = 0;\n        subscriptions.push(domMutationObservable.subscribe(notifyPageActivity), windowOpenObservable.subscribe(notifyPageActivity), createPerformanceObservable(configuration, { type: RumPerformanceEntryType.RESOURCE }).subscribe((entries) => {\n            if (entries.some((entry) => !isExcludedUrl(configuration, entry.name))) {\n                notifyPageActivity();\n            }\n        }), lifeCycle.subscribe(7 /* LifeCycleEventType.REQUEST_STARTED */, (startEvent) => {\n            if (isExcludedUrl(configuration, startEvent.url)) {\n                return;\n            }\n            if (firstRequestIndex === undefined) {\n                firstRequestIndex = startEvent.requestIndex;\n            }\n            pendingRequestsCount += 1;\n            notifyPageActivity();\n        }), lifeCycle.subscribe(8 /* LifeCycleEventType.REQUEST_COMPLETED */, (request) => {\n            if (isExcludedUrl(configuration, request.url) ||\n                firstRequestIndex === undefined ||\n                // If the request started before the tracking start, ignore it\n                request.requestIndex < firstRequestIndex) {\n                return;\n            }\n            pendingRequestsCount -= 1;\n            notifyPageActivity();\n        }));\n        return () => {\n            subscriptions.forEach((s) => s.unsubscribe());\n        };\n        function notifyPageActivity() {\n            observable.notify({ isBusy: pendingRequestsCount > 0 });\n        }\n    });\n}\nfunction isExcludedUrl(configuration, requestUrl) {\n    return matchList(configuration.excludedActivityUrls, requestUrl);\n}\n//# sourceMappingURL=waitPageActivityEnd.js.map","export function isTextNode(node) {\n    return node.nodeType === Node.TEXT_NODE;\n}\nexport function isCommentNode(node) {\n    return node.nodeType === Node.COMMENT_NODE;\n}\nexport function isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\nexport function isNodeShadowHost(node) {\n    return isElementNode(node) && Boolean(node.shadowRoot);\n}\nexport function isNodeShadowRoot(node) {\n    const shadowRoot = node;\n    return !!shadowRoot.host && shadowRoot.nodeType === Node.DOCUMENT_FRAGMENT_NODE && isElementNode(shadowRoot.host);\n}\nexport function hasChildNodes(node) {\n    return node.childNodes.length > 0 || isNodeShadowHost(node);\n}\nexport function forEachChildNodes(node, callback) {\n    let child = node.firstChild;\n    while (child) {\n        callback(child);\n        child = child.nextSibling;\n    }\n    if (isNodeShadowHost(node)) {\n        callback(node.shadowRoot);\n    }\n}\n/**\n * Return `host` in case if the current node is a shadow root otherwise will return the `parentNode`\n */\nexport function getParentNode(node) {\n    return isNodeShadowRoot(node) ? node.host : node.parentNode;\n}\n//# sourceMappingURL=htmlDomUtils.js.map","import { DefaultPrivacyLevel } from '@datadog/browser-core';\nimport { isElementNode, getParentNode, isTextNode } from '../browser/htmlDomUtils';\nexport const NodePrivacyLevel = {\n    IGNORE: 'ignore',\n    HIDDEN: 'hidden',\n    ALLOW: DefaultPrivacyLevel.ALLOW,\n    MASK: DefaultPrivacyLevel.MASK,\n    MASK_USER_INPUT: DefaultPrivacyLevel.MASK_USER_INPUT,\n};\nexport const PRIVACY_ATTR_NAME = 'data-dd-privacy';\n// Privacy Attrs\nexport const PRIVACY_ATTR_VALUE_ALLOW = 'allow';\nexport const PRIVACY_ATTR_VALUE_MASK = 'mask';\nexport const PRIVACY_ATTR_VALUE_MASK_USER_INPUT = 'mask-user-input';\nexport const PRIVACY_ATTR_VALUE_HIDDEN = 'hidden';\n// Privacy Classes - not all customers can set plain HTML attributes, so support classes too\nexport const PRIVACY_CLASS_PREFIX = 'dd-privacy-';\n// Private Replacement Templates\nexport const CENSORED_STRING_MARK = '***';\nexport const CENSORED_IMG_MARK = 'data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==';\nexport const FORM_PRIVATE_TAG_NAMES = {\n    INPUT: true,\n    OUTPUT: true,\n    TEXTAREA: true,\n    SELECT: true,\n    OPTION: true,\n    DATALIST: true,\n    OPTGROUP: true,\n};\nconst TEXT_MASKING_CHAR = 'x';\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(node, defaultPrivacyLevel, cache) {\n    if (cache && cache.has(node)) {\n        return cache.get(node);\n    }\n    const parentNode = getParentNode(node);\n    const parentNodePrivacyLevel = parentNode\n        ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel, cache)\n        : defaultPrivacyLevel;\n    const selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node);\n    const nodePrivacyLevel = reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel);\n    if (cache) {\n        cache.set(node, nodePrivacyLevel);\n    }\n    return nodePrivacyLevel;\n}\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(childPrivacyLevel, parentNodePrivacyLevel) {\n    switch (parentNodePrivacyLevel) {\n        // These values cannot be overridden\n        case NodePrivacyLevel.HIDDEN:\n        case NodePrivacyLevel.IGNORE:\n            return parentNodePrivacyLevel;\n    }\n    switch (childPrivacyLevel) {\n        case NodePrivacyLevel.ALLOW:\n        case NodePrivacyLevel.MASK:\n        case NodePrivacyLevel.MASK_USER_INPUT:\n        case NodePrivacyLevel.HIDDEN:\n        case NodePrivacyLevel.IGNORE:\n            return childPrivacyLevel;\n        default:\n            return parentNodePrivacyLevel;\n    }\n}\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node) {\n    // Only Element types can have a privacy level set\n    if (!isElementNode(node)) {\n        return;\n    }\n    // Overrules for replay purpose\n    if (node.tagName === 'BASE') {\n        return NodePrivacyLevel.ALLOW;\n    }\n    // Overrules to enforce end-user protection\n    if (node.tagName === 'INPUT') {\n        const inputElement = node;\n        if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n            return NodePrivacyLevel.MASK;\n        }\n        if (inputElement.type === 'hidden') {\n            return NodePrivacyLevel.MASK;\n        }\n        const autocomplete = inputElement.getAttribute('autocomplete');\n        // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year/new-password/current-password]\n        if (autocomplete && (autocomplete.startsWith('cc-') || autocomplete.endsWith('-password'))) {\n            return NodePrivacyLevel.MASK;\n        }\n    }\n    // Check HTML privacy attributes and classes\n    if (node.matches(getPrivacySelector(NodePrivacyLevel.HIDDEN))) {\n        return NodePrivacyLevel.HIDDEN;\n    }\n    if (node.matches(getPrivacySelector(NodePrivacyLevel.MASK))) {\n        return NodePrivacyLevel.MASK;\n    }\n    if (node.matches(getPrivacySelector(NodePrivacyLevel.MASK_USER_INPUT))) {\n        return NodePrivacyLevel.MASK_USER_INPUT;\n    }\n    if (node.matches(getPrivacySelector(NodePrivacyLevel.ALLOW))) {\n        return NodePrivacyLevel.ALLOW;\n    }\n    if (shouldIgnoreElement(node)) {\n        return NodePrivacyLevel.IGNORE;\n    }\n}\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node, privacyLevel) {\n    switch (privacyLevel) {\n        case NodePrivacyLevel.MASK:\n        case NodePrivacyLevel.HIDDEN:\n        case NodePrivacyLevel.IGNORE:\n            return true;\n        case NodePrivacyLevel.MASK_USER_INPUT:\n            return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node);\n        default:\n            return false;\n    }\n}\nfunction isFormElement(node) {\n    if (!node || node.nodeType !== node.ELEMENT_NODE) {\n        return false;\n    }\n    const element = node;\n    if (element.tagName === 'INPUT') {\n        switch (element.type) {\n            case 'button':\n            case 'color':\n            case 'reset':\n            case 'submit':\n                return false;\n        }\n    }\n    return !!FORM_PRIVATE_TAG_NAMES[element.tagName];\n}\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport const censorText = (text) => text.replace(/\\S/g, TEXT_MASKING_CHAR);\nexport function getTextContent(textNode, ignoreWhiteSpace, parentNodePrivacyLevel) {\n    var _a;\n    // The parent node may not be a html element which has a tagName attribute.\n    // So just let it be undefined which is ok in this use case.\n    const parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;\n    let textContent = textNode.textContent || '';\n    if (ignoreWhiteSpace && !textContent.trim()) {\n        return;\n    }\n    const nodePrivacyLevel = parentNodePrivacyLevel;\n    const isScript = parentTagName === 'SCRIPT';\n    if (isScript) {\n        // For perf reasons, we don't record script (heuristic)\n        textContent = CENSORED_STRING_MARK;\n    }\n    else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        // Should never occur, but just in case, we set to CENSORED_MARK.\n        textContent = CENSORED_STRING_MARK;\n    }\n    else if (shouldMaskNode(textNode, nodePrivacyLevel)) {\n        if (\n        // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n        parentTagName === 'DATALIST' ||\n            parentTagName === 'SELECT' ||\n            parentTagName === 'OPTGROUP') {\n            if (!textContent.trim()) {\n                return;\n            }\n        }\n        else if (parentTagName === 'OPTION') {\n            // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n            textContent = CENSORED_STRING_MARK;\n        }\n        else {\n            textContent = censorText(textContent);\n        }\n    }\n    return textContent;\n}\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element) {\n    if (element.nodeName === 'SCRIPT') {\n        return true;\n    }\n    if (element.nodeName === 'LINK') {\n        const relAttribute = getLowerCaseAttribute('rel');\n        return (\n        // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n        (/preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script') ||\n            // Favicons\n            relAttribute === 'shortcut icon' ||\n            relAttribute === 'icon');\n    }\n    if (element.nodeName === 'META') {\n        const nameAttribute = getLowerCaseAttribute('name');\n        const relAttribute = getLowerCaseAttribute('rel');\n        const propertyAttribute = getLowerCaseAttribute('property');\n        return (\n        // Favicons\n        /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n            nameAttribute === 'application-name' ||\n            relAttribute === 'icon' ||\n            relAttribute === 'apple-touch-icon' ||\n            relAttribute === 'shortcut icon' ||\n            // Description\n            nameAttribute === 'keywords' ||\n            nameAttribute === 'description' ||\n            // Social\n            /^(og|twitter|fb):/.test(propertyAttribute) ||\n            /^(og|twitter):/.test(nameAttribute) ||\n            nameAttribute === 'pinterest' ||\n            // Robots\n            nameAttribute === 'robots' ||\n            nameAttribute === 'googlebot' ||\n            nameAttribute === 'bingbot' ||\n            // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n            // X-Translated-By\n            element.hasAttribute('http-equiv') ||\n            // Authorship\n            nameAttribute === 'author' ||\n            nameAttribute === 'generator' ||\n            nameAttribute === 'framework' ||\n            nameAttribute === 'publisher' ||\n            nameAttribute === 'progid' ||\n            /^article:/.test(propertyAttribute) ||\n            /^product:/.test(propertyAttribute) ||\n            // Verification\n            nameAttribute === 'google-site-verification' ||\n            nameAttribute === 'yandex-verification' ||\n            nameAttribute === 'csrf-token' ||\n            nameAttribute === 'p:domain_verify' ||\n            nameAttribute === 'verify-v1' ||\n            nameAttribute === 'verification' ||\n            nameAttribute === 'shopify-checkout-api-token');\n    }\n    function getLowerCaseAttribute(name) {\n        return (element.getAttribute(name) || '').toLowerCase();\n    }\n    return false;\n}\nexport function getPrivacySelector(privacyLevel) {\n    return `[${PRIVACY_ATTR_NAME}=\"${privacyLevel}\"], .${PRIVACY_CLASS_PREFIX}${privacyLevel}`;\n}\n//# sourceMappingURL=privacy.js.map","import { safeTruncate } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getPrivacySelector } from '../privacy';\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport const DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name';\nexport const ACTION_NAME_PLACEHOLDER = 'Masked Element';\nexport function getActionNameFromElement(element, { enablePrivacyForActionName, actionNameAttribute: userProgrammaticAttribute }, nodePrivacyLevel) {\n    // Proceed to get the action name in two steps:\n    // * first, get the name programmatically, explicitly defined by the user.\n    // * then, if privacy is set to mask, return a placeholder for the undefined.\n    // * if privacy is not set to mask, use strategies that are known to return good results.\n    //   Those strategies will be used on the element and a few parents, but it's likely that they won't succeed at all.\n    // * if no name is found this way, use strategies returning less accurate names as a fallback.\n    //   Those are much likely to succeed.\n    const defaultActionName = getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) ||\n        (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute));\n    if (defaultActionName) {\n        return { name: defaultActionName, nameSource: \"custom_attribute\" /* ActionNameSource.CUSTOM_ATTRIBUTE */ };\n    }\n    else if (nodePrivacyLevel === NodePrivacyLevel.MASK) {\n        return { name: ACTION_NAME_PLACEHOLDER, nameSource: \"mask_placeholder\" /* ActionNameSource.MASK_PLACEHOLDER */ };\n    }\n    return (getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies, enablePrivacyForActionName) ||\n        getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies, enablePrivacyForActionName) || { name: '', nameSource: \"blank\" /* ActionNameSource.BLANK */ });\n}\nfunction getActionNameFromElementProgrammatically(targetElement, programmaticAttribute) {\n    // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n    // without limit. It is up to the user to declare a relevant naming strategy.\n    const elementWithAttribute = targetElement.closest(`[${programmaticAttribute}]`);\n    if (!elementWithAttribute) {\n        return;\n    }\n    const name = elementWithAttribute.getAttribute(programmaticAttribute);\n    return truncate(normalizeWhitespace(name.trim()));\n}\nconst priorityStrategies = [\n    // associated LABEL text\n    (element, userProgrammaticAttribute) => {\n        if ('labels' in element && element.labels && element.labels.length > 0) {\n            return getActionNameFromTextualContent(element.labels[0], userProgrammaticAttribute);\n        }\n    },\n    // INPUT button (and associated) value\n    (element) => {\n        if (element.nodeName === 'INPUT') {\n            const input = element;\n            const type = input.getAttribute('type');\n            if (type === 'button' || type === 'submit' || type === 'reset') {\n                return { name: input.value, nameSource: \"text_content\" /* ActionNameSource.TEXT_CONTENT */ };\n            }\n        }\n    },\n    // BUTTON, LABEL or button-like element text\n    (element, userProgrammaticAttribute, privacyEnabledActionName) => {\n        if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n            return getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName);\n        }\n    },\n    (element) => getActionNameFromStandardAttribute(element, 'aria-label'),\n    // associated element text designated by the aria-labelledby attribute\n    (element, userProgrammaticAttribute, privacyEnabledActionName) => {\n        const labelledByAttribute = element.getAttribute('aria-labelledby');\n        if (labelledByAttribute) {\n            return {\n                name: labelledByAttribute\n                    .split(/\\s+/)\n                    .map((id) => getElementById(element, id))\n                    .filter((label) => Boolean(label))\n                    .map((element) => getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName))\n                    .join(' '),\n                nameSource: \"text_content\" /* ActionNameSource.TEXT_CONTENT */,\n            };\n        }\n    },\n    (element) => getActionNameFromStandardAttribute(element, 'alt'),\n    (element) => getActionNameFromStandardAttribute(element, 'name'),\n    (element) => getActionNameFromStandardAttribute(element, 'title'),\n    (element) => getActionNameFromStandardAttribute(element, 'placeholder'),\n    // SELECT first OPTION text\n    (element, userProgrammaticAttribute) => {\n        if ('options' in element && element.options.length > 0) {\n            return getActionNameFromTextualContent(element.options[0], userProgrammaticAttribute);\n        }\n    },\n];\nconst fallbackStrategies = [\n    (element, userProgrammaticAttribute, privacyEnabledActionName) => getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName),\n];\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nconst MAX_PARENTS_TO_CONSIDER = 10;\nfunction getActionNameFromElementForStrategies(targetElement, userProgrammaticAttribute, strategies, privacyEnabledActionName) {\n    let element = targetElement;\n    let recursionCounter = 0;\n    while (recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n        element &&\n        element.nodeName !== 'BODY' &&\n        element.nodeName !== 'HTML' &&\n        element.nodeName !== 'HEAD') {\n        for (const strategy of strategies) {\n            const actionName = strategy(element, userProgrammaticAttribute, privacyEnabledActionName);\n            if (actionName) {\n                const { name, nameSource } = actionName;\n                const trimmedName = name && name.trim();\n                if (trimmedName) {\n                    return { name: truncate(normalizeWhitespace(trimmedName)), nameSource };\n                }\n            }\n        }\n        // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n        // be reconsidered in the future.\n        if (element.nodeName === 'FORM') {\n            break;\n        }\n        element = element.parentElement;\n        recursionCounter += 1;\n    }\n}\nfunction normalizeWhitespace(s) {\n    return s.replace(/\\s+/g, ' ');\n}\nfunction truncate(s) {\n    return s.length > 100 ? `${safeTruncate(s, 100)} [...]` : s;\n}\nfunction getElementById(refElement, id) {\n    // Use the element ownerDocument here, because tests are executed in an iframe, so\n    // document.getElementById won't work.\n    return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null;\n}\nfunction getActionNameFromStandardAttribute(element, attribute) {\n    return {\n        name: element.getAttribute(attribute) || '',\n        nameSource: \"standard_attribute\" /* ActionNameSource.STANDARD_ATTRIBUTE */,\n    };\n}\nfunction getActionNameFromTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) {\n    return {\n        name: getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) || '',\n        nameSource: \"text_content\" /* ActionNameSource.TEXT_CONTENT */,\n    };\n}\nfunction getTextualContent(element, userProgrammaticAttribute, privacyEnabledActionName) {\n    if (element.isContentEditable) {\n        return;\n    }\n    if ('innerText' in element) {\n        let text = element.innerText;\n        const removeTextFromElements = (query) => {\n            const list = element.querySelectorAll(query);\n            for (let index = 0; index < list.length; index += 1) {\n                const element = list[index];\n                if ('innerText' in element) {\n                    const textToReplace = element.innerText;\n                    if (textToReplace && textToReplace.trim().length > 0) {\n                        text = text.replace(textToReplace, '');\n                    }\n                }\n            }\n        };\n        // remove the text of elements with programmatic attribute value\n        removeTextFromElements(`[${DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE}]`);\n        if (userProgrammaticAttribute) {\n            removeTextFromElements(`[${userProgrammaticAttribute}]`);\n        }\n        if (privacyEnabledActionName) {\n            // remove the text of elements with privacy override\n            removeTextFromElements(`${getPrivacySelector(NodePrivacyLevel.HIDDEN)}, ${getPrivacySelector(NodePrivacyLevel.MASK)}`);\n        }\n        return text;\n    }\n    return element.textContent;\n}\n//# sourceMappingURL=getActionNameFromElement.js.map","import { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './action/getActionNameFromElement';\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport const STABLE_ATTRIBUTES = [\n    DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n    // Common test attributes (list provided by google recorder)\n    'data-testid',\n    'data-test',\n    'data-qa',\n    'data-cy',\n    'data-test-id',\n    'data-qa-id',\n    'data-testing',\n    // FullStory decorator attributes:\n    'data-component',\n    'data-element',\n    'data-source-file',\n];\n// Selectors to use if they target a single element on the whole document. Those selectors are\n// considered as \"stable\" and uniquely identify an element regardless of the page state. If we find\n// one, we should consider the selector \"complete\" and stop iterating over ancestors.\nconst GLOBALLY_UNIQUE_SELECTOR_GETTERS = [getStableAttributeSelector, getIDSelector];\n// Selectors to use if they target a single element among an element descendants. Those selectors\n// are more brittle than \"globally unique\" selectors and should be combined with ancestor selectors\n// to improve specificity.\nconst UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS = [\n    getStableAttributeSelector,\n    getClassSelector,\n    getTagNameSelector,\n];\nexport function getSelectorFromElement(targetElement, actionNameAttribute) {\n    if (!targetElement.isConnected) {\n        // We cannot compute a selector for a detached element, as we don't have access to all of its\n        // parents, and we cannot determine if it's unique in the document.\n        return;\n    }\n    let targetElementSelector;\n    let currentElement = targetElement;\n    while (currentElement && currentElement.nodeName !== 'HTML') {\n        const globallyUniqueSelector = findSelector(currentElement, GLOBALLY_UNIQUE_SELECTOR_GETTERS, isSelectorUniqueGlobally, actionNameAttribute, targetElementSelector);\n        if (globallyUniqueSelector) {\n            return globallyUniqueSelector;\n        }\n        const uniqueSelectorAmongChildren = findSelector(currentElement, UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS, isSelectorUniqueAmongSiblings, actionNameAttribute, targetElementSelector);\n        targetElementSelector =\n            uniqueSelectorAmongChildren || combineSelector(getPositionSelector(currentElement), targetElementSelector);\n        currentElement = currentElement.parentElement;\n    }\n    return targetElementSelector;\n}\nfunction isGeneratedValue(value) {\n    // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n    // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n    // present.\n    //\n    // Here, we use the same strategy: if the value contains a digit, we consider it generated. This\n    // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n    // CSS selectors so it should be fine most of the time.\n    return /[0-9]/.test(value);\n}\nfunction getIDSelector(element) {\n    if (element.id && !isGeneratedValue(element.id)) {\n        return `#${CSS.escape(element.id)}`;\n    }\n}\nfunction getClassSelector(element) {\n    if (element.tagName === 'BODY') {\n        return;\n    }\n    const classList = element.classList;\n    for (let i = 0; i < classList.length; i += 1) {\n        const className = classList[i];\n        if (isGeneratedValue(className)) {\n            continue;\n        }\n        return `${CSS.escape(element.tagName)}.${CSS.escape(className)}`;\n    }\n}\nfunction getTagNameSelector(element) {\n    return CSS.escape(element.tagName);\n}\nfunction getStableAttributeSelector(element, actionNameAttribute) {\n    if (actionNameAttribute) {\n        const selector = getAttributeSelector(actionNameAttribute);\n        if (selector) {\n            return selector;\n        }\n    }\n    for (const attributeName of STABLE_ATTRIBUTES) {\n        const selector = getAttributeSelector(attributeName);\n        if (selector) {\n            return selector;\n        }\n    }\n    function getAttributeSelector(attributeName) {\n        if (element.hasAttribute(attributeName)) {\n            return `${CSS.escape(element.tagName)}[${attributeName}=\"${CSS.escape(element.getAttribute(attributeName))}\"]`;\n        }\n    }\n}\nfunction getPositionSelector(element) {\n    let sibling = element.parentElement.firstElementChild;\n    let elementIndex = 1;\n    while (sibling && sibling !== element) {\n        if (sibling.tagName === element.tagName) {\n            elementIndex += 1;\n        }\n        sibling = sibling.nextElementSibling;\n    }\n    return `${CSS.escape(element.tagName)}:nth-of-type(${elementIndex})`;\n}\nfunction findSelector(element, selectorGetters, predicate, actionNameAttribute, childSelector) {\n    for (const selectorGetter of selectorGetters) {\n        const elementSelector = selectorGetter(element, actionNameAttribute);\n        if (!elementSelector) {\n            continue;\n        }\n        if (predicate(element, elementSelector, childSelector)) {\n            return combineSelector(elementSelector, childSelector);\n        }\n    }\n}\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(element, elementSelector, childSelector) {\n    return element.ownerDocument.querySelectorAll(combineSelector(elementSelector, childSelector)).length === 1;\n}\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > CHILD_SELECTOR\" returns a single element.\n *\n * @param {Element} currentElement - the element being considered while iterating over the target\n * element ancestors.\n *\n * @param {string} currentElementSelector - a selector that matches the current element. That\n * selector is not a composed selector (i.e. it might be a single tag name, class name...).\n *\n * @param {string|undefined} childSelector - child selector is a selector that targets a descendant\n * of the current element. When undefined, the current element is the target element.\n *\n * # Scope selector usage\n *\n * When composed together, the final selector will be joined with `>` operators to make sure we\n * target direct descendants at each level. In this function, we'll use `querySelector` to check if\n * a selector matches descendants of the current element. But by default, the query selector match\n * elements at any level. Example:\n *\n * ```html\n * <main>\n *   <div>\n *     <span></span>\n *   </div>\n *   <marquee>\n *     <div>\n *       <span></span>\n *     </div>\n *   </marquee>\n * </main>\n * ```\n *\n * `sibling.querySelector('DIV > SPAN')` will match both span elements, so we would consider the\n * selector to be not unique, even if it is unique when we'll compose it with the parent with a `>`\n * operator (`MAIN > DIV > SPAN`).\n *\n * To avoid this, we can use the `:scope` selector to make sure the selector starts from the current\n * sibling (i.e. `sibling.querySelector('DIV:scope > SPAN')` will only match the first span).\n *\n * [1]: https://developer.mozilla.org/fr/docs/Web/CSS/:scope\n *\n * # Performance considerations\n *\n * We compute selectors in performance-critical operations (ex: during a click), so we need to make\n * sure the function is as fast as possible. We observed that naively using `querySelectorAll` to\n * check if the selector matches more than 1 element is quite expensive, so we want to avoid it.\n *\n * Because we are iterating the DOM upward and we use that function at every level, we know the\n * child selector is already unique among the current element children, so we don't need to check\n * for the current element subtree.\n *\n * Instead, we can focus on the current element siblings. If we find a single element matching the\n * selector within a sibling, we know that it's not unique. This allows us to use `querySelector`\n * (or `matches`, when the current element is the target element) instead of `querySelectorAll`.\n */\nexport function isSelectorUniqueAmongSiblings(currentElement, currentElementSelector, childSelector) {\n    let isSiblingMatching;\n    if (childSelector === undefined) {\n        // If the child selector is undefined (meaning `currentElement` is the target element, not one\n        // of its ancestor), we need to use `matches` to check if the sibling is matching the selector,\n        // as `querySelector` only returns a descendant of the element.\n        isSiblingMatching = (sibling) => sibling.matches(currentElementSelector);\n    }\n    else {\n        const scopedSelector = combineSelector(`${currentElementSelector}:scope`, childSelector);\n        isSiblingMatching = (sibling) => sibling.querySelector(scopedSelector) !== null;\n    }\n    const parent = currentElement.parentElement;\n    let sibling = parent.firstElementChild;\n    while (sibling) {\n        if (sibling !== currentElement && isSiblingMatching(sibling)) {\n            return false;\n        }\n        sibling = sibling.nextElementSibling;\n    }\n    return true;\n}\nfunction combineSelector(parent, child) {\n    return child ? `${parent}>${child}` : parent;\n}\n//# sourceMappingURL=getSelectorFromElement.js.map","import { ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core';\nexport const MAX_DURATION_BETWEEN_CLICKS = ONE_SECOND;\nexport const MAX_DISTANCE_BETWEEN_CLICKS = 100;\nexport function createClickChain(firstClick, onFinalize) {\n    const bufferedClicks = [];\n    let status = 0 /* ClickChainStatus.WaitingForMoreClicks */;\n    let maxDurationBetweenClicksTimeoutId;\n    appendClick(firstClick);\n    function appendClick(click) {\n        click.stopObservable.subscribe(tryFinalize);\n        bufferedClicks.push(click);\n        clearTimeout(maxDurationBetweenClicksTimeoutId);\n        maxDurationBetweenClicksTimeoutId = setTimeout(dontAcceptMoreClick, MAX_DURATION_BETWEEN_CLICKS);\n    }\n    function tryFinalize() {\n        if (status === 1 /* ClickChainStatus.WaitingForClicksToStop */ && bufferedClicks.every((click) => click.isStopped())) {\n            status = 2 /* ClickChainStatus.Finalized */;\n            onFinalize(bufferedClicks);\n        }\n    }\n    function dontAcceptMoreClick() {\n        clearTimeout(maxDurationBetweenClicksTimeoutId);\n        if (status === 0 /* ClickChainStatus.WaitingForMoreClicks */) {\n            status = 1 /* ClickChainStatus.WaitingForClicksToStop */;\n            tryFinalize();\n        }\n    }\n    return {\n        tryAppend: (click) => {\n            if (status !== 0 /* ClickChainStatus.WaitingForMoreClicks */) {\n                return false;\n            }\n            if (bufferedClicks.length > 0 &&\n                !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)) {\n                dontAcceptMoreClick();\n                return false;\n            }\n            appendClick(click);\n            return true;\n        },\n        stop: () => {\n            dontAcceptMoreClick();\n        },\n    };\n}\n/**\n * Checks whether two events are similar by comparing their target, position and timestamp\n */\nfunction areEventsSimilar(first, second) {\n    return (first.target === second.target &&\n        mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS &&\n        first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS);\n}\nfunction mouseEventDistance(origin, other) {\n    return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2));\n}\n//# sourceMappingURL=clickChain.js.map","import { addEventListener } from '@datadog/browser-core';\nexport function listenActionEvents(configuration, { onPointerDown, onPointerUp }) {\n    let selectionEmptyAtPointerDown;\n    let userActivity = {\n        selection: false,\n        input: false,\n        scroll: false,\n    };\n    let clickContext;\n    const listeners = [\n        addEventListener(configuration, window, \"pointerdown\" /* DOM_EVENT.POINTER_DOWN */, (event) => {\n            if (isValidPointerEvent(event)) {\n                selectionEmptyAtPointerDown = isSelectionEmpty();\n                userActivity = {\n                    selection: false,\n                    input: false,\n                    scroll: false,\n                };\n                clickContext = onPointerDown(event);\n            }\n        }, { capture: true }),\n        addEventListener(configuration, window, \"selectionchange\" /* DOM_EVENT.SELECTION_CHANGE */, () => {\n            if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {\n                userActivity.selection = true;\n            }\n        }, { capture: true }),\n        addEventListener(configuration, window, \"scroll\" /* DOM_EVENT.SCROLL */, () => {\n            userActivity.scroll = true;\n        }, { capture: true, passive: true }),\n        addEventListener(configuration, window, \"pointerup\" /* DOM_EVENT.POINTER_UP */, (event) => {\n            if (isValidPointerEvent(event) && clickContext) {\n                // Use a scoped variable to make sure the value is not changed by other clicks\n                const localUserActivity = userActivity;\n                onPointerUp(clickContext, event, () => localUserActivity);\n                clickContext = undefined;\n            }\n        }, { capture: true }),\n        addEventListener(configuration, window, \"input\" /* DOM_EVENT.INPUT */, () => {\n            userActivity.input = true;\n        }, { capture: true }),\n    ];\n    return {\n        stop: () => {\n            listeners.forEach((listener) => listener.stop());\n        },\n    };\n}\nfunction isSelectionEmpty() {\n    const selection = window.getSelection();\n    return !selection || selection.isCollapsed;\n}\nfunction isValidPointerEvent(event) {\n    return (event.target instanceof Element &&\n        // Only consider 'primary' pointer events for now. Multi-touch support could be implemented in\n        // the future.\n        event.isPrimary !== false);\n}\n//# sourceMappingURL=listenActionEvents.js.map","import { ONE_SECOND } from '@datadog/browser-core';\nconst MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3;\nexport function computeFrustration(clicks, rageClick) {\n    if (isRage(clicks)) {\n        rageClick.addFrustration(\"rage_click\" /* FrustrationType.RAGE_CLICK */);\n        if (clicks.some(isDead)) {\n            rageClick.addFrustration(\"dead_click\" /* FrustrationType.DEAD_CLICK */);\n        }\n        if (rageClick.hasError) {\n            rageClick.addFrustration(\"error_click\" /* FrustrationType.ERROR_CLICK */);\n        }\n        return { isRage: true };\n    }\n    const hasSelectionChanged = clicks.some((click) => click.getUserActivity().selection);\n    clicks.forEach((click) => {\n        if (click.hasError) {\n            click.addFrustration(\"error_click\" /* FrustrationType.ERROR_CLICK */);\n        }\n        if (isDead(click) &&\n            // Avoid considering clicks part of a double-click or triple-click selections as dead clicks\n            !hasSelectionChanged) {\n            click.addFrustration(\"dead_click\" /* FrustrationType.DEAD_CLICK */);\n        }\n    });\n    return { isRage: false };\n}\nexport function isRage(clicks) {\n    if (clicks.some((click) => click.getUserActivity().selection || click.getUserActivity().scroll)) {\n        return false;\n    }\n    for (let i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {\n        if (clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <=\n            ONE_SECOND) {\n            return true;\n        }\n    }\n    return false;\n}\nconst DEAD_CLICK_EXCLUDE_SELECTOR = \n// inputs that don't trigger a meaningful event like \"input\" when clicked, including textual\n// inputs (using a negative selector is shorter here)\n'input:not([type=\"checkbox\"]):not([type=\"radio\"]):not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]):not([type=\"range\"]),' +\n    'textarea,' +\n    'select,' +\n    // contenteditable and their descendants don't always trigger meaningful changes when manipulated\n    '[contenteditable],' +\n    '[contenteditable] *,' +\n    // canvas, as there is no good way to detect activity occurring on them\n    'canvas,' +\n    // links that are interactive (have an href attribute) or any of their descendants, as they can\n    // open a new tab or navigate to a hash without triggering a meaningful event\n    'a[href],' +\n    'a[href] *';\nexport function isDead(click) {\n    if (click.hasPageActivity || click.getUserActivity().input || click.getUserActivity().scroll) {\n        return false;\n    }\n    return !click.event.target.matches(DEAD_CLICK_EXCLUDE_SELECTOR);\n}\n//# sourceMappingURL=computeFrustration.js.map","import { elapsed, ONE_SECOND, relativeNow } from '@datadog/browser-core';\n// Maximum duration for click actions\nexport const CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND;\nexport const interactionSelectorCache = new Map();\nexport function getInteractionSelector(relativeTimestamp) {\n    const selector = interactionSelectorCache.get(relativeTimestamp);\n    interactionSelectorCache.delete(relativeTimestamp);\n    return selector;\n}\nexport function updateInteractionSelector(relativeTimestamp, selector) {\n    interactionSelectorCache.set(relativeTimestamp, selector);\n    interactionSelectorCache.forEach((_, relativeTimestamp) => {\n        if (elapsed(relativeTimestamp, relativeNow()) > CLICK_ACTION_MAX_DURATION) {\n            interactionSelectorCache.delete(relativeTimestamp);\n        }\n    });\n}\n//# sourceMappingURL=interactionSelectorCache.js.map","import { timeStampNow, Observable, getRelativeTime, ONE_MINUTE, generateUUID, clocksNow, elapsed, createValueHistory, } from '@datadog/browser-core';\nimport { trackEventCounts } from '../trackEventCounts';\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../waitPageActivityEnd';\nimport { getSelectorFromElement } from '../getSelectorFromElement';\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '../privacy';\nimport { createClickChain } from './clickChain';\nimport { getActionNameFromElement } from './getActionNameFromElement';\nimport { listenActionEvents } from './listenActionEvents';\nimport { computeFrustration } from './computeFrustration';\nimport { CLICK_ACTION_MAX_DURATION, updateInteractionSelector } from './interactionSelectorCache';\nexport const ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE; // arbitrary\nexport function trackClickActions(lifeCycle, domMutationObservable, windowOpenObservable, configuration) {\n    const history = createValueHistory({ expireDelay: ACTION_CONTEXT_TIME_OUT_DELAY });\n    const stopObservable = new Observable();\n    let currentClickChain;\n    lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, () => {\n        history.reset();\n    });\n    lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, stopClickChain);\n    const { stop: stopActionEventsListener } = listenActionEvents(configuration, {\n        onPointerDown: (pointerDownEvent) => processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent, windowOpenObservable),\n        onPointerUp: ({ clickActionBase, hadActivityOnPointerDown }, startEvent, getUserActivity) => {\n            startClickAction(configuration, lifeCycle, domMutationObservable, windowOpenObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown);\n        },\n    });\n    const actionContexts = {\n        findActionId: (startTime) => history.findAll(startTime),\n    };\n    return {\n        stop: () => {\n            stopClickChain();\n            stopObservable.notify();\n            stopActionEventsListener();\n        },\n        actionContexts,\n    };\n    function appendClickToClickChain(click) {\n        if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n            const rageClick = click.clone();\n            currentClickChain = createClickChain(click, (clicks) => {\n                finalizeClicks(clicks, rageClick);\n            });\n        }\n    }\n    function stopClickChain() {\n        if (currentClickChain) {\n            currentClickChain.stop();\n        }\n    }\n}\nfunction processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent, windowOpenObservable) {\n    const nodePrivacyLevel = configuration.enablePrivacyForActionName\n        ? getNodePrivacyLevel(pointerDownEvent.target, configuration.defaultPrivacyLevel)\n        : NodePrivacyLevel.ALLOW;\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        return undefined;\n    }\n    const clickActionBase = computeClickActionBase(pointerDownEvent, nodePrivacyLevel, configuration);\n    let hadActivityOnPointerDown = false;\n    waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, (pageActivityEndEvent) => {\n        hadActivityOnPointerDown = pageActivityEndEvent.hadActivity;\n    }, \n    // We don't care about the activity duration, we just want to know whether an activity did happen\n    // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n    PAGE_ACTIVITY_VALIDATION_DELAY);\n    return { clickActionBase, hadActivityOnPointerDown: () => hadActivityOnPointerDown };\n}\nfunction startClickAction(configuration, lifeCycle, domMutationObservable, windowOpenObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown) {\n    var _a;\n    const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);\n    appendClickToClickChain(click);\n    const selector = (_a = clickActionBase === null || clickActionBase === void 0 ? void 0 : clickActionBase.target) === null || _a === void 0 ? void 0 : _a.selector;\n    if (selector) {\n        updateInteractionSelector(startEvent.timeStamp, selector);\n    }\n    const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, (pageActivityEndEvent) => {\n        if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n            // If the clock is looking weird, just discard the click\n            click.discard();\n        }\n        else {\n            if (pageActivityEndEvent.hadActivity) {\n                click.stop(pageActivityEndEvent.end);\n            }\n            else if (hadActivityOnPointerDown()) {\n                click.stop(\n                // using the click start as activity end, so the click will have some activity but its\n                // duration will be 0 (as the activity started before the click start)\n                click.startClocks.timeStamp);\n            }\n            else {\n                click.stop();\n            }\n        }\n    }, CLICK_ACTION_MAX_DURATION);\n    const viewEndedSubscription = lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, ({ endClocks }) => {\n        click.stop(endClocks.timeStamp);\n    });\n    const stopSubscription = stopObservable.subscribe(() => {\n        click.stop();\n    });\n    click.stopObservable.subscribe(() => {\n        viewEndedSubscription.unsubscribe();\n        stopWaitPageActivityEnd();\n        stopSubscription.unsubscribe();\n    });\n}\nfunction computeClickActionBase(event, nodePrivacyLevel, configuration) {\n    const rect = event.target.getBoundingClientRect();\n    const selector = getSelectorFromElement(event.target, configuration.actionNameAttribute);\n    if (selector) {\n        updateInteractionSelector(event.timeStamp, selector);\n    }\n    const actionName = getActionNameFromElement(event.target, configuration, nodePrivacyLevel);\n    return {\n        type: \"click\" /* ActionType.CLICK */,\n        target: {\n            width: Math.round(rect.width),\n            height: Math.round(rect.height),\n            selector,\n        },\n        position: {\n            // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n            x: Math.round(event.clientX - rect.left),\n            y: Math.round(event.clientY - rect.top),\n        },\n        name: actionName.name,\n        nameSource: actionName.nameSource,\n    };\n}\nfunction newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent) {\n    const id = generateUUID();\n    const startClocks = clocksNow();\n    const historyEntry = history.add(id, startClocks.relative);\n    const eventCountsSubscription = trackEventCounts({\n        lifeCycle,\n        isChildEvent: (event) => event.action !== undefined &&\n            (Array.isArray(event.action.id) ? event.action.id.includes(id) : event.action.id === id),\n    });\n    let status = 0 /* ClickStatus.ONGOING */;\n    let activityEndTime;\n    const frustrationTypes = [];\n    const stopObservable = new Observable();\n    function stop(newActivityEndTime) {\n        if (status !== 0 /* ClickStatus.ONGOING */) {\n            return;\n        }\n        activityEndTime = newActivityEndTime;\n        status = 1 /* ClickStatus.STOPPED */;\n        if (activityEndTime) {\n            historyEntry.close(getRelativeTime(activityEndTime));\n        }\n        else {\n            historyEntry.remove();\n        }\n        eventCountsSubscription.stop();\n        stopObservable.notify();\n    }\n    return {\n        event: startEvent,\n        stop,\n        stopObservable,\n        get hasError() {\n            return eventCountsSubscription.eventCounts.errorCount > 0;\n        },\n        get hasPageActivity() {\n            return activityEndTime !== undefined;\n        },\n        getUserActivity,\n        addFrustration: (frustrationType) => {\n            frustrationTypes.push(frustrationType);\n        },\n        startClocks,\n        isStopped: () => status === 1 /* ClickStatus.STOPPED */ || status === 2 /* ClickStatus.FINALIZED */,\n        clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent),\n        validate: (domEvents) => {\n            stop();\n            if (status !== 1 /* ClickStatus.STOPPED */) {\n                return;\n            }\n            const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts;\n            const clickAction = {\n                duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n                startClocks,\n                id,\n                frustrationTypes,\n                counts: {\n                    resourceCount,\n                    errorCount,\n                    longTaskCount,\n                },\n                events: domEvents !== null && domEvents !== void 0 ? domEvents : [startEvent],\n                event: startEvent,\n                ...clickActionBase,\n            };\n            lifeCycle.notify(0 /* LifeCycleEventType.AUTO_ACTION_COMPLETED */, clickAction);\n            status = 2 /* ClickStatus.FINALIZED */;\n        },\n        discard: () => {\n            stop();\n            status = 2 /* ClickStatus.FINALIZED */;\n        },\n    };\n}\nexport function finalizeClicks(clicks, rageClick) {\n    const { isRage } = computeFrustration(clicks, rageClick);\n    if (isRage) {\n        clicks.forEach((click) => click.discard());\n        rageClick.stop(timeStampNow());\n        rageClick.validate(clicks.map((click) => click.event));\n    }\n    else {\n        rageClick.discard();\n        clicks.forEach((click) => click.validate());\n    }\n}\n//# sourceMappingURL=trackClickActions.js.map","import { noop, combine, toServerDuration, generateUUID } from '@datadog/browser-core';\nimport { discardNegativeDuration } from '../discardNegativeDuration';\nimport { trackClickActions } from './trackClickActions';\nexport function startActionCollection(lifeCycle, hooks, domMutationObservable, windowOpenObservable, configuration, pageStateHistory) {\n    lifeCycle.subscribe(0 /* LifeCycleEventType.AUTO_ACTION_COMPLETED */, (action) => lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processAction(action, pageStateHistory)));\n    hooks.register(0 /* HookNames.Assemble */, ({ startTime, eventType }) => {\n        if (eventType !== \"error\" /* RumEventType.ERROR */ &&\n            eventType !== \"resource\" /* RumEventType.RESOURCE */ &&\n            eventType !== \"long_task\" /* RumEventType.LONG_TASK */) {\n            return;\n        }\n        const actionId = actionContexts.findActionId(startTime);\n        if (!actionId) {\n            return;\n        }\n        return {\n            type: eventType,\n            action: { id: actionId },\n        };\n    });\n    let actionContexts = { findActionId: noop };\n    let stop = noop;\n    if (configuration.trackUserInteractions) {\n        ;\n        ({ actionContexts, stop } = trackClickActions(lifeCycle, domMutationObservable, windowOpenObservable, configuration));\n    }\n    return {\n        addAction: (action, savedCommonContext) => {\n            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, {\n                savedCommonContext,\n                ...processAction(action, pageStateHistory),\n            });\n        },\n        actionContexts,\n        stop,\n    };\n}\nfunction processAction(action, pageStateHistory) {\n    const autoActionProperties = isAutoAction(action)\n        ? {\n            action: {\n                id: action.id,\n                loading_time: discardNegativeDuration(toServerDuration(action.duration)),\n                frustration: {\n                    type: action.frustrationTypes,\n                },\n                error: {\n                    count: action.counts.errorCount,\n                },\n                long_task: {\n                    count: action.counts.longTaskCount,\n                },\n                resource: {\n                    count: action.counts.resourceCount,\n                },\n            },\n            _dd: {\n                action: {\n                    target: action.target,\n                    position: action.position,\n                    name_source: action.nameSource,\n                },\n            },\n        }\n        : undefined;\n    const customerContext = !isAutoAction(action) ? action.context : undefined;\n    const actionEvent = combine({\n        action: {\n            id: generateUUID(),\n            target: {\n                name: action.name,\n            },\n            type: action.type,\n        },\n        date: action.startClocks.timeStamp,\n        type: \"action\" /* RumEventType.ACTION */,\n        view: { in_foreground: pageStateHistory.wasInPageStateAt(\"active\" /* PageState.ACTIVE */, action.startClocks.relative) },\n    }, autoActionProperties);\n    const domainContext = isAutoAction(action) ? { events: action.events } : {};\n    if (!isAutoAction(action) && action.handlingStack) {\n        domainContext.handlingStack = action.handlingStack;\n    }\n    return {\n        customerContext,\n        rawRumEvent: actionEvent,\n        startTime: action.startClocks.relative,\n        domainContext,\n    };\n}\nfunction isAutoAction(action) {\n    return action.type !== \"custom\" /* ActionType.CUSTOM */;\n}\n//# sourceMappingURL=actionCollection.js.map","import { ErrorSource, generateUUID, computeRawError, computeStackTrace, Observable, trackRuntimeError, isError, combine, } from '@datadog/browser-core';\nimport { trackConsoleError } from './trackConsoleError';\nimport { trackReportError } from './trackReportError';\nexport function startErrorCollection(lifeCycle, configuration, pageStateHistory) {\n    const errorObservable = new Observable();\n    trackConsoleError(errorObservable);\n    trackRuntimeError(errorObservable);\n    trackReportError(configuration, errorObservable);\n    errorObservable.subscribe((error) => lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error }));\n    return doStartErrorCollection(lifeCycle, pageStateHistory);\n}\nexport function doStartErrorCollection(lifeCycle, pageStateHistory) {\n    lifeCycle.subscribe(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, ({ error, customerContext, savedCommonContext }) => {\n        customerContext = combine(error.context, customerContext);\n        lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, {\n            customerContext,\n            savedCommonContext,\n            ...processError(error, pageStateHistory),\n        });\n    });\n    return {\n        addError: ({ error, handlingStack, componentStack, startClocks, context: customerContext }, savedCommonContext) => {\n            const stackTrace = isError(error) ? computeStackTrace(error) : undefined;\n            const rawError = computeRawError({\n                stackTrace,\n                originalError: error,\n                handlingStack,\n                componentStack,\n                startClocks,\n                nonErrorPrefix: \"Provided\" /* NonErrorPrefix.PROVIDED */,\n                source: ErrorSource.CUSTOM,\n                handling: \"handled\" /* ErrorHandling.HANDLED */,\n            });\n            lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, {\n                customerContext,\n                savedCommonContext,\n                error: rawError,\n            });\n        },\n    };\n}\nfunction processError(error, pageStateHistory) {\n    const rawRumEvent = {\n        date: error.startClocks.timeStamp,\n        error: {\n            id: generateUUID(),\n            message: error.message,\n            source: error.source,\n            stack: error.stack,\n            handling_stack: error.handlingStack,\n            component_stack: error.componentStack,\n            type: error.type,\n            handling: error.handling,\n            causes: error.causes,\n            source_type: 'browser',\n            fingerprint: error.fingerprint,\n            csp: error.csp,\n        },\n        type: \"error\" /* RumEventType.ERROR */,\n        view: { in_foreground: pageStateHistory.wasInPageStateAt(\"active\" /* PageState.ACTIVE */, error.startClocks.relative) },\n    };\n    const domainContext = {\n        error: error.originalError,\n        handlingStack: error.handlingStack,\n    };\n    return {\n        rawRumEvent,\n        startTime: error.startClocks.relative,\n        domainContext,\n    };\n}\n//# sourceMappingURL=errorCollection.js.map","import { initConsoleObservable, ConsoleApiName } from '@datadog/browser-core';\nexport function trackConsoleError(errorObservable) {\n    const subscription = initConsoleObservable([ConsoleApiName.error]).subscribe((consoleLog) => errorObservable.notify(consoleLog.error));\n    return {\n        stop: () => {\n            subscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackConsoleError.js.map","import { initReportObservable, RawReportType } from '@datadog/browser-core';\nexport function trackReportError(configuration, errorObservable) {\n    const subscription = initReportObservable(configuration, [\n        RawReportType.cspViolation,\n        RawReportType.intervention,\n    ]).subscribe((rawError) => errorObservable.notify(rawError));\n    return {\n        stop: () => {\n            subscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackReportError.js.map","import { addDuration } from '@datadog/browser-core';\nimport { hasValidResourceEntryDuration, hasValidResourceEntryTimings } from './resourceUtils';\nconst alreadyMatchedEntries = new WeakSet();\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - filter out timing that were already matched to a request\n * - then, if a single timing match, return the timing\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestResourceEntry(request) {\n    if (!performance || !('getEntriesByName' in performance)) {\n        return;\n    }\n    const sameNameEntries = performance.getEntriesByName(request.url, 'resource');\n    if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n        return;\n    }\n    const candidates = sameNameEntries\n        .filter((entry) => !alreadyMatchedEntries.has(entry))\n        .filter((entry) => hasValidResourceEntryDuration(entry) && hasValidResourceEntryTimings(entry))\n        .filter((entry) => isBetween(entry, request.startClocks.relative, endTime({ startTime: request.startClocks.relative, duration: request.duration })));\n    if (candidates.length === 1) {\n        alreadyMatchedEntries.add(candidates[0]);\n        return candidates[0].toJSON();\n    }\n    return;\n}\nfunction endTime(timing) {\n    return addDuration(timing.startTime, timing.duration);\n}\nfunction isBetween(timing, start, end) {\n    const errorMargin = 1;\n    return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin);\n}\n//# sourceMappingURL=matchRequestResourceEntry.js.map","import { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core';\nimport { isCommentNode, isTextNode } from '../../browser/htmlDomUtils';\nexport const INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE;\nexport function getDocumentTraceId(document) {\n    const data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document);\n    if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n        return undefined;\n    }\n    return data.traceId;\n}\nexport function getDocumentTraceDataFromMeta(document) {\n    const traceIdMeta = document.querySelector('meta[name=dd-trace-id]');\n    const traceTimeMeta = document.querySelector('meta[name=dd-trace-time]');\n    return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content);\n}\nexport function getDocumentTraceDataFromComment(document) {\n    const comment = findTraceComment(document);\n    if (!comment) {\n        return undefined;\n    }\n    return createDocumentTraceData(findCommaSeparatedValue(comment, 'trace-id'), findCommaSeparatedValue(comment, 'trace-time'));\n}\nexport function createDocumentTraceData(traceId, rawTraceTime) {\n    const traceTime = rawTraceTime && Number(rawTraceTime);\n    if (!traceId || !traceTime) {\n        return undefined;\n    }\n    return {\n        traceId,\n        traceTime,\n    };\n}\nexport function findTraceComment(document) {\n    // 1. Try to find the comment as a direct child of the document\n    // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n    // value is not an array or string (here, a NodeList).\n    for (let i = 0; i < document.childNodes.length; i += 1) {\n        const comment = getTraceCommentFromNode(document.childNodes[i]);\n        if (comment) {\n            return comment;\n        }\n    }\n    // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n    // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n    // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n    // reverse order, stopping if we come across a non-text node.\n    if (document.body) {\n        for (let i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n            const node = document.body.childNodes[i];\n            const comment = getTraceCommentFromNode(node);\n            if (comment) {\n                return comment;\n            }\n            if (!isTextNode(node)) {\n                break;\n            }\n        }\n    }\n}\nfunction getTraceCommentFromNode(node) {\n    if (node && isCommentNode(node)) {\n        const match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data);\n        if (match) {\n            return match[1];\n        }\n    }\n}\n//# sourceMappingURL=getDocumentTraceId.js.map","import { getRelativeTime, isNumber } from '@datadog/browser-core';\nimport { RumPerformanceEntryType, supportPerformanceTimingEvent, } from './performanceObservable';\nexport function getNavigationEntry() {\n    if (supportPerformanceTimingEvent(RumPerformanceEntryType.NAVIGATION)) {\n        const navigationEntry = performance.getEntriesByType(RumPerformanceEntryType.NAVIGATION)[0];\n        if (navigationEntry) {\n            return navigationEntry;\n        }\n    }\n    const timings = computeTimingsFromDeprecatedPerformanceTiming();\n    const entry = {\n        entryType: RumPerformanceEntryType.NAVIGATION,\n        initiatorType: 'navigation',\n        name: window.location.href,\n        startTime: 0,\n        duration: timings.loadEventEnd,\n        decodedBodySize: 0,\n        encodedBodySize: 0,\n        transferSize: 0,\n        workerStart: 0,\n        toJSON: () => ({ ...entry, toJSON: undefined }),\n        ...timings,\n    };\n    return entry;\n}\nexport function computeTimingsFromDeprecatedPerformanceTiming() {\n    const result = {};\n    const timing = performance.timing;\n    for (const key in timing) {\n        if (isNumber(timing[key])) {\n            const numberKey = key;\n            const timingElement = timing[numberKey];\n            result[numberKey] = timingElement === 0 ? 0 : getRelativeTime(timingElement);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=performanceUtils.js.map","import { runOnReadyState } from '@datadog/browser-core';\nimport { RumPerformanceEntryType } from '../../browser/performanceObservable';\nimport { getDocumentTraceId } from '../tracing/getDocumentTraceId';\nimport { getNavigationEntry } from '../../browser/performanceUtils';\nimport { FAKE_INITIAL_DOCUMENT } from './resourceUtils';\nexport function retrieveInitialDocumentResourceTiming(configuration, callback, getNavigationEntryImpl = getNavigationEntry) {\n    runOnReadyState(configuration, 'interactive', () => {\n        const navigationEntry = getNavigationEntryImpl();\n        const entry = Object.assign(navigationEntry.toJSON(), {\n            entryType: RumPerformanceEntryType.RESOURCE,\n            initiatorType: FAKE_INITIAL_DOCUMENT,\n            // The ResourceTiming duration entry should be `responseEnd - startTime`. With\n            // NavigationTiming entries, `startTime` is always 0, so set it to `responseEnd`.\n            duration: navigationEntry.responseEnd,\n            traceId: getDocumentTraceId(document),\n            toJSON: () => ({ ...entry, toJSON: undefined }),\n        });\n        callback(entry);\n    });\n}\n//# sourceMappingURL=retrieveInitialDocumentResourceTiming.js.map","import { combine, generateUUID, toServerDuration, relativeToClocks, createTaskQueue, } from '@datadog/browser-core';\nimport { RumPerformanceEntryType, createPerformanceObservable, } from '../../browser/performanceObservable';\nimport { createSpanIdentifier } from '../tracing/identifier';\nimport { matchRequestResourceEntry } from './matchRequestResourceEntry';\nimport { computeResourceEntryDetails, computeResourceEntryDuration, computeResourceEntryType, computeResourceEntrySize, computeResourceEntryProtocol, computeResourceEntryDeliveryType, isResourceEntryRequestType, isLongDataUrl, sanitizeDataUrl, } from './resourceUtils';\nimport { retrieveInitialDocumentResourceTiming } from './retrieveInitialDocumentResourceTiming';\nexport function startResourceCollection(lifeCycle, configuration, pageStateHistory, taskQueue = createTaskQueue(), retrieveInitialDocumentResourceTimingImpl = retrieveInitialDocumentResourceTiming) {\n    lifeCycle.subscribe(8 /* LifeCycleEventType.REQUEST_COMPLETED */, (request) => {\n        handleResource(() => processRequest(request, configuration, pageStateHistory));\n    });\n    const performanceResourceSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.RESOURCE,\n        buffered: true,\n    }).subscribe((entries) => {\n        for (const entry of entries) {\n            if (!isResourceEntryRequestType(entry)) {\n                handleResource(() => processResourceEntry(entry, configuration));\n            }\n        }\n    });\n    retrieveInitialDocumentResourceTimingImpl(configuration, (timing) => {\n        handleResource(() => processResourceEntry(timing, configuration));\n    });\n    function handleResource(computeRawEvent) {\n        taskQueue.push(() => {\n            const rawEvent = computeRawEvent();\n            if (rawEvent) {\n                lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, rawEvent);\n            }\n        });\n    }\n    return {\n        stop: () => {\n            performanceResourceSubscription.unsubscribe();\n        },\n    };\n}\nfunction processRequest(request, configuration, pageStateHistory) {\n    const matchingTiming = matchRequestResourceEntry(request);\n    const startClocks = matchingTiming ? relativeToClocks(matchingTiming.startTime) : request.startClocks;\n    const tracingInfo = computeRequestTracingInfo(request, configuration);\n    if (!configuration.trackResources && !tracingInfo) {\n        return;\n    }\n    const type = request.type === \"xhr\" /* RequestType.XHR */ ? \"xhr\" /* ResourceType.XHR */ : \"fetch\" /* ResourceType.FETCH */;\n    const correspondingTimingOverrides = matchingTiming ? computeResourceEntryMetrics(matchingTiming) : undefined;\n    const duration = computeRequestDuration(pageStateHistory, startClocks, request.duration);\n    const resourceEvent = combine({\n        date: startClocks.timeStamp,\n        resource: {\n            id: generateUUID(),\n            type,\n            duration,\n            method: request.method,\n            status_code: request.status,\n            protocol: matchingTiming && computeResourceEntryProtocol(matchingTiming),\n            url: isLongDataUrl(request.url) ? sanitizeDataUrl(request.url) : request.url,\n            delivery_type: matchingTiming && computeResourceEntryDeliveryType(matchingTiming),\n        },\n        type: \"resource\" /* RumEventType.RESOURCE */,\n        _dd: {\n            discarded: !configuration.trackResources,\n        },\n    }, tracingInfo, correspondingTimingOverrides);\n    return {\n        startTime: startClocks.relative,\n        rawRumEvent: resourceEvent,\n        domainContext: {\n            performanceEntry: matchingTiming,\n            xhr: request.xhr,\n            response: request.response,\n            requestInput: request.input,\n            requestInit: request.init,\n            error: request.error,\n            isAborted: request.isAborted,\n            handlingStack: request.handlingStack,\n        },\n    };\n}\nfunction processResourceEntry(entry, configuration) {\n    const startClocks = relativeToClocks(entry.startTime);\n    const tracingInfo = computeResourceEntryTracingInfo(entry, configuration);\n    if (!configuration.trackResources && !tracingInfo) {\n        return;\n    }\n    const type = computeResourceEntryType(entry);\n    const entryMetrics = computeResourceEntryMetrics(entry);\n    const resourceEvent = combine({\n        date: startClocks.timeStamp,\n        resource: {\n            id: generateUUID(),\n            type,\n            url: entry.name,\n            status_code: discardZeroStatus(entry.responseStatus),\n            protocol: computeResourceEntryProtocol(entry),\n            delivery_type: computeResourceEntryDeliveryType(entry),\n        },\n        type: \"resource\" /* RumEventType.RESOURCE */,\n        _dd: {\n            discarded: !configuration.trackResources,\n        },\n    }, tracingInfo, entryMetrics);\n    return {\n        startTime: startClocks.relative,\n        rawRumEvent: resourceEvent,\n        domainContext: {\n            performanceEntry: entry,\n        },\n    };\n}\nfunction computeResourceEntryMetrics(entry) {\n    const { renderBlockingStatus } = entry;\n    return {\n        resource: {\n            duration: computeResourceEntryDuration(entry),\n            render_blocking_status: renderBlockingStatus,\n            ...computeResourceEntrySize(entry),\n            ...computeResourceEntryDetails(entry),\n        },\n    };\n}\nfunction computeRequestTracingInfo(request, configuration) {\n    const hasBeenTraced = request.traceSampled && request.traceId && request.spanId;\n    if (!hasBeenTraced) {\n        return undefined;\n    }\n    return {\n        _dd: {\n            span_id: request.spanId.toString(),\n            trace_id: request.traceId.toString(),\n            rule_psr: configuration.rulePsr,\n        },\n    };\n}\nfunction computeResourceEntryTracingInfo(entry, configuration) {\n    const hasBeenTraced = entry.traceId;\n    if (!hasBeenTraced) {\n        return undefined;\n    }\n    return {\n        _dd: {\n            trace_id: entry.traceId,\n            span_id: createSpanIdentifier().toString(),\n            rule_psr: configuration.rulePsr,\n        },\n    };\n}\nfunction computeRequestDuration(pageStateHistory, startClocks, duration) {\n    return !pageStateHistory.wasInPageStateDuringPeriod(\"frozen\" /* PageState.FROZEN */, startClocks.relative, duration)\n        ? toServerDuration(duration)\n        : undefined;\n}\n/**\n * The status is 0 for cross-origin resources without CORS headers, so the status is meaningless, and we shouldn't report it\n * https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/responseStatus#cross-origin_response_status_codes\n */\nfunction discardZeroStatus(statusCode) {\n    return statusCode === 0 ? undefined : statusCode;\n}\n//# sourceMappingURL=resourceCollection.js.map","import { ONE_SECOND } from './utils/timeUtils';\nimport { requestIdleCallback } from './requestIdleCallback';\n/**\n * Maximum delay before starting to execute tasks in the queue. We don't want to wait too long\n * before running tasks, as it might hurt reliability (ex: if the user navigates away, we might lose\n * the opportunity to send some data). We also don't want to run tasks too often, as it might hurt\n * performance.\n */\nconst IDLE_CALLBACK_TIMEOUT = ONE_SECOND;\n/**\n * Maximum amount of time allocated to running tasks when a timeout (`IDLE_CALLBACK_TIMEOUT`) is\n * reached. We should not run tasks for too long as it will hurt performance, but we should still\n * run some tasks to avoid postponing them forever.\n *\n * Rational: Running tasks for 30ms every second (IDLE_CALLBACK_TIMEOUT) should be acceptable.\n */\nexport const MAX_EXECUTION_TIME_ON_TIMEOUT = 30;\nexport function createTaskQueue() {\n    const pendingTasks = [];\n    function run(deadline) {\n        let executionTimeRemaining;\n        if (deadline.didTimeout) {\n            const start = performance.now();\n            executionTimeRemaining = () => MAX_EXECUTION_TIME_ON_TIMEOUT - (performance.now() - start);\n        }\n        else {\n            executionTimeRemaining = deadline.timeRemaining.bind(deadline);\n        }\n        while (executionTimeRemaining() > 0 && pendingTasks.length) {\n            pendingTasks.shift()();\n        }\n        if (pendingTasks.length) {\n            scheduleNextRun();\n        }\n    }\n    function scheduleNextRun() {\n        requestIdleCallback(run, { timeout: IDLE_CALLBACK_TIMEOUT });\n    }\n    return {\n        push(task) {\n            if (pendingTasks.push(task) === 1) {\n                scheduleNextRun();\n            }\n        },\n    };\n}\n//# sourceMappingURL=taskQueue.js.map","import { setTimeout, relativeNow, runOnReadyState, clearTimeout } from '@datadog/browser-core';\nimport { getNavigationEntry } from '../../../browser/performanceUtils';\nexport function trackNavigationTimings(configuration, callback, getNavigationEntryImpl = getNavigationEntry) {\n    return waitAfterLoadEvent(configuration, () => {\n        const entry = getNavigationEntryImpl();\n        if (!isIncompleteNavigation(entry)) {\n            callback(processNavigationEntry(entry));\n        }\n    });\n}\nfunction processNavigationEntry(entry) {\n    return {\n        domComplete: entry.domComplete,\n        domContentLoaded: entry.domContentLoadedEventEnd,\n        domInteractive: entry.domInteractive,\n        loadEvent: entry.loadEventEnd,\n        // In some cases the value reported is negative or is larger\n        // than the current page time. Ignore these cases:\n        // https://github.com/GoogleChrome/web-vitals/issues/137\n        // https://github.com/GoogleChrome/web-vitals/issues/162\n        firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined,\n    };\n}\nfunction isIncompleteNavigation(entry) {\n    return entry.loadEventEnd <= 0;\n}\nfunction waitAfterLoadEvent(configuration, callback) {\n    let timeoutId;\n    const { stop: stopOnReadyState } = runOnReadyState(configuration, 'complete', () => {\n        // Invoke the callback a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n        timeoutId = setTimeout(() => callback());\n    });\n    return {\n        stop: () => {\n            stopOnReadyState();\n            clearTimeout(timeoutId);\n        },\n    };\n}\n//# sourceMappingURL=trackNavigationTimings.js.map","import { addEventListeners } from '@datadog/browser-core';\nexport function trackFirstHidden(configuration, eventTarget = window) {\n    let timeStamp;\n    let stopListeners;\n    if (document.visibilityState === 'hidden') {\n        timeStamp = 0;\n    }\n    else {\n        timeStamp = Infinity;\n        ({ stop: stopListeners } = addEventListeners(configuration, eventTarget, [\"pagehide\" /* DOM_EVENT.PAGE_HIDE */, \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */], (event) => {\n            if (event.type === \"pagehide\" /* DOM_EVENT.PAGE_HIDE */ || document.visibilityState === 'hidden') {\n                timeStamp = event.timeStamp;\n                stopListeners();\n            }\n        }, { capture: true }));\n    }\n    return {\n        get timeStamp() {\n            return timeStamp;\n        },\n        stop() {\n            stopListeners === null || stopListeners === void 0 ? void 0 : stopListeners();\n        },\n    };\n}\n//# sourceMappingURL=trackFirstHidden.js.map","import { trackFirstContentfulPaint } from './trackFirstContentfulPaint';\nimport { trackFirstInput } from './trackFirstInput';\nimport { trackNavigationTimings } from './trackNavigationTimings';\nimport { trackLargestContentfulPaint } from './trackLargestContentfulPaint';\nimport { trackFirstHidden } from './trackFirstHidden';\nexport function trackInitialViewMetrics(configuration, setLoadEvent, scheduleViewUpdate) {\n    const initialViewMetrics = {};\n    const { stop: stopNavigationTracking } = trackNavigationTimings(configuration, (navigationTimings) => {\n        setLoadEvent(navigationTimings.loadEvent);\n        initialViewMetrics.navigationTimings = navigationTimings;\n        scheduleViewUpdate();\n    });\n    const firstHidden = trackFirstHidden(configuration);\n    const { stop: stopFCPTracking } = trackFirstContentfulPaint(configuration, firstHidden, (firstContentfulPaint) => {\n        initialViewMetrics.firstContentfulPaint = firstContentfulPaint;\n        scheduleViewUpdate();\n    });\n    const { stop: stopLCPTracking } = trackLargestContentfulPaint(configuration, firstHidden, window, (largestContentfulPaint) => {\n        initialViewMetrics.largestContentfulPaint = largestContentfulPaint;\n        scheduleViewUpdate();\n    });\n    const { stop: stopFIDTracking } = trackFirstInput(configuration, firstHidden, (firstInput) => {\n        initialViewMetrics.firstInput = firstInput;\n        scheduleViewUpdate();\n    });\n    function stop() {\n        stopNavigationTracking();\n        stopFCPTracking();\n        stopLCPTracking();\n        stopFIDTracking();\n        firstHidden.stop();\n    }\n    return {\n        stop,\n        initialViewMetrics,\n    };\n}\n//# sourceMappingURL=trackInitialViewMetrics.js.map","import { ONE_MINUTE } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../../browser/performanceObservable';\n// Discard FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const FCP_MAXIMUM_DELAY = 10 * ONE_MINUTE;\nexport function trackFirstContentfulPaint(configuration, firstHidden, callback) {\n    const performanceSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.PAINT,\n        buffered: true,\n    }).subscribe((entries) => {\n        const fcpEntry = entries.find((entry) => entry.name === 'first-contentful-paint' &&\n            entry.startTime < firstHidden.timeStamp &&\n            entry.startTime < FCP_MAXIMUM_DELAY);\n        if (fcpEntry) {\n            callback(fcpEntry.startTime);\n        }\n    });\n    return {\n        stop: performanceSubscription.unsubscribe,\n    };\n}\n//# sourceMappingURL=trackFirstContentfulPaint.js.map","import { ONE_MINUTE, addEventListeners, findLast } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../../browser/performanceObservable';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\n// Discard LCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const LCP_MAXIMUM_DELAY = 10 * ONE_MINUTE;\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/onLCP.ts\n */\nexport function trackLargestContentfulPaint(configuration, firstHidden, eventTarget, callback) {\n    // Ignore entries that come after the first user interaction. According to the documentation, the\n    // browser should not send largest-contentful-paint entries after a user interact with the page,\n    // but the web-vitals reference implementation uses this as a safeguard.\n    let firstInteractionTimestamp = Infinity;\n    const { stop: stopEventListener } = addEventListeners(configuration, eventTarget, [\"pointerdown\" /* DOM_EVENT.POINTER_DOWN */, \"keydown\" /* DOM_EVENT.KEY_DOWN */], (event) => {\n        firstInteractionTimestamp = event.timeStamp;\n    }, { capture: true, once: true });\n    let biggestLcpSize = 0;\n    const performanceLcpSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT,\n        buffered: true,\n    }).subscribe((entries) => {\n        const lcpEntry = findLast(entries, (entry) => entry.entryType === RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT &&\n            entry.startTime < firstInteractionTimestamp &&\n            entry.startTime < firstHidden.timeStamp &&\n            entry.startTime < LCP_MAXIMUM_DELAY &&\n            // Ensure to get the LCP entry with the biggest size, see\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=1516655\n            entry.size > biggestLcpSize);\n        if (lcpEntry) {\n            let lcpTargetSelector;\n            if (lcpEntry.element) {\n                lcpTargetSelector = getSelectorFromElement(lcpEntry.element, configuration.actionNameAttribute);\n            }\n            callback({\n                value: lcpEntry.startTime,\n                targetSelector: lcpTargetSelector,\n                resourceUrl: computeLcpEntryUrl(lcpEntry),\n            });\n            biggestLcpSize = lcpEntry.size;\n        }\n    });\n    return {\n        stop: () => {\n            stopEventListener();\n            performanceLcpSubscription.unsubscribe();\n        },\n    };\n}\n// The property url report an empty string if the value is not available, we shouldn't report it in this case.\nfunction computeLcpEntryUrl(entry) {\n    return entry.url === '' ? undefined : entry.url;\n}\n//# sourceMappingURL=trackLargestContentfulPaint.js.map","import { elapsed } from '@datadog/browser-core';\nimport { isElementNode } from '../../../browser/htmlDomUtils';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../../browser/performanceObservable';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInput(configuration, firstHidden, callback) {\n    const performanceFirstInputSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.FIRST_INPUT,\n        buffered: true,\n    }).subscribe((entries) => {\n        const firstInputEntry = entries.find((entry) => entry.startTime < firstHidden.timeStamp);\n        if (firstInputEntry) {\n            const firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart);\n            let firstInputTargetSelector;\n            if (firstInputEntry.target && isElementNode(firstInputEntry.target)) {\n                firstInputTargetSelector = getSelectorFromElement(firstInputEntry.target, configuration.actionNameAttribute);\n            }\n            callback({\n                // Ensure firstInputDelay to be positive, see\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n                delay: firstInputDelay >= 0 ? firstInputDelay : 0,\n                time: firstInputEntry.startTime,\n                targetSelector: firstInputTargetSelector,\n            });\n        }\n    });\n    return {\n        stop: () => {\n            performanceFirstInputSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackFirstInput.js.map","import { round, ONE_SECOND, noop, elapsed } from '@datadog/browser-core';\nimport { isElementNode } from '../../../browser/htmlDomUtils';\nimport { supportPerformanceTimingEvent, RumPerformanceEntryType, createPerformanceObservable, } from '../../../browser/performanceObservable';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nexport function trackCumulativeLayoutShift(configuration, viewStart, callback) {\n    if (!isLayoutShiftSupported()) {\n        return {\n            stop: noop,\n        };\n    }\n    let maxClsValue = 0;\n    let biggestShift;\n    // if no layout shift happen the value should be reported as 0\n    callback({\n        value: 0,\n    });\n    const window = slidingSessionWindow();\n    const performanceSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.LAYOUT_SHIFT,\n        buffered: true,\n    }).subscribe((entries) => {\n        var _a;\n        for (const entry of entries) {\n            if (entry.hadRecentInput || entry.startTime < viewStart) {\n                continue;\n            }\n            const { cumulatedValue, isMaxValue } = window.update(entry);\n            if (isMaxValue) {\n                const attribution = getFirstElementAttribution(entry.sources);\n                biggestShift = {\n                    target: (attribution === null || attribution === void 0 ? void 0 : attribution.node) ? new WeakRef(attribution.node) : undefined,\n                    time: elapsed(viewStart, entry.startTime),\n                    previousRect: attribution === null || attribution === void 0 ? void 0 : attribution.previousRect,\n                    currentRect: attribution === null || attribution === void 0 ? void 0 : attribution.currentRect,\n                };\n            }\n            if (cumulatedValue > maxClsValue) {\n                maxClsValue = cumulatedValue;\n                const target = (_a = biggestShift === null || biggestShift === void 0 ? void 0 : biggestShift.target) === null || _a === void 0 ? void 0 : _a.deref();\n                callback({\n                    value: round(maxClsValue, 4),\n                    targetSelector: target && getSelectorFromElement(target, configuration.actionNameAttribute),\n                    time: biggestShift === null || biggestShift === void 0 ? void 0 : biggestShift.time,\n                    previousRect: (biggestShift === null || biggestShift === void 0 ? void 0 : biggestShift.previousRect) ? asRumRect(biggestShift.previousRect) : undefined,\n                    currentRect: (biggestShift === null || biggestShift === void 0 ? void 0 : biggestShift.currentRect) ? asRumRect(biggestShift.currentRect) : undefined,\n                });\n            }\n        }\n    });\n    return {\n        stop: () => {\n            performanceSubscription.unsubscribe();\n        },\n    };\n}\nfunction getFirstElementAttribution(sources) {\n    return sources.find((source) => !!source.node && isElementNode(source.node));\n}\nfunction asRumRect({ x, y, width, height }) {\n    return { x, y, width, height };\n}\nexport const MAX_WINDOW_DURATION = 5 * ONE_SECOND;\nconst MAX_UPDATE_GAP = ONE_SECOND;\nfunction slidingSessionWindow() {\n    let cumulatedValue = 0;\n    let startTime;\n    let endTime;\n    let maxValue = 0;\n    return {\n        update: (entry) => {\n            const shouldCreateNewWindow = startTime === undefined ||\n                entry.startTime - endTime >= MAX_UPDATE_GAP ||\n                entry.startTime - startTime >= MAX_WINDOW_DURATION;\n            let isMaxValue;\n            if (shouldCreateNewWindow) {\n                startTime = endTime = entry.startTime;\n                maxValue = cumulatedValue = entry.value;\n                isMaxValue = true;\n            }\n            else {\n                cumulatedValue += entry.value;\n                endTime = entry.startTime;\n                isMaxValue = entry.value > maxValue;\n                if (isMaxValue) {\n                    maxValue = entry.value;\n                }\n            }\n            return {\n                cumulatedValue,\n                isMaxValue,\n            };\n        },\n    };\n}\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nexport function isLayoutShiftSupported() {\n    return supportPerformanceTimingEvent(RumPerformanceEntryType.LAYOUT_SHIFT) && 'WeakRef' in window;\n}\n//# sourceMappingURL=trackCumulativeLayoutShift.js.map","/**\n * performance.interactionCount polyfill\n *\n * The interactionCount is an integer which counts the total number of distinct user interactions,\n * for which there was a unique interactionId.\n *\n * The interactionCount polyfill is an estimate based on a convention specific to Chrome. Cf: https://github.com/GoogleChrome/web-vitals/pull/213\n * This is currently not an issue as the polyfill is only used for INP which is currently only supported on Chrome.\n * Hopefully when/if other browsers will support INP, they will also implement performance.interactionCount at the same time, so we won't need that polyfill.\n *\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/lib/polyfills/interactionCountPolyfill.ts\n */\nimport { monitor } from '@datadog/browser-core';\nlet observer;\nlet interactionCountEstimate = 0;\nlet minKnownInteractionId = Infinity;\nlet maxKnownInteractionId = 0;\nexport function initInteractionCountPolyfill() {\n    if ('interactionCount' in performance || observer) {\n        return;\n    }\n    observer = new window.PerformanceObserver(monitor((entries) => {\n        entries.getEntries().forEach((e) => {\n            const entry = e;\n            if (entry.interactionId) {\n                minKnownInteractionId = Math.min(minKnownInteractionId, entry.interactionId);\n                maxKnownInteractionId = Math.max(maxKnownInteractionId, entry.interactionId);\n                interactionCountEstimate = (maxKnownInteractionId - minKnownInteractionId) / 7 + 1;\n            }\n        });\n    }));\n    observer.observe({ type: 'event', buffered: true, durationThreshold: 0 });\n}\n/**\n * Returns the `interactionCount` value using the native API (if available)\n * or the polyfill estimate in this module.\n */\nexport const getInteractionCount = () => observer ? interactionCountEstimate : window.performance.interactionCount || 0;\n//# sourceMappingURL=interactionCountPolyfill.js.map","import { elapsed, noop, ONE_MINUTE } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType, supportPerformanceTimingEvent, } from '../../../browser/performanceObservable';\nimport { getSelectorFromElement } from '../../getSelectorFromElement';\nimport { isElementNode } from '../../../browser/htmlDomUtils';\nimport { getInteractionSelector } from '../../action/interactionSelectorCache';\nimport { getInteractionCount, initInteractionCountPolyfill } from './interactionCountPolyfill';\n// Arbitrary value to prevent unnecessary memory usage on views with lots of interactions.\nconst MAX_INTERACTION_ENTRIES = 10;\n// Arbitrary value to cap INP outliers\nexport const MAX_INP_VALUE = (1 * ONE_MINUTE);\n/**\n * Track the interaction to next paint (INP).\n * To avoid outliers, return the p98 worst interaction of the view.\n * Documentation: https://web.dev/inp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/onINP.ts\n */\nexport function trackInteractionToNextPaint(configuration, viewStart, viewLoadingType) {\n    if (!isInteractionToNextPaintSupported()) {\n        return {\n            getInteractionToNextPaint: () => undefined,\n            setViewEnd: noop,\n            stop: noop,\n        };\n    }\n    const { getViewInteractionCount, stopViewInteractionCount } = trackViewInteractionCount(viewLoadingType);\n    let viewEnd = Infinity;\n    const longestInteractions = trackLongestInteractions(getViewInteractionCount);\n    let interactionToNextPaint = -1;\n    let interactionToNextPaintTargetSelector;\n    let interactionToNextPaintStartTime;\n    function handleEntries(entries) {\n        for (const entry of entries) {\n            if (entry.interactionId &&\n                // Check the entry start time is inside the view bounds because some view interactions can be reported after the view end (if long duration).\n                entry.startTime >= viewStart &&\n                entry.startTime <= viewEnd) {\n                longestInteractions.process(entry);\n            }\n        }\n        const newInteraction = longestInteractions.estimateP98Interaction();\n        if (newInteraction && newInteraction.duration !== interactionToNextPaint) {\n            interactionToNextPaint = newInteraction.duration;\n            interactionToNextPaintStartTime = elapsed(viewStart, newInteraction.startTime);\n            interactionToNextPaintTargetSelector = getInteractionSelector(newInteraction.startTime);\n            if (!interactionToNextPaintTargetSelector && newInteraction.target && isElementNode(newInteraction.target)) {\n                interactionToNextPaintTargetSelector = getSelectorFromElement(newInteraction.target, configuration.actionNameAttribute);\n            }\n        }\n    }\n    const firstInputSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.FIRST_INPUT,\n        buffered: true,\n    }).subscribe(handleEntries);\n    const eventSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.EVENT,\n        // durationThreshold only impact PerformanceEventTiming entries used for INP computation which requires a threshold at 40 (default is 104ms)\n        // cf: https://github.com/GoogleChrome/web-vitals/blob/3806160ffbc93c3c4abf210a167b81228172b31c/src/onINP.ts#L202-L210\n        durationThreshold: 40,\n        buffered: true,\n    }).subscribe(handleEntries);\n    return {\n        getInteractionToNextPaint: () => {\n            // If no INP duration where captured because of the performanceObserver 40ms threshold\n            // but the view interaction count > 0 then report 0\n            if (interactionToNextPaint >= 0) {\n                return {\n                    value: Math.min(interactionToNextPaint, MAX_INP_VALUE),\n                    targetSelector: interactionToNextPaintTargetSelector,\n                    time: interactionToNextPaintStartTime,\n                };\n            }\n            else if (getViewInteractionCount()) {\n                return {\n                    value: 0,\n                };\n            }\n        },\n        setViewEnd: (viewEndTime) => {\n            viewEnd = viewEndTime;\n            stopViewInteractionCount();\n        },\n        stop: () => {\n            eventSubscription.unsubscribe();\n            firstInputSubscription.unsubscribe();\n        },\n    };\n}\nfunction trackLongestInteractions(getViewInteractionCount) {\n    const longestInteractions = [];\n    function sortAndTrimLongestInteractions() {\n        longestInteractions.sort((a, b) => b.duration - a.duration).splice(MAX_INTERACTION_ENTRIES);\n    }\n    return {\n        /**\n         * Process the performance entry:\n         * - if its duration is long enough, add the performance entry to the list of worst interactions\n         * - if an entry with the same interaction id exists and its duration is lower than the new one, then replace it in the list of worst interactions\n         */\n        process(entry) {\n            const interactionIndex = longestInteractions.findIndex((interaction) => entry.interactionId === interaction.interactionId);\n            const minLongestInteraction = longestInteractions[longestInteractions.length - 1];\n            if (interactionIndex !== -1) {\n                if (entry.duration > longestInteractions[interactionIndex].duration) {\n                    longestInteractions[interactionIndex] = entry;\n                    sortAndTrimLongestInteractions();\n                }\n            }\n            else if (longestInteractions.length < MAX_INTERACTION_ENTRIES ||\n                entry.duration > minLongestInteraction.duration) {\n                longestInteractions.push(entry);\n                sortAndTrimLongestInteractions();\n            }\n        },\n        /**\n         * Compute the p98 longest interaction.\n         * For better performance the computation is based on 10 longest interactions and the interaction count of the current view.\n         */\n        estimateP98Interaction() {\n            const interactionIndex = Math.min(longestInteractions.length - 1, Math.floor(getViewInteractionCount() / 50));\n            return longestInteractions[interactionIndex];\n        },\n    };\n}\nexport function trackViewInteractionCount(viewLoadingType) {\n    initInteractionCountPolyfill();\n    const previousInteractionCount = viewLoadingType === \"initial_load\" /* ViewLoadingType.INITIAL_LOAD */ ? 0 : getInteractionCount();\n    let state = { stopped: false };\n    function computeViewInteractionCount() {\n        return getInteractionCount() - previousInteractionCount;\n    }\n    return {\n        getViewInteractionCount: () => {\n            if (state.stopped) {\n                return state.interactionCount;\n            }\n            return computeViewInteractionCount();\n        },\n        stopViewInteractionCount: () => {\n            state = { stopped: true, interactionCount: computeViewInteractionCount() };\n        },\n    };\n}\nexport function isInteractionToNextPaintSupported() {\n    return (supportPerformanceTimingEvent(RumPerformanceEntryType.EVENT) &&\n        window.PerformanceEventTiming &&\n        'interactionId' in PerformanceEventTiming.prototype);\n}\n//# sourceMappingURL=trackInteractionToNextPaint.js.map","export function getScrollX() {\n    let scrollX;\n    const visual = window.visualViewport;\n    if (visual) {\n        scrollX = visual.pageLeft - visual.offsetLeft;\n    }\n    else if (window.scrollX !== undefined) {\n        scrollX = window.scrollX;\n    }\n    else {\n        scrollX = window.pageXOffset || 0;\n    }\n    return Math.round(scrollX);\n}\nexport function getScrollY() {\n    let scrollY;\n    const visual = window.visualViewport;\n    if (visual) {\n        scrollY = visual.pageTop - visual.offsetTop;\n    }\n    else if (window.scrollY !== undefined) {\n        scrollY = window.scrollY;\n    }\n    else {\n        scrollY = window.pageYOffset || 0;\n    }\n    return Math.round(scrollY);\n}\n//# sourceMappingURL=scroll.js.map","import { Observable, throttle, addEventListener } from '@datadog/browser-core';\nlet viewportObservable;\nexport function initViewportObservable(configuration) {\n    if (!viewportObservable) {\n        viewportObservable = createViewportObservable(configuration);\n    }\n    return viewportObservable;\n}\nexport function createViewportObservable(configuration) {\n    return new Observable((observable) => {\n        const { throttled: updateDimension } = throttle(() => {\n            observable.notify(getViewportDimension());\n        }, 200);\n        return addEventListener(configuration, window, \"resize\" /* DOM_EVENT.RESIZE */, updateDimension, { capture: true, passive: true })\n            .stop;\n    });\n}\n// excludes the width and height of any rendered classic scrollbar that is fixed to the visual viewport\nexport function getViewportDimension() {\n    const visual = window.visualViewport;\n    if (visual) {\n        return {\n            width: Number(visual.width * visual.scale),\n            height: Number(visual.height * visual.scale),\n        };\n    }\n    return {\n        width: Number(window.innerWidth || 0),\n        height: Number(window.innerHeight || 0),\n    };\n}\n//# sourceMappingURL=viewportObservable.js.map","import { Observable, ONE_SECOND, elapsed, relativeNow, throttle, addEventListener, monitor, } from '@datadog/browser-core';\nimport { getScrollY } from '../../../browser/scroll';\nimport { getViewportDimension } from '../../../browser/viewportObservable';\n/** Arbitrary scroll throttle duration */\nexport const THROTTLE_SCROLL_DURATION = ONE_SECOND;\nexport function trackScrollMetrics(configuration, viewStart, callback, scrollValues = createScrollValuesObservable(configuration)) {\n    let maxScrollDepth = 0;\n    let maxScrollHeight = 0;\n    let maxScrollHeightTime = 0;\n    const subscription = scrollValues.subscribe(({ scrollDepth, scrollTop, scrollHeight }) => {\n        let shouldUpdate = false;\n        if (scrollDepth > maxScrollDepth) {\n            maxScrollDepth = scrollDepth;\n            shouldUpdate = true;\n        }\n        if (scrollHeight > maxScrollHeight) {\n            maxScrollHeight = scrollHeight;\n            const now = relativeNow();\n            maxScrollHeightTime = elapsed(viewStart.relative, now);\n            shouldUpdate = true;\n        }\n        if (shouldUpdate) {\n            callback({\n                maxDepth: Math.min(maxScrollDepth, maxScrollHeight),\n                maxDepthScrollTop: scrollTop,\n                maxScrollHeight,\n                maxScrollHeightTime,\n            });\n        }\n    });\n    return {\n        stop: () => subscription.unsubscribe(),\n    };\n}\nexport function computeScrollValues() {\n    const scrollTop = getScrollY();\n    const { height } = getViewportDimension();\n    const scrollHeight = Math.round((document.scrollingElement || document.documentElement).scrollHeight);\n    const scrollDepth = Math.round(height + scrollTop);\n    return {\n        scrollHeight,\n        scrollDepth,\n        scrollTop,\n    };\n}\nexport function createScrollValuesObservable(configuration, throttleDuration = THROTTLE_SCROLL_DURATION) {\n    return new Observable((observable) => {\n        function notify() {\n            observable.notify(computeScrollValues());\n        }\n        if (window.ResizeObserver) {\n            const throttledNotify = throttle(notify, throttleDuration, {\n                leading: false,\n                trailing: true,\n            });\n            const observerTarget = document.scrollingElement || document.documentElement;\n            const resizeObserver = new ResizeObserver(monitor(throttledNotify.throttled));\n            if (observerTarget) {\n                resizeObserver.observe(observerTarget);\n            }\n            const eventListener = addEventListener(configuration, window, \"scroll\" /* DOM_EVENT.SCROLL */, throttledNotify.throttled, {\n                passive: true,\n            });\n            return () => {\n                throttledNotify.cancel();\n                resizeObserver.disconnect();\n                eventListener.stop();\n            };\n        }\n    });\n}\n//# sourceMappingURL=trackScrollMetrics.js.map","import { trackCumulativeLayoutShift } from './trackCumulativeLayoutShift';\nimport { trackInteractionToNextPaint } from './trackInteractionToNextPaint';\nimport { trackLoadingTime } from './trackLoadingTime';\nimport { trackScrollMetrics } from './trackScrollMetrics';\nexport function trackCommonViewMetrics(lifeCycle, domMutationObservable, windowOpenObservable, configuration, scheduleViewUpdate, loadingType, viewStart) {\n    const commonViewMetrics = {};\n    const { stop: stopLoadingTimeTracking, setLoadEvent } = trackLoadingTime(lifeCycle, domMutationObservable, windowOpenObservable, configuration, loadingType, viewStart, (newLoadingTime) => {\n        commonViewMetrics.loadingTime = newLoadingTime;\n        scheduleViewUpdate();\n    });\n    const { stop: stopScrollMetricsTracking } = trackScrollMetrics(configuration, viewStart, (newScrollMetrics) => {\n        commonViewMetrics.scroll = newScrollMetrics;\n    });\n    const { stop: stopCLSTracking } = trackCumulativeLayoutShift(configuration, viewStart.relative, (cumulativeLayoutShift) => {\n        commonViewMetrics.cumulativeLayoutShift = cumulativeLayoutShift;\n        scheduleViewUpdate();\n    });\n    const { stop: stopINPTracking, getInteractionToNextPaint, setViewEnd, } = trackInteractionToNextPaint(configuration, viewStart.relative, loadingType);\n    return {\n        stop: () => {\n            stopLoadingTimeTracking();\n            stopCLSTracking();\n            stopScrollMetricsTracking();\n        },\n        stopINPTracking,\n        setLoadEvent,\n        setViewEnd,\n        getCommonViewMetrics: () => {\n            commonViewMetrics.interactionToNextPaint = getInteractionToNextPaint();\n            return commonViewMetrics;\n        },\n    };\n}\n//# sourceMappingURL=trackCommonViewMetrics.js.map","import { elapsed } from '@datadog/browser-core';\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd';\nimport { trackFirstHidden } from './trackFirstHidden';\nexport function trackLoadingTime(lifeCycle, domMutationObservable, windowOpenObservable, configuration, loadType, viewStart, callback) {\n    let isWaitingForLoadEvent = loadType === \"initial_load\" /* ViewLoadingType.INITIAL_LOAD */;\n    let isWaitingForActivityLoadingTime = true;\n    const loadingTimeCandidates = [];\n    const firstHidden = trackFirstHidden(configuration);\n    function invokeCallbackIfAllCandidatesAreReceived() {\n        if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n            const loadingTime = Math.max(...loadingTimeCandidates);\n            if (loadingTime < firstHidden.timeStamp) {\n                callback(loadingTime);\n            }\n        }\n    }\n    const { stop } = waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, (event) => {\n        if (isWaitingForActivityLoadingTime) {\n            isWaitingForActivityLoadingTime = false;\n            if (event.hadActivity) {\n                loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end));\n            }\n            invokeCallbackIfAllCandidatesAreReceived();\n        }\n    });\n    return {\n        stop: () => {\n            stop();\n            firstHidden.stop();\n        },\n        setLoadEvent: (loadEvent) => {\n            if (isWaitingForLoadEvent) {\n                isWaitingForLoadEvent = false;\n                loadingTimeCandidates.push(loadEvent);\n                invokeCallbackIfAllCandidatesAreReceived();\n            }\n        },\n    };\n}\n//# sourceMappingURL=trackLoadingTime.js.map","import { noop, PageExitReason, shallowClone, elapsed, generateUUID, ONE_MINUTE, throttle, clocksNow, clocksOrigin, timeStampNow, display, looksLikeRelativeTime, setInterval, clearInterval, setTimeout, Observable, createContextManager, } from '@datadog/browser-core';\nimport { trackViewEventCounts } from './trackViewEventCounts';\nimport { trackInitialViewMetrics } from './viewMetrics/trackInitialViewMetrics';\nimport { trackCommonViewMetrics } from './viewMetrics/trackCommonViewMetrics';\nexport const THROTTLE_VIEW_UPDATE_PERIOD = 3000;\nexport const SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE;\n// Some events or metrics can be captured after the end of the view. To avoid missing those;\n// an arbitrary delay is added for stopping their tracking after the view ends.\n//\n// Ideally, we would not stop and keep tracking events or metrics until the end of the session.\n// But this might have a small performance impact if there are many many views.\n// So let's have a fairly short delay improving the situation in most cases and avoid impacting performances too much.\nexport const KEEP_TRACKING_AFTER_VIEW_DELAY = 5 * ONE_MINUTE;\nexport function trackViews(location, lifeCycle, domMutationObservable, windowOpenObservable, configuration, locationChangeObservable, areViewsTrackedAutomatically, initialViewOptions) {\n    const activeViews = new Set();\n    let currentView = startNewView(\"initial_load\" /* ViewLoadingType.INITIAL_LOAD */, clocksOrigin(), initialViewOptions);\n    startViewLifeCycle();\n    let locationChangeSubscription;\n    if (areViewsTrackedAutomatically) {\n        locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable);\n    }\n    function startNewView(loadingType, startClocks, viewOptions) {\n        const newlyCreatedView = newView(lifeCycle, domMutationObservable, windowOpenObservable, configuration, location, loadingType, startClocks, viewOptions);\n        activeViews.add(newlyCreatedView);\n        newlyCreatedView.stopObservable.subscribe(() => {\n            activeViews.delete(newlyCreatedView);\n        });\n        return newlyCreatedView;\n    }\n    function startViewLifeCycle() {\n        lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, () => {\n            // Renew view on session renewal\n            currentView = startNewView(\"route_change\" /* ViewLoadingType.ROUTE_CHANGE */, undefined, {\n                name: currentView.name,\n                service: currentView.service,\n                version: currentView.version,\n                context: currentView.contextManager.getContext(),\n            });\n        });\n        lifeCycle.subscribe(9 /* LifeCycleEventType.SESSION_EXPIRED */, () => {\n            currentView.end({ sessionIsActive: false });\n        });\n        // End the current view on page unload\n        lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_EXITED */, (pageExitEvent) => {\n            if (pageExitEvent.reason === PageExitReason.UNLOADING) {\n                currentView.end();\n            }\n        });\n    }\n    function renewViewOnLocationChange(locationChangeObservable) {\n        return locationChangeObservable.subscribe(({ oldLocation, newLocation }) => {\n            if (areDifferentLocation(oldLocation, newLocation)) {\n                currentView.end();\n                currentView = startNewView(\"route_change\" /* ViewLoadingType.ROUTE_CHANGE */);\n            }\n        });\n    }\n    return {\n        addTiming: (name, time = timeStampNow()) => {\n            currentView.addTiming(name, time);\n        },\n        startView: (options, startClocks) => {\n            currentView.end({ endClocks: startClocks });\n            currentView = startNewView(\"route_change\" /* ViewLoadingType.ROUTE_CHANGE */, startClocks, options);\n        },\n        setViewContext: (context) => {\n            currentView.contextManager.setContext(context);\n        },\n        setViewContextProperty: (key, value) => {\n            currentView.contextManager.setContextProperty(key, value);\n        },\n        setViewName: (name) => {\n            currentView.setViewName(name);\n        },\n        getViewContext: () => currentView.contextManager.getContext(),\n        stop: () => {\n            if (locationChangeSubscription) {\n                locationChangeSubscription.unsubscribe();\n            }\n            currentView.end();\n            activeViews.forEach((view) => view.stop());\n        },\n    };\n}\nfunction newView(lifeCycle, domMutationObservable, windowOpenObservable, configuration, initialLocation, loadingType, startClocks = clocksNow(), viewOptions) {\n    // Setup initial values\n    const id = generateUUID();\n    const stopObservable = new Observable();\n    const customTimings = {};\n    let documentVersion = 0;\n    let endClocks;\n    const location = shallowClone(initialLocation);\n    const contextManager = createContextManager();\n    let sessionIsActive = true;\n    let name = viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.name;\n    const service = (viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.service) || configuration.service;\n    const version = (viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.version) || configuration.version;\n    const context = viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.context;\n    if (context) {\n        contextManager.setContext(context);\n    }\n    const viewCreatedEvent = {\n        id,\n        name,\n        startClocks,\n        service,\n        version,\n        context,\n    };\n    lifeCycle.notify(1 /* LifeCycleEventType.BEFORE_VIEW_CREATED */, viewCreatedEvent);\n    lifeCycle.notify(2 /* LifeCycleEventType.VIEW_CREATED */, viewCreatedEvent);\n    // Update the view every time the measures are changing\n    const { throttled, cancel: cancelScheduleViewUpdate } = throttle(triggerViewUpdate, THROTTLE_VIEW_UPDATE_PERIOD, {\n        leading: false,\n    });\n    const { setLoadEvent, setViewEnd, stop: stopCommonViewMetricsTracking, stopINPTracking, getCommonViewMetrics, } = trackCommonViewMetrics(lifeCycle, domMutationObservable, windowOpenObservable, configuration, scheduleViewUpdate, loadingType, startClocks);\n    const { stop: stopInitialViewMetricsTracking, initialViewMetrics } = loadingType === \"initial_load\" /* ViewLoadingType.INITIAL_LOAD */\n        ? trackInitialViewMetrics(configuration, setLoadEvent, scheduleViewUpdate)\n        : { stop: noop, initialViewMetrics: {} };\n    const { stop: stopEventCountsTracking, eventCounts } = trackViewEventCounts(lifeCycle, id, scheduleViewUpdate);\n    // Session keep alive\n    const keepAliveIntervalId = setInterval(triggerViewUpdate, SESSION_KEEP_ALIVE_INTERVAL);\n    // Initial view update\n    triggerViewUpdate();\n    // View context update should always be throttled\n    contextManager.changeObservable.subscribe(scheduleViewUpdate);\n    function triggerBeforeViewUpdate() {\n        lifeCycle.notify(3 /* LifeCycleEventType.BEFORE_VIEW_UPDATED */, {\n            id,\n            name,\n            context: contextManager.getContext(),\n            startClocks,\n        });\n    }\n    function scheduleViewUpdate() {\n        triggerBeforeViewUpdate();\n        throttled();\n    }\n    function triggerViewUpdate() {\n        cancelScheduleViewUpdate();\n        triggerBeforeViewUpdate();\n        documentVersion += 1;\n        const currentEnd = endClocks === undefined ? timeStampNow() : endClocks.timeStamp;\n        lifeCycle.notify(4 /* LifeCycleEventType.VIEW_UPDATED */, {\n            customTimings,\n            documentVersion,\n            id,\n            name,\n            service,\n            version,\n            context: contextManager.getContext(),\n            loadingType,\n            location,\n            startClocks,\n            commonViewMetrics: getCommonViewMetrics(),\n            initialViewMetrics,\n            duration: elapsed(startClocks.timeStamp, currentEnd),\n            isActive: endClocks === undefined,\n            sessionIsActive,\n            eventCounts,\n        });\n    }\n    return {\n        get name() {\n            return name;\n        },\n        service,\n        version,\n        contextManager,\n        stopObservable,\n        end(options = {}) {\n            var _a, _b;\n            if (endClocks) {\n                // view already ended\n                return;\n            }\n            endClocks = (_a = options.endClocks) !== null && _a !== void 0 ? _a : clocksNow();\n            sessionIsActive = (_b = options.sessionIsActive) !== null && _b !== void 0 ? _b : true;\n            lifeCycle.notify(5 /* LifeCycleEventType.VIEW_ENDED */, { endClocks });\n            lifeCycle.notify(6 /* LifeCycleEventType.AFTER_VIEW_ENDED */, { endClocks });\n            clearInterval(keepAliveIntervalId);\n            setViewEnd(endClocks.relative);\n            stopCommonViewMetricsTracking();\n            triggerViewUpdate();\n            setTimeout(() => {\n                this.stop();\n            }, KEEP_TRACKING_AFTER_VIEW_DELAY);\n        },\n        stop() {\n            stopInitialViewMetricsTracking();\n            stopEventCountsTracking();\n            stopINPTracking();\n            stopObservable.notify();\n        },\n        addTiming(name, time) {\n            if (endClocks) {\n                return;\n            }\n            const relativeTime = looksLikeRelativeTime(time) ? time : elapsed(startClocks.timeStamp, time);\n            customTimings[sanitizeTiming(name)] = relativeTime;\n            scheduleViewUpdate();\n        },\n        setViewName(updatedName) {\n            name = updatedName;\n            triggerViewUpdate();\n        },\n    };\n}\n/**\n * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $\n */\nfunction sanitizeTiming(name) {\n    const sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_');\n    if (sanitized !== name) {\n        display.warn(`Invalid timing name: ${name}, sanitized to: ${sanitized}`);\n    }\n    return sanitized;\n}\nfunction areDifferentLocation(currentLocation, otherLocation) {\n    return (currentLocation.pathname !== otherLocation.pathname ||\n        (!isHashAnAnchor(otherLocation.hash) &&\n            getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash)));\n}\nfunction isHashAnAnchor(hash) {\n    const correspondingId = hash.substring(1);\n    // check if the correspondingId is empty because on Firefox an empty string passed to getElementById() prints a consol warning\n    return correspondingId !== '' && !!document.getElementById(correspondingId);\n}\nfunction getPathFromHash(hash) {\n    const index = hash.indexOf('?');\n    return index < 0 ? hash : hash.slice(0, index);\n}\n//# sourceMappingURL=trackViews.js.map","import { trackEventCounts } from '../trackEventCounts';\nexport function trackViewEventCounts(lifeCycle, viewId, onChange) {\n    const { stop, eventCounts } = trackEventCounts({\n        lifeCycle,\n        isChildEvent: (event) => event.view.id === viewId,\n        onChange,\n    });\n    return {\n        stop,\n        eventCounts,\n    };\n}\n//# sourceMappingURL=trackViewEventCounts.js.map","import { isEmptyObject, mapValues, toServerDuration } from '@datadog/browser-core';\nimport { discardNegativeDuration } from '../discardNegativeDuration';\nimport { trackViews } from './trackViews';\nexport function startViewCollection(lifeCycle, hooks, configuration, location, domMutationObservable, pageOpenObservable, locationChangeObservable, pageStateHistory, recorderApi, viewHistory, initialViewOptions) {\n    lifeCycle.subscribe(4 /* LifeCycleEventType.VIEW_UPDATED */, (view) => lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processViewUpdate(view, configuration, recorderApi, pageStateHistory)));\n    hooks.register(0 /* HookNames.Assemble */, ({ startTime, eventType }) => {\n        const { service, version, id, name, context } = viewHistory.findView(startTime);\n        return {\n            type: eventType,\n            service,\n            version,\n            context,\n            view: {\n                id,\n                name,\n            },\n        };\n    });\n    return trackViews(location, lifeCycle, domMutationObservable, pageOpenObservable, configuration, locationChangeObservable, !configuration.trackViewsManually, initialViewOptions);\n}\nfunction processViewUpdate(view, configuration, recorderApi, pageStateHistory) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n    const replayStats = recorderApi.getReplayStats(view.id);\n    const pageStates = pageStateHistory.findAll(view.startClocks.relative, view.duration);\n    const viewEvent = {\n        _dd: {\n            document_version: view.documentVersion,\n            replay_stats: replayStats,\n            page_states: pageStates,\n            configuration: {\n                start_session_replay_recording_manually: configuration.startSessionReplayRecordingManually,\n            },\n        },\n        date: view.startClocks.timeStamp,\n        type: \"view\" /* RumEventType.VIEW */,\n        view: {\n            action: {\n                count: view.eventCounts.actionCount,\n            },\n            frustration: {\n                count: view.eventCounts.frustrationCount,\n            },\n            cumulative_layout_shift: (_a = view.commonViewMetrics.cumulativeLayoutShift) === null || _a === void 0 ? void 0 : _a.value,\n            cumulative_layout_shift_time: toServerDuration((_b = view.commonViewMetrics.cumulativeLayoutShift) === null || _b === void 0 ? void 0 : _b.time),\n            cumulative_layout_shift_target_selector: (_c = view.commonViewMetrics.cumulativeLayoutShift) === null || _c === void 0 ? void 0 : _c.targetSelector,\n            first_byte: toServerDuration((_d = view.initialViewMetrics.navigationTimings) === null || _d === void 0 ? void 0 : _d.firstByte),\n            dom_complete: toServerDuration((_e = view.initialViewMetrics.navigationTimings) === null || _e === void 0 ? void 0 : _e.domComplete),\n            dom_content_loaded: toServerDuration((_f = view.initialViewMetrics.navigationTimings) === null || _f === void 0 ? void 0 : _f.domContentLoaded),\n            dom_interactive: toServerDuration((_g = view.initialViewMetrics.navigationTimings) === null || _g === void 0 ? void 0 : _g.domInteractive),\n            error: {\n                count: view.eventCounts.errorCount,\n            },\n            first_contentful_paint: toServerDuration(view.initialViewMetrics.firstContentfulPaint),\n            first_input_delay: toServerDuration((_h = view.initialViewMetrics.firstInput) === null || _h === void 0 ? void 0 : _h.delay),\n            first_input_time: toServerDuration((_j = view.initialViewMetrics.firstInput) === null || _j === void 0 ? void 0 : _j.time),\n            first_input_target_selector: (_k = view.initialViewMetrics.firstInput) === null || _k === void 0 ? void 0 : _k.targetSelector,\n            interaction_to_next_paint: toServerDuration((_l = view.commonViewMetrics.interactionToNextPaint) === null || _l === void 0 ? void 0 : _l.value),\n            interaction_to_next_paint_time: toServerDuration((_m = view.commonViewMetrics.interactionToNextPaint) === null || _m === void 0 ? void 0 : _m.time),\n            interaction_to_next_paint_target_selector: (_o = view.commonViewMetrics.interactionToNextPaint) === null || _o === void 0 ? void 0 : _o.targetSelector,\n            is_active: view.isActive,\n            name: view.name,\n            largest_contentful_paint: toServerDuration((_p = view.initialViewMetrics.largestContentfulPaint) === null || _p === void 0 ? void 0 : _p.value),\n            largest_contentful_paint_target_selector: (_q = view.initialViewMetrics.largestContentfulPaint) === null || _q === void 0 ? void 0 : _q.targetSelector,\n            load_event: toServerDuration((_r = view.initialViewMetrics.navigationTimings) === null || _r === void 0 ? void 0 : _r.loadEvent),\n            loading_time: discardNegativeDuration(toServerDuration(view.commonViewMetrics.loadingTime)),\n            loading_type: view.loadingType,\n            long_task: {\n                count: view.eventCounts.longTaskCount,\n            },\n            performance: computeViewPerformanceData(view.commonViewMetrics, view.initialViewMetrics),\n            resource: {\n                count: view.eventCounts.resourceCount,\n            },\n            time_spent: toServerDuration(view.duration),\n        },\n        display: view.commonViewMetrics.scroll\n            ? {\n                scroll: {\n                    max_depth: view.commonViewMetrics.scroll.maxDepth,\n                    max_depth_scroll_top: view.commonViewMetrics.scroll.maxDepthScrollTop,\n                    max_scroll_height: view.commonViewMetrics.scroll.maxScrollHeight,\n                    max_scroll_height_time: toServerDuration(view.commonViewMetrics.scroll.maxScrollHeightTime),\n                },\n            }\n            : undefined,\n        session: {\n            has_replay: replayStats ? true : undefined,\n            is_active: view.sessionIsActive ? undefined : false,\n        },\n        privacy: {\n            replay_level: configuration.defaultPrivacyLevel,\n        },\n    };\n    if (!isEmptyObject(view.customTimings)) {\n        viewEvent.view.custom_timings = mapValues(view.customTimings, toServerDuration);\n    }\n    return {\n        rawRumEvent: viewEvent,\n        startTime: view.startClocks.relative,\n        domainContext: {\n            location: view.location,\n        },\n    };\n}\nfunction computeViewPerformanceData({ cumulativeLayoutShift, interactionToNextPaint }, { firstContentfulPaint, firstInput, largestContentfulPaint }) {\n    return {\n        cls: cumulativeLayoutShift && {\n            score: cumulativeLayoutShift.value,\n            timestamp: toServerDuration(cumulativeLayoutShift.time),\n            target_selector: cumulativeLayoutShift.targetSelector,\n            previous_rect: cumulativeLayoutShift.previousRect,\n            current_rect: cumulativeLayoutShift.currentRect,\n        },\n        fcp: firstContentfulPaint && { timestamp: toServerDuration(firstContentfulPaint) },\n        fid: firstInput && {\n            duration: toServerDuration(firstInput.delay),\n            timestamp: toServerDuration(firstInput.time),\n            target_selector: firstInput.targetSelector,\n        },\n        inp: interactionToNextPaint && {\n            duration: toServerDuration(interactionToNextPaint.value),\n            timestamp: toServerDuration(interactionToNextPaint.time),\n            target_selector: interactionToNextPaint.targetSelector,\n        },\n        lcp: largestContentfulPaint && {\n            timestamp: toServerDuration(largestContentfulPaint.value),\n            target_selector: largestContentfulPaint.targetSelector,\n            resource_url: largestContentfulPaint.resourceUrl,\n        },\n    };\n}\n//# sourceMappingURL=viewCollection.js.map","import { Observable, bridgeSupports, noop, performDraw, startSessionManager, } from '@datadog/browser-core';\nexport const RUM_SESSION_KEY = 'rum';\nexport function startRumSessionManager(configuration, lifeCycle, trackingConsentState) {\n    const sessionManager = startSessionManager(configuration, RUM_SESSION_KEY, (rawTrackingType) => computeSessionState(configuration, rawTrackingType), trackingConsentState);\n    sessionManager.expireObservable.subscribe(() => {\n        lifeCycle.notify(9 /* LifeCycleEventType.SESSION_EXPIRED */);\n    });\n    sessionManager.renewObservable.subscribe(() => {\n        lifeCycle.notify(10 /* LifeCycleEventType.SESSION_RENEWED */);\n    });\n    sessionManager.sessionStateUpdateObservable.subscribe(({ previousState, newState }) => {\n        if (!previousState.forcedReplay && newState.forcedReplay) {\n            const sessionEntity = sessionManager.findSession();\n            if (sessionEntity) {\n                sessionEntity.isReplayForced = true;\n            }\n        }\n    });\n    return {\n        findTrackedSession: (startTime) => {\n            const session = sessionManager.findSession(startTime);\n            if (!session || !isTypeTracked(session.trackingType)) {\n                return;\n            }\n            return {\n                id: session.id,\n                sessionReplay: session.trackingType === \"1\" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */\n                    ? 1 /* SessionReplayState.SAMPLED */\n                    : session.isReplayForced\n                        ? 2 /* SessionReplayState.FORCED */\n                        : 0 /* SessionReplayState.OFF */,\n                anonymousId: session.anonymousId,\n            };\n        },\n        expire: sessionManager.expire,\n        expireObservable: sessionManager.expireObservable,\n        setForcedReplay: () => sessionManager.updateSessionState({ forcedReplay: '1' }),\n    };\n}\n/**\n * Start a tracked replay session stub\n */\nexport function startRumSessionManagerStub() {\n    const session = {\n        id: '00000000-aaaa-0000-aaaa-000000000000',\n        sessionReplay: bridgeSupports(\"records\" /* BridgeCapability.RECORDS */) ? 1 /* SessionReplayState.SAMPLED */ : 0 /* SessionReplayState.OFF */,\n    };\n    return {\n        findTrackedSession: () => session,\n        expire: noop,\n        expireObservable: new Observable(),\n        setForcedReplay: noop,\n    };\n}\nfunction computeSessionState(configuration, rawTrackingType) {\n    let trackingType;\n    if (hasValidRumSession(rawTrackingType)) {\n        trackingType = rawTrackingType;\n    }\n    else if (!performDraw(configuration.sessionSampleRate)) {\n        trackingType = \"0\" /* RumTrackingType.NOT_TRACKED */;\n    }\n    else if (!performDraw(configuration.sessionReplaySampleRate)) {\n        trackingType = \"2\" /* RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY */;\n    }\n    else {\n        trackingType = \"1\" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */;\n    }\n    return {\n        trackingType,\n        isTracked: isTypeTracked(trackingType),\n    };\n}\nfunction hasValidRumSession(trackingType) {\n    return (trackingType === \"0\" /* RumTrackingType.NOT_TRACKED */ ||\n        trackingType === \"1\" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */ ||\n        trackingType === \"2\" /* RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY */);\n}\nfunction isTypeTracked(rumSessionType) {\n    return (rumSessionType === \"2\" /* RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY */ ||\n        rumSessionType === \"1\" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */);\n}\n//# sourceMappingURL=rumSessionManager.js.map","import { combine, isTelemetryReplicationAllowed, startBatchWithReplica, } from '@datadog/browser-core';\nexport function startRumBatch(configuration, lifeCycle, telemetryEventObservable, reportError, pageExitObservable, sessionExpireObservable, createEncoder) {\n    const replica = configuration.replica;\n    const batch = startBatchWithReplica(configuration, {\n        endpoint: configuration.rumEndpointBuilder,\n        encoder: createEncoder(2 /* DeflateEncoderStreamId.RUM */),\n    }, replica && {\n        endpoint: replica.rumEndpointBuilder,\n        transformMessage: (message) => combine(message, { application: { id: replica.applicationId } }),\n        encoder: createEncoder(3 /* DeflateEncoderStreamId.RUM_REPLICA */),\n    }, reportError, pageExitObservable, sessionExpireObservable);\n    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, (serverRumEvent) => {\n        if (serverRumEvent.type === \"view\" /* RumEventType.VIEW */) {\n            batch.upsert(serverRumEvent, serverRumEvent.view.id);\n        }\n        else {\n            batch.add(serverRumEvent);\n        }\n    });\n    telemetryEventObservable.subscribe((event) => batch.add(event, isTelemetryReplicationAllowed(configuration)));\n    return batch;\n}\n//# sourceMappingURL=startRumBatch.js.map","import { createBatch } from './batch';\nimport { createHttpRequest } from './httpRequest';\nimport { createFlushController } from './flushController';\nexport function startBatchWithReplica(configuration, primary, replica, reportError, pageExitObservable, sessionExpireObservable, batchFactoryImp = createBatch) {\n    const primaryBatch = createBatchFromConfig(configuration, primary);\n    const replicaBatch = replica && createBatchFromConfig(configuration, replica);\n    function createBatchFromConfig(configuration, { endpoint, encoder }) {\n        return batchFactoryImp({\n            encoder,\n            request: createHttpRequest(endpoint, configuration.batchBytesLimit, reportError),\n            flushController: createFlushController({\n                messagesLimit: configuration.batchMessagesLimit,\n                bytesLimit: configuration.batchBytesLimit,\n                durationLimit: configuration.flushTimeout,\n                pageExitObservable,\n                sessionExpireObservable,\n            }),\n            messageBytesLimit: configuration.messageBytesLimit,\n        });\n    }\n    return {\n        flushObservable: primaryBatch.flushController.flushObservable,\n        add(message, replicated = true) {\n            primaryBatch.add(message);\n            if (replicaBatch && replicated) {\n                replicaBatch.add(replica.transformMessage ? replica.transformMessage(message) : message);\n            }\n        },\n        upsert: (message, key) => {\n            primaryBatch.upsert(message, key);\n            if (replicaBatch) {\n                replicaBatch.upsert(replica.transformMessage ? replica.transformMessage(message) : message, key);\n            }\n        },\n        stop: () => {\n            primaryBatch.stop();\n            if (replicaBatch) {\n                replicaBatch.stop();\n            }\n        },\n    };\n}\n//# sourceMappingURL=startBatchWithReplica.js.map","import { SESSION_TIME_OUT_DELAY, relativeNow, createValueHistory } from '@datadog/browser-core';\n/**\n * We want to attach to an event:\n * - the url corresponding to its start\n * - the referrer corresponding to the previous view url (or document referrer for initial view)\n */\nexport const URL_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;\nexport function startUrlContexts(lifeCycle, hooks, locationChangeObservable, location) {\n    const urlContextHistory = createValueHistory({ expireDelay: URL_CONTEXT_TIME_OUT_DELAY });\n    let previousViewUrl;\n    lifeCycle.subscribe(1 /* LifeCycleEventType.BEFORE_VIEW_CREATED */, ({ startClocks }) => {\n        const viewUrl = location.href;\n        urlContextHistory.add(buildUrlContext({\n            url: viewUrl,\n            referrer: !previousViewUrl ? document.referrer : previousViewUrl,\n        }), startClocks.relative);\n        previousViewUrl = viewUrl;\n    });\n    lifeCycle.subscribe(6 /* LifeCycleEventType.AFTER_VIEW_ENDED */, ({ endClocks }) => {\n        urlContextHistory.closeActive(endClocks.relative);\n    });\n    const locationChangeSubscription = locationChangeObservable.subscribe(({ newLocation }) => {\n        const current = urlContextHistory.find();\n        if (current) {\n            const changeTime = relativeNow();\n            urlContextHistory.closeActive(changeTime);\n            urlContextHistory.add(buildUrlContext({\n                url: newLocation.href,\n                referrer: current.referrer,\n            }), changeTime);\n        }\n    });\n    function buildUrlContext({ url, referrer }) {\n        return {\n            url,\n            referrer,\n        };\n    }\n    hooks.register(0 /* HookNames.Assemble */, ({ startTime, eventType }) => {\n        const { url, referrer } = urlContextHistory.find(startTime);\n        return {\n            type: eventType,\n            view: {\n                url,\n                referrer,\n            },\n        };\n    });\n    return {\n        findUrl: (startTime) => urlContextHistory.find(startTime),\n        getAllEntries: () => urlContextHistory.getAllEntries(),\n        getDeletedEntries: () => urlContextHistory.getDeletedEntries(),\n        stop: () => {\n            locationChangeSubscription.unsubscribe();\n            urlContextHistory.stop();\n        },\n    };\n}\n//# sourceMappingURL=urlContexts.js.map","import { addEventListener, instrumentMethod, Observable, shallowClone } from '@datadog/browser-core';\nexport function createLocationChangeObservable(configuration, location) {\n    let currentLocation = shallowClone(location);\n    return new Observable((observable) => {\n        const { stop: stopHistoryTracking } = trackHistory(configuration, onLocationChange);\n        const { stop: stopHashTracking } = trackHash(configuration, onLocationChange);\n        function onLocationChange() {\n            if (currentLocation.href === location.href) {\n                return;\n            }\n            const newLocation = shallowClone(location);\n            observable.notify({\n                newLocation,\n                oldLocation: currentLocation,\n            });\n            currentLocation = newLocation;\n        }\n        return () => {\n            stopHistoryTracking();\n            stopHashTracking();\n        };\n    });\n}\nfunction trackHistory(configuration, onHistoryChange) {\n    const { stop: stopInstrumentingPushState } = instrumentMethod(getHistoryInstrumentationTarget('pushState'), 'pushState', ({ onPostCall }) => {\n        onPostCall(onHistoryChange);\n    });\n    const { stop: stopInstrumentingReplaceState } = instrumentMethod(getHistoryInstrumentationTarget('replaceState'), 'replaceState', ({ onPostCall }) => {\n        onPostCall(onHistoryChange);\n    });\n    const { stop: removeListener } = addEventListener(configuration, window, \"popstate\" /* DOM_EVENT.POP_STATE */, onHistoryChange);\n    return {\n        stop: () => {\n            stopInstrumentingPushState();\n            stopInstrumentingReplaceState();\n            removeListener();\n        },\n    };\n}\nfunction trackHash(configuration, onHashChange) {\n    return addEventListener(configuration, window, \"hashchange\" /* DOM_EVENT.HASH_CHANGE */, onHashChange);\n}\nfunction getHistoryInstrumentationTarget(methodName) {\n    // Ideally we should always instument the method on the prototype, however some frameworks (e.g [Next.js](https://github.com/vercel/next.js/blob/d3f5532065f3e3bb84fb54bd2dfd1a16d0f03a21/packages/next/src/client/components/app-router.tsx#L429))\n    // are wrapping the instance method. In that case we should also wrap the instance method.\n    return Object.prototype.hasOwnProperty.call(history, methodName) ? history : History.prototype;\n}\n//# sourceMappingURL=locationChangeObservable.js.map","import { SESSION_TIME_OUT_DELAY, createValueHistory, isEmptyObject } from '@datadog/browser-core';\nexport const FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200;\n/**\n * Start feature flag contexts\n *\n * Feature flag contexts follow the life of views.\n * A new context is added when a view is created and ended when the view is ended\n *\n * Note: we choose not to add a new context at each evaluation to save memory\n */\nexport function startFeatureFlagContexts(lifeCycle, hooks, configuration, customerDataTracker) {\n    const featureFlagContexts = createValueHistory({\n        expireDelay: FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY,\n    });\n    lifeCycle.subscribe(1 /* LifeCycleEventType.BEFORE_VIEW_CREATED */, ({ startClocks }) => {\n        featureFlagContexts.add({}, startClocks.relative);\n        customerDataTracker.resetCustomerData();\n    });\n    lifeCycle.subscribe(6 /* LifeCycleEventType.AFTER_VIEW_ENDED */, ({ endClocks }) => {\n        featureFlagContexts.closeActive(endClocks.relative);\n    });\n    hooks.register(0 /* HookNames.Assemble */, ({ startTime, eventType }) => {\n        const trackFeatureFlagsForEvents = configuration.trackFeatureFlagsForEvents.concat([\n            \"view\" /* RumEventType.VIEW */,\n            \"error\" /* RumEventType.ERROR */,\n        ]);\n        if (!trackFeatureFlagsForEvents.includes(eventType)) {\n            return;\n        }\n        const featureFlagContext = featureFlagContexts.find(startTime);\n        if (!featureFlagContext || isEmptyObject(featureFlagContext)) {\n            return;\n        }\n        return {\n            type: eventType,\n            feature_flags: featureFlagContext,\n        };\n    });\n    return {\n        addFeatureFlagEvaluation: (key, value) => {\n            const currentContext = featureFlagContexts.find();\n            if (currentContext) {\n                currentContext[key] = value;\n                customerDataTracker.updateCustomerData(currentContext);\n            }\n        },\n        stop: () => customerDataTracker.stop(),\n    };\n}\n//# sourceMappingURL=featureFlagContext.js.map","import { performDraw, ONE_SECOND, addTelemetryDebug, setInterval } from '@datadog/browser-core';\nexport const MEASURES_PERIOD_DURATION = 10 * ONE_SECOND;\nlet currentPeriodMeasures;\nlet currentBatchMeasures;\nlet batchHasRumEvent;\nexport function startCustomerDataTelemetry(configuration, telemetry, lifeCycle, customerDataTrackerManager, batchFlushObservable) {\n    const customerDataTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate);\n    if (!customerDataTelemetryEnabled) {\n        return;\n    }\n    initCurrentPeriodMeasures();\n    initCurrentBatchMeasures();\n    // We measure the data of every view updates even if there could only be one per batch due to the upsert\n    // It means that contexts bytes count sums can be higher than it really is\n    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, (event) => {\n        batchHasRumEvent = true;\n        updateMeasure(currentBatchMeasures.globalContextBytes, customerDataTrackerManager.getOrCreateTracker(2 /* CustomerDataType.GlobalContext */).getBytesCount());\n        updateMeasure(currentBatchMeasures.userContextBytes, customerDataTrackerManager.getOrCreateTracker(1 /* CustomerDataType.User */).getBytesCount());\n        updateMeasure(currentBatchMeasures.featureFlagBytes, [\"view\" /* RumEventType.VIEW */, \"error\" /* RumEventType.ERROR */].includes(event.type)\n            ? customerDataTrackerManager.getOrCreateTracker(0 /* CustomerDataType.FeatureFlag */).getBytesCount()\n            : 0);\n    });\n    batchFlushObservable.subscribe(({ bytesCount, messagesCount }) => {\n        // Don't measure batch that only contains telemetry events to avoid batch sending loop\n        // It could happen because after each batch we are adding a customer data measures telemetry event to the next one\n        if (!batchHasRumEvent) {\n            return;\n        }\n        currentPeriodMeasures.batchCount += 1;\n        updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount);\n        updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount);\n        mergeMeasure(currentPeriodMeasures.globalContextBytes, currentBatchMeasures.globalContextBytes);\n        mergeMeasure(currentPeriodMeasures.userContextBytes, currentBatchMeasures.userContextBytes);\n        mergeMeasure(currentPeriodMeasures.featureFlagBytes, currentBatchMeasures.featureFlagBytes);\n        initCurrentBatchMeasures();\n    });\n    setInterval(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION);\n}\nfunction sendCurrentPeriodMeasures() {\n    if (currentPeriodMeasures.batchCount === 0) {\n        return;\n    }\n    addTelemetryDebug('Customer data measures', currentPeriodMeasures);\n    initCurrentPeriodMeasures();\n}\nfunction createMeasure() {\n    return { min: Infinity, max: 0, sum: 0 };\n}\nfunction updateMeasure(measure, value) {\n    measure.sum += value;\n    measure.min = Math.min(measure.min, value);\n    measure.max = Math.max(measure.max, value);\n}\nfunction mergeMeasure(target, source) {\n    target.sum += source.sum;\n    target.min = Math.min(target.min, source.min);\n    target.max = Math.max(target.max, source.max);\n}\nfunction initCurrentPeriodMeasures() {\n    currentPeriodMeasures = {\n        batchCount: 0,\n        batchBytesCount: createMeasure(),\n        batchMessagesCount: createMeasure(),\n        globalContextBytes: createMeasure(),\n        userContextBytes: createMeasure(),\n        featureFlagBytes: createMeasure(),\n    };\n}\nfunction initCurrentBatchMeasures() {\n    batchHasRumEvent = false;\n    currentBatchMeasures = {\n        globalContextBytes: createMeasure(),\n        userContextBytes: createMeasure(),\n        featureFlagBytes: createMeasure(),\n    };\n}\n//# sourceMappingURL=startCustomerDataTelemetry.js.map","import { elapsed, createValueHistory, SESSION_TIME_OUT_DELAY, toServerDuration, addEventListeners, relativeNow, } from '@datadog/browser-core';\n// Arbitrary value to cap number of element for memory consumption in the browser\nexport const MAX_PAGE_STATE_ENTRIES = 4000;\n// Arbitrary value to cap number of element for backend & to save bandwidth\nexport const MAX_PAGE_STATE_ENTRIES_SELECTABLE = 500;\nexport const PAGE_STATE_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY;\nexport function startPageStateHistory(configuration, maxPageStateEntriesSelectable = MAX_PAGE_STATE_ENTRIES_SELECTABLE) {\n    const pageStateEntryHistory = createValueHistory({\n        expireDelay: PAGE_STATE_CONTEXT_TIME_OUT_DELAY,\n        maxEntries: MAX_PAGE_STATE_ENTRIES,\n    });\n    let currentPageState;\n    addPageState(getPageState(), relativeNow());\n    const { stop: stopEventListeners } = addEventListeners(configuration, window, [\n        \"pageshow\" /* DOM_EVENT.PAGE_SHOW */,\n        \"focus\" /* DOM_EVENT.FOCUS */,\n        \"blur\" /* DOM_EVENT.BLUR */,\n        \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */,\n        \"resume\" /* DOM_EVENT.RESUME */,\n        \"freeze\" /* DOM_EVENT.FREEZE */,\n        \"pagehide\" /* DOM_EVENT.PAGE_HIDE */,\n    ], (event) => {\n        addPageState(computePageState(event), event.timeStamp);\n    }, { capture: true });\n    function addPageState(nextPageState, startTime = relativeNow()) {\n        if (nextPageState === currentPageState) {\n            return;\n        }\n        currentPageState = nextPageState;\n        pageStateEntryHistory.closeActive(startTime);\n        pageStateEntryHistory.add({ state: currentPageState, startTime }, startTime);\n    }\n    const pageStateHistory = {\n        findAll: (eventStartTime, duration) => {\n            const pageStateEntries = pageStateEntryHistory.findAll(eventStartTime, duration);\n            if (pageStateEntries.length === 0) {\n                return;\n            }\n            const pageStateServerEntries = [];\n            // limit the number of entries to return\n            const limit = Math.max(0, pageStateEntries.length - maxPageStateEntriesSelectable);\n            // loop page state entries backward to return the selected ones in desc order\n            for (let index = pageStateEntries.length - 1; index >= limit; index--) {\n                const pageState = pageStateEntries[index];\n                // compute the start time relative to the event start time (ex: to be relative to the view start time)\n                const relativeStartTime = elapsed(eventStartTime, pageState.startTime);\n                pageStateServerEntries.push({\n                    state: pageState.state,\n                    start: toServerDuration(relativeStartTime),\n                });\n            }\n            return pageStateServerEntries;\n        },\n        wasInPageStateAt: (state, startTime) => pageStateHistory.wasInPageStateDuringPeriod(state, startTime, 0),\n        wasInPageStateDuringPeriod: (state, startTime, duration) => pageStateEntryHistory.findAll(startTime, duration).some((pageState) => pageState.state === state),\n        addPageState,\n        stop: () => {\n            stopEventListeners();\n            pageStateEntryHistory.stop();\n        },\n    };\n    return pageStateHistory;\n}\nfunction computePageState(event) {\n    if (event.type === \"freeze\" /* DOM_EVENT.FREEZE */) {\n        return \"frozen\" /* PageState.FROZEN */;\n    }\n    else if (event.type === \"pagehide\" /* DOM_EVENT.PAGE_HIDE */) {\n        return event.persisted ? \"frozen\" /* PageState.FROZEN */ : \"terminated\" /* PageState.TERMINATED */;\n    }\n    return getPageState();\n}\nfunction getPageState() {\n    if (document.visibilityState === 'hidden') {\n        return \"hidden\" /* PageState.HIDDEN */;\n    }\n    if (document.hasFocus()) {\n        return \"active\" /* PageState.ACTIVE */;\n    }\n    return \"passive\" /* PageState.PASSIVE */;\n}\n//# sourceMappingURL=pageStateHistory.js.map","import { setInterval, clearInterval, Observable, addEventListener, ONE_SECOND, findCommaSeparatedValue, } from '@datadog/browser-core';\nexport function createCookieObservable(configuration, cookieName) {\n    const detectCookieChangeStrategy = window.cookieStore\n        ? listenToCookieStoreChange(configuration)\n        : watchCookieFallback;\n    return new Observable((observable) => detectCookieChangeStrategy(cookieName, (event) => observable.notify(event)));\n}\nfunction listenToCookieStoreChange(configuration) {\n    return (cookieName, callback) => {\n        const listener = addEventListener(configuration, window.cookieStore, \"change\" /* DOM_EVENT.CHANGE */, (event) => {\n            // Based on our experimentation, we're assuming that entries for the same cookie cannot be in both the 'changed' and 'deleted' arrays.\n            // However, due to ambiguity in the specification, we asked for clarification: https://github.com/WICG/cookie-store/issues/226\n            const changeEvent = event.changed.find((event) => event.name === cookieName) ||\n                event.deleted.find((event) => event.name === cookieName);\n            if (changeEvent) {\n                callback(changeEvent.value);\n            }\n        });\n        return listener.stop;\n    };\n}\nexport const WATCH_COOKIE_INTERVAL_DELAY = ONE_SECOND;\nfunction watchCookieFallback(cookieName, callback) {\n    const previousCookieValue = findCommaSeparatedValue(document.cookie, cookieName);\n    const watchCookieIntervalId = setInterval(() => {\n        const cookieValue = findCommaSeparatedValue(document.cookie, cookieName);\n        if (cookieValue !== previousCookieValue) {\n            callback(cookieValue);\n        }\n    }, WATCH_COOKIE_INTERVAL_DELAY);\n    return () => {\n        clearInterval(watchCookieIntervalId);\n    };\n}\n//# sourceMappingURL=cookieObservable.js.map","import { getInitCookie } from '@datadog/browser-core';\nimport { createCookieObservable } from '../../browser/cookieObservable';\nexport const CI_VISIBILITY_TEST_ID_COOKIE_NAME = 'datadog-ci-visibility-test-execution-id';\nexport function startCiVisibilityContext(configuration, hooks, cookieObservable = createCookieObservable(configuration, CI_VISIBILITY_TEST_ID_COOKIE_NAME)) {\n    var _a;\n    let testExecutionId = getInitCookie(CI_VISIBILITY_TEST_ID_COOKIE_NAME) || ((_a = window.Cypress) === null || _a === void 0 ? void 0 : _a.env('traceId'));\n    const cookieObservableSubscription = cookieObservable.subscribe((value) => {\n        testExecutionId = value;\n    });\n    hooks.register(0 /* HookNames.Assemble */, ({ eventType }) => {\n        if (typeof testExecutionId !== 'string') {\n            return;\n        }\n        return {\n            type: eventType,\n            session: {\n                type: \"ci_test\" /* SessionType.CI_TEST */,\n            },\n            ci_test: {\n                test_execution_id: testExecutionId,\n            },\n        };\n    });\n    return {\n        stop: () => {\n            cookieObservableSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=ciVisibilityContext.js.map","import { getSyntheticsResultId, getSyntheticsTestId, willSyntheticsInjectRum } from '@datadog/browser-core';\nexport function startSyntheticsContext(hooks) {\n    hooks.register(0 /* HookNames.Assemble */, ({ eventType }) => {\n        const testId = getSyntheticsTestId();\n        const resultId = getSyntheticsResultId();\n        if (!testId || !resultId) {\n            return;\n        }\n        return {\n            type: eventType,\n            session: {\n                type: \"synthetics\" /* SessionType.SYNTHETICS */,\n            },\n            synthetics: {\n                test_id: testId,\n                result_id: resultId,\n                injected: willSyntheticsInjectRum(),\n            },\n        };\n    });\n}\n//# sourceMappingURL=syntheticsContext.js.map","import { INTAKE_SITE_STAGING, INTAKE_SITE_US1, INTAKE_SITE_EU1 } from '@datadog/browser-core';\nexport function getSessionReplayUrl(configuration, { session, viewContext, errorType, }) {\n    const sessionId = session ? session.id : 'no-session-id';\n    const parameters = [];\n    if (errorType !== undefined) {\n        parameters.push(`error-type=${errorType}`);\n    }\n    if (viewContext) {\n        parameters.push(`seed=${viewContext.id}`);\n        parameters.push(`from=${viewContext.startClocks.timeStamp}`);\n    }\n    const origin = getDatadogSiteUrl(configuration);\n    const path = `/rum/replay/sessions/${sessionId}`;\n    return `${origin}${path}?${parameters.join('&')}`;\n}\nexport function getDatadogSiteUrl(rumConfiguration) {\n    const site = rumConfiguration.site;\n    const subdomain = rumConfiguration.subdomain || getSiteDefaultSubdomain(rumConfiguration);\n    return `https://${subdomain ? `${subdomain}.` : ''}${site}`;\n}\nfunction getSiteDefaultSubdomain(configuration) {\n    switch (configuration.site) {\n        case INTAKE_SITE_US1:\n        case INTAKE_SITE_EU1:\n            return 'app';\n        case INTAKE_SITE_STAGING:\n            return 'dd';\n        default:\n            return undefined;\n    }\n}\n//# sourceMappingURL=getSessionReplayUrl.js.map","export const MAX_STATS_HISTORY = 1000;\nlet statsPerView;\nexport function getSegmentsCount(viewId) {\n    return getOrCreateReplayStats(viewId).segments_count;\n}\nexport function addSegment(viewId) {\n    getOrCreateReplayStats(viewId).segments_count += 1;\n}\nexport function addRecord(viewId) {\n    getOrCreateReplayStats(viewId).records_count += 1;\n}\nexport function addWroteData(viewId, additionalBytesCount) {\n    getOrCreateReplayStats(viewId).segments_total_raw_size += additionalBytesCount;\n}\nexport function getReplayStats(viewId) {\n    return statsPerView === null || statsPerView === void 0 ? void 0 : statsPerView.get(viewId);\n}\nexport function resetReplayStats() {\n    statsPerView = undefined;\n}\nfunction getOrCreateReplayStats(viewId) {\n    if (!statsPerView) {\n        statsPerView = new Map();\n    }\n    let replayStats;\n    if (statsPerView.has(viewId)) {\n        replayStats = statsPerView.get(viewId);\n    }\n    else {\n        replayStats = {\n            records_count: 0,\n            segments_count: 0,\n            segments_total_raw_size: 0,\n        };\n        statsPerView.set(viewId, replayStats);\n        if (statsPerView.size > MAX_STATS_HISTORY) {\n            deleteOldestStats();\n        }\n    }\n    return replayStats;\n}\nfunction deleteOldestStats() {\n    if (!statsPerView) {\n        return;\n    }\n    const toDelete = statsPerView.keys().next().value;\n    if (toDelete) {\n        statsPerView.delete(toDelete);\n    }\n}\n//# sourceMappingURL=replayStats.js.map","import { addEventListener, addTelemetryDebug, concatBuffers } from '@datadog/browser-core';\nexport function createDeflateEncoder(configuration, worker, streamId) {\n    let rawBytesCount = 0;\n    let compressedData = [];\n    let compressedDataTrailer;\n    let nextWriteActionId = 0;\n    const pendingWriteActions = [];\n    const { stop: removeMessageListener } = addEventListener(configuration, worker, 'message', ({ data: workerResponse }) => {\n        if (workerResponse.type !== 'wrote' || workerResponse.streamId !== streamId) {\n            return;\n        }\n        rawBytesCount += workerResponse.additionalBytesCount;\n        compressedData.push(workerResponse.result);\n        compressedDataTrailer = workerResponse.trailer;\n        const nextPendingAction = pendingWriteActions.shift();\n        if (nextPendingAction && nextPendingAction.id === workerResponse.id) {\n            if (nextPendingAction.writeCallback) {\n                nextPendingAction.writeCallback(workerResponse.result.byteLength);\n            }\n            else if (nextPendingAction.finishCallback) {\n                nextPendingAction.finishCallback();\n            }\n        }\n        else {\n            removeMessageListener();\n            addTelemetryDebug('Worker responses received out of order.');\n        }\n    });\n    function consumeResult() {\n        const output = compressedData.length === 0 ? new Uint8Array(0) : concatBuffers(compressedData.concat(compressedDataTrailer));\n        const result = {\n            rawBytesCount,\n            output,\n            outputBytesCount: output.byteLength,\n            encoding: 'deflate',\n        };\n        rawBytesCount = 0;\n        compressedData = [];\n        return result;\n    }\n    function sendResetIfNeeded() {\n        if (nextWriteActionId > 0) {\n            worker.postMessage({\n                action: 'reset',\n                streamId,\n            });\n            nextWriteActionId = 0;\n        }\n    }\n    return {\n        isAsync: true,\n        get isEmpty() {\n            return nextWriteActionId === 0;\n        },\n        write(data, callback) {\n            worker.postMessage({\n                action: 'write',\n                id: nextWriteActionId,\n                data,\n                streamId,\n            });\n            pendingWriteActions.push({\n                id: nextWriteActionId,\n                writeCallback: callback,\n                data,\n            });\n            nextWriteActionId += 1;\n        },\n        finish(callback) {\n            sendResetIfNeeded();\n            if (!pendingWriteActions.length) {\n                callback(consumeResult());\n            }\n            else {\n                // Make sure we do not call any write callback\n                pendingWriteActions.forEach((pendingWriteAction) => {\n                    delete pendingWriteAction.writeCallback;\n                });\n                // Wait for the last action to finish before calling the finish callback\n                pendingWriteActions[pendingWriteActions.length - 1].finishCallback = () => callback(consumeResult());\n            }\n        },\n        finishSync() {\n            sendResetIfNeeded();\n            const pendingData = pendingWriteActions\n                .map((pendingWriteAction) => {\n                // Make sure we do not call any write or finish callback\n                delete pendingWriteAction.writeCallback;\n                delete pendingWriteAction.finishCallback;\n                return pendingWriteAction.data;\n            })\n                .join('');\n            return { ...consumeResult(), pendingData };\n        },\n        estimateEncodedBytesCount(data) {\n            // This is a rough estimation of the data size once it'll be encoded by deflate. We observed\n            // that if it's the first chunk of data pushed to the stream, the ratio is lower (3-4), but\n            // after that the ratio is greater (10+). We chose 8 here, which (on average) seems to produce\n            // requests of the expected size.\n            return data.length / 8;\n        },\n        stop() {\n            removeMessageListener();\n        },\n    };\n}\n//# sourceMappingURL=deflateEncoder.js.map","import { addTelemetryError, display, addEventListener, setTimeout, ONE_SECOND, DOCS_ORIGIN, } from '@datadog/browser-core';\nexport const INITIALIZATION_TIME_OUT_DELAY = 30 * ONE_SECOND;\nfunction createDeflateWorker(configuration) {\n    return new Worker(configuration.workerUrl || URL.createObjectURL(new Blob([\"(()=>{\\\"use strict\\\";function t(t){const e=t.reduce(((t,e)=>t+e.length),0),a=new Uint8Array(e);let n=0;for(const e of t)a.set(e,n),n+=e.length;return a}function e(t){for(var e=t.length;--e>=0;)t[e]=0}var a=256,n=286,r=30,i=15,s=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),h=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),l=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),_=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=new Array(576);e(o);var d=new Array(60);e(d);var u=new Array(512);e(u);var f=new Array(256);e(f);var c=new Array(29);e(c);var p,g,w,v=new Array(r);function b(t,e,a,n,r){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=n,this.max_length=r,this.has_stree=t&&t.length}function m(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}e(v);var y=function(t){return t<256?u[t]:u[256+(t>>>7)]},k=function(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},z=function(t,e,a){t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535,k(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)},x=function(t,e,a){z(t,a[2*e],a[2*e+1])},A=function(t,e){var a=0;do{a|=1&t,t>>>=1,a<<=1}while(--e>0);return a>>>1},U=function(t,e,a){var n,r,s=new Array(16),h=0;for(n=1;n<=i;n++)s[n]=h=h+a[n-1]<<1;for(r=0;r<=e;r++){var l=t[2*r+1];0!==l&&(t[2*r]=A(s[l]++,l))}},I=function(t){var e;for(e=0;e<n;e++)t.dyn_ltree[2*e]=0;for(e=0;e<r;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0},B=function(t){t.bi_valid>8?k(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},E=function(t,e,a,n){var r=2*e,i=2*a;return t[r]<t[i]||t[r]===t[i]&&n[e]<=n[a]},S=function(t,e,a){for(var n=t.heap[a],r=a<<1;r<=t.heap_len&&(r<t.heap_len&&E(e,t.heap[r+1],t.heap[r],t.depth)&&r++,!E(e,n,t.heap[r],t.depth));)t.heap[a]=t.heap[r],a=r,r<<=1;t.heap[a]=n},C=function(t,e,n){var r,i,l,_,o=0;if(0!==t.last_lit)do{r=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],i=t.pending_buf[t.l_buf+o],o++,0===r?x(t,i,e):(l=f[i],x(t,l+a+1,e),0!==(_=s[l])&&(i-=c[l],z(t,i,_)),r--,l=y(r),x(t,l,n),0!==(_=h[l])&&(r-=v[l],z(t,r,_)))}while(o<t.last_lit);x(t,256,e)},D=function(t,e){var a,n,r,s=e.dyn_tree,h=e.stat_desc.static_tree,l=e.stat_desc.has_stree,_=e.stat_desc.elems,o=-1;for(t.heap_len=0,t.heap_max=573,a=0;a<_;a++)0!==s[2*a]?(t.heap[++t.heap_len]=o=a,t.depth[a]=0):s[2*a+1]=0;for(;t.heap_len<2;)s[2*(r=t.heap[++t.heap_len]=o<2?++o:0)]=1,t.depth[r]=0,t.opt_len--,l&&(t.static_len-=h[2*r+1]);for(e.max_code=o,a=t.heap_len>>1;a>=1;a--)S(t,s,a);r=_;do{a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],S(t,s,1),n=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=n,s[2*r]=s[2*a]+s[2*n],t.depth[r]=(t.depth[a]>=t.depth[n]?t.depth[a]:t.depth[n])+1,s[2*a+1]=s[2*n+1]=r,t.heap[1]=r++,S(t,s,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(t,e){var a,n,r,s,h,l,_=e.dyn_tree,o=e.max_code,d=e.stat_desc.static_tree,u=e.stat_desc.has_stree,f=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,g=0;for(s=0;s<=i;s++)t.bl_count[s]=0;for(_[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<573;a++)(s=_[2*_[2*(n=t.heap[a])+1]+1]+1)>p&&(s=p,g++),_[2*n+1]=s,n>o||(t.bl_count[s]++,h=0,n>=c&&(h=f[n-c]),l=_[2*n],t.opt_len+=l*(s+h),u&&(t.static_len+=l*(d[2*n+1]+h)));if(0!==g){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,g-=2}while(g>0);for(s=p;0!==s;s--)for(n=t.bl_count[s];0!==n;)(r=t.heap[--a])>o||(_[2*r+1]!==s&&(t.opt_len+=(s-_[2*r+1])*_[2*r],_[2*r+1]=s),n--)}}(t,e),U(s,o,t.bl_count)},j=function(t,e,a){var n,r,i=-1,s=e[1],h=0,l=7,_=4;for(0===s&&(l=138,_=3),e[2*(a+1)+1]=65535,n=0;n<=a;n++)r=s,s=e[2*(n+1)+1],++h<l&&r===s||(h<_?t.bl_tree[2*r]+=h:0!==r?(r!==i&&t.bl_tree[2*r]++,t.bl_tree[32]++):h<=10?t.bl_tree[34]++:t.bl_tree[36]++,h=0,i=r,0===s?(l=138,_=3):r===s?(l=6,_=3):(l=7,_=4))},M=function(t,e,a){var n,r,i=-1,s=e[1],h=0,l=7,_=4;for(0===s&&(l=138,_=3),n=0;n<=a;n++)if(r=s,s=e[2*(n+1)+1],!(++h<l&&r===s)){if(h<_)do{x(t,r,t.bl_tree)}while(0!=--h);else 0!==r?(r!==i&&(x(t,r,t.bl_tree),h--),x(t,16,t.bl_tree),z(t,h-3,2)):h<=10?(x(t,17,t.bl_tree),z(t,h-3,3)):(x(t,18,t.bl_tree),z(t,h-11,7));h=0,i=r,0===s?(l=138,_=3):r===s?(l=6,_=3):(l=7,_=4)}},L=!1,T=function(t,e,a,n){z(t,0+(n?1:0),3),function(t,e,a,n){B(t),n&&(k(t,a),k(t,~a)),t.pending_buf.set(t.window.subarray(e,e+a),t.pending),t.pending+=a}(t,e,a,!0)},H=function(t,e,n,r){var i,s,h=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,n=4093624447;for(e=0;e<=31;e++,n>>>=1)if(1&n&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<a;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0}(t)),D(t,t.l_desc),D(t,t.d_desc),h=function(t){var e;for(j(t,t.dyn_ltree,t.l_desc.max_code),j(t,t.dyn_dtree,t.d_desc.max_code),D(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*_[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),i=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=i&&(i=s)):i=s=n+5,n+4<=i&&-1!==e?T(t,e,n,r):4===t.strategy||s===i?(z(t,2+(r?1:0),3),C(t,o,d)):(z(t,4+(r?1:0),3),function(t,e,a,n){var r;for(z(t,e-257,5),z(t,a-1,5),z(t,n-4,4),r=0;r<n;r++)z(t,t.bl_tree[2*_[r]+1],3);M(t,t.dyn_ltree,e-1),M(t,t.dyn_dtree,a-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,h+1),C(t,t.dyn_ltree,t.dyn_dtree)),I(t),r&&B(t)},R={_tr_init:function(t){L||(!function(){var t,e,a,_,m,y=new Array(16);for(a=0,_=0;_<28;_++)for(c[_]=a,t=0;t<1<<s[_];t++)f[a++]=_;for(f[a-1]=_,m=0,_=0;_<16;_++)for(v[_]=m,t=0;t<1<<h[_];t++)u[m++]=_;for(m>>=7;_<r;_++)for(v[_]=m<<7,t=0;t<1<<h[_]-7;t++)u[256+m++]=_;for(e=0;e<=i;e++)y[e]=0;for(t=0;t<=143;)o[2*t+1]=8,t++,y[8]++;for(;t<=255;)o[2*t+1]=9,t++,y[9]++;for(;t<=279;)o[2*t+1]=7,t++,y[7]++;for(;t<=287;)o[2*t+1]=8,t++,y[8]++;for(U(o,287,y),t=0;t<r;t++)d[2*t+1]=5,d[2*t]=A(t,5);p=new b(o,s,257,n,i),g=new b(d,h,0,r,i),w=new b(new Array(0),l,0,19,7)}(),L=!0),t.l_desc=new m(t.dyn_ltree,p),t.d_desc=new m(t.dyn_dtree,g),t.bl_desc=new m(t.bl_tree,w),t.bi_buf=0,t.bi_valid=0,I(t)},_tr_stored_block:T,_tr_flush_block:H,_tr_tally:function(t,e,n){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&n,t.last_lit++,0===e?t.dyn_ltree[2*n]++:(t.matches++,e--,t.dyn_ltree[2*(f[n]+a+1)]++,t.dyn_dtree[2*y(e)]++),t.last_lit===t.lit_bufsize-1},_tr_align:function(t){z(t,2,3),x(t,256,o),function(t){16===t.bi_valid?(k(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},K=function(t,e,a,n){for(var r=65535&t,i=t>>>16&65535,s=0;0!==a;){a-=s=a>2e3?2e3:a;do{i=i+(r=r+e[n++]|0)|0}while(--s);r%=65521,i%=65521}return r|i<<16},N=new Uint32Array(function(){for(var t,e=[],a=0;a<256;a++){t=a;for(var n=0;n<8;n++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}()),O=function(t,e,a,n){var r=N,i=n+a;t^=-1;for(var s=n;s<i;s++)t=t>>>8^r[255&(t^e[s])];return~t},q={2:\\\"need dictionary\\\",1:\\\"stream end\\\",0:\\\"\\\",\\\"-1\\\":\\\"file error\\\",\\\"-2\\\":\\\"stream error\\\",\\\"-3\\\":\\\"data error\\\",\\\"-4\\\":\\\"insufficient memory\\\",\\\"-5\\\":\\\"buffer error\\\",\\\"-6\\\":\\\"incompatible version\\\"},F=0,G=2,J=3,P=4,Q=0,V=1,W=-1,X=0,Y=8,Z=R._tr_init,$=R._tr_stored_block,tt=R._tr_flush_block,et=R._tr_tally,at=R._tr_align,nt=F,rt=1,it=J,st=P,ht=5,lt=Q,_t=V,ot=-2,dt=-3,ut=-5,ft=W,ct=1,pt=2,gt=3,wt=4,vt=X,bt=2,mt=Y,yt=258,kt=262,zt=103,xt=113,At=666,Ut=function(t,e){return t.msg=q[e],e},It=function(t){return(t<<1)-(t>4?9:0)},Bt=function(t){for(var e=t.length;--e>=0;)t[e]=0},Et=function(t,e,a){return(e<<t.hash_shift^a)&t.hash_mask},St=function(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+a),t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))},Ct=function(t,e){tt(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,St(t.strm)},Dt=function(t,e){t.pending_buf[t.pending++]=e},jt=function(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},Mt=function(t,e){var a,n,r=t.max_chain_length,i=t.strstart,s=t.prev_length,h=t.nice_match,l=t.strstart>t.w_size-kt?t.strstart-(t.w_size-kt):0,_=t.window,o=t.w_mask,d=t.prev,u=t.strstart+yt,f=_[i+s-1],c=_[i+s];t.prev_length>=t.good_match&&(r>>=2),h>t.lookahead&&(h=t.lookahead);do{if(_[(a=e)+s]===c&&_[a+s-1]===f&&_[a]===_[i]&&_[++a]===_[i+1]){i+=2,a++;do{}while(_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&_[++i]===_[++a]&&i<u);if(n=yt-(u-i),i=u-yt,n>s){if(t.match_start=e,s=n,n>=h)break;f=_[i+s-1],c=_[i+s]}}}while((e=d[e&o])>l&&0!=--r);return s<=t.lookahead?s:t.lookahead},Lt=function(t){var e,a,n,r,i,s,h,l,_,o,d=t.w_size;do{if(r=t.window_size-t.lookahead-t.strstart,t.strstart>=d+(d-kt)){t.window.set(t.window.subarray(d,d+d),0),t.match_start-=d,t.strstart-=d,t.block_start-=d,e=a=t.hash_size;do{n=t.head[--e],t.head[e]=n>=d?n-d:0}while(--a);e=a=d;do{n=t.prev[--e],t.prev[e]=n>=d?n-d:0}while(--a);r+=d}if(0===t.strm.avail_in)break;if(s=t.strm,h=t.window,l=t.strstart+t.lookahead,_=r,o=void 0,(o=s.avail_in)>_&&(o=_),a=0===o?0:(s.avail_in-=o,h.set(s.input.subarray(s.next_in,s.next_in+o),l),1===s.state.wrap?s.adler=K(s.adler,h,o,l):2===s.state.wrap&&(s.adler=O(s.adler,h,o,l)),s.next_in+=o,s.total_in+=o,o),t.lookahead+=a,t.lookahead+t.insert>=3)for(i=t.strstart-t.insert,t.ins_h=t.window[i],t.ins_h=Et(t,t.ins_h,t.window[i+1]);t.insert&&(t.ins_h=Et(t,t.ins_h,t.window[i+3-1]),t.prev[i&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=i,i++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<kt&&0!==t.strm.avail_in)},Tt=function(t,e){for(var a,n;;){if(t.lookahead<kt){if(Lt(t),t.lookahead<kt&&e===nt)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=Et(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-kt&&(t.match_length=Mt(t,a)),t.match_length>=3)if(n=et(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=Et(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=Et(t,t.ins_h,t.window[t.strstart+1]);else n=et(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(n&&(Ct(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Ct(t,!1),0===t.strm.avail_out)?1:2},Ht=function(t,e){for(var a,n,r;;){if(t.lookahead<kt){if(Lt(t),t.lookahead<kt&&e===nt)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=Et(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-kt&&(t.match_length=Mt(t,a),t.match_length<=5&&(t.strategy===ct||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){r=t.strstart+t.lookahead-3,n=et(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=r&&(t.ins_h=Et(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,n&&(Ct(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if((n=et(t,0,t.window[t.strstart-1]))&&Ct(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(n=et(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Ct(t,!1),0===t.strm.avail_out)?1:2};function Rt(t,e,a,n,r){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=n,this.func=r}var Kt=[new Rt(0,0,0,0,(function(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(Lt(t),0===t.lookahead&&e===nt)return 1;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var n=t.block_start+a;if((0===t.strstart||t.strstart>=n)&&(t.lookahead=t.strstart-n,t.strstart=n,Ct(t,!1),0===t.strm.avail_out))return 1;if(t.strstart-t.block_start>=t.w_size-kt&&(Ct(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):(t.strstart>t.block_start&&(Ct(t,!1),t.strm.avail_out),1)})),new Rt(4,4,8,4,Tt),new Rt(4,5,16,8,Tt),new Rt(4,6,32,32,Tt),new Rt(4,4,16,16,Ht),new Rt(8,16,32,32,Ht),new Rt(8,16,128,128,Ht),new Rt(8,32,128,256,Ht),new Rt(32,128,258,1024,Ht),new Rt(32,258,258,4096,Ht)];function Nt(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=mt,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),Bt(this.dyn_ltree),Bt(this.dyn_dtree),Bt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),Bt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),Bt(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}var Ot=function(t){if(!t||!t.state)return Ut(t,ot);t.total_in=t.total_out=0,t.data_type=bt;var e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?42:xt,t.adler=2===e.wrap?0:1,e.last_flush=nt,Z(e),lt},qt=function(t){var e,a=Ot(t);return a===lt&&((e=t.state).window_size=2*e.w_size,Bt(e.head),e.max_lazy_match=Kt[e.level].max_lazy,e.good_match=Kt[e.level].good_length,e.nice_match=Kt[e.level].nice_length,e.max_chain_length=Kt[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=2,e.match_available=0,e.ins_h=0),a},Ft=function(t,e,a,n,r,i){if(!t)return ot;var s=1;if(e===ft&&(e=6),n<0?(s=0,n=-n):n>15&&(s=2,n-=16),r<1||r>9||a!==mt||n<8||n>15||e<0||e>9||i<0||i>wt)return Ut(t,ot);8===n&&(n=9);var h=new Nt;return t.state=h,h.strm=t,h.wrap=s,h.gzhead=null,h.w_bits=n,h.w_size=1<<h.w_bits,h.w_mask=h.w_size-1,h.hash_bits=r+7,h.hash_size=1<<h.hash_bits,h.hash_mask=h.hash_size-1,h.hash_shift=~~((h.hash_bits+3-1)/3),h.window=new Uint8Array(2*h.w_size),h.head=new Uint16Array(h.hash_size),h.prev=new Uint16Array(h.w_size),h.lit_bufsize=1<<r+6,h.pending_buf_size=4*h.lit_bufsize,h.pending_buf=new Uint8Array(h.pending_buf_size),h.d_buf=1*h.lit_bufsize,h.l_buf=3*h.lit_bufsize,h.level=e,h.strategy=i,h.method=a,qt(t)},Gt={deflateInit:function(t,e){return Ft(t,e,mt,15,8,vt)},deflateInit2:Ft,deflateReset:qt,deflateResetKeep:Ot,deflateSetHeader:function(t,e){return t&&t.state?2!==t.state.wrap?ot:(t.state.gzhead=e,lt):ot},deflate:function(t,e){var a,n;if(!t||!t.state||e>ht||e<0)return t?Ut(t,ot):ot;var r=t.state;if(!t.output||!t.input&&0!==t.avail_in||r.status===At&&e!==st)return Ut(t,0===t.avail_out?ut:ot);r.strm=t;var i=r.last_flush;if(r.last_flush=e,42===r.status)if(2===r.wrap)t.adler=0,Dt(r,31),Dt(r,139),Dt(r,8),r.gzhead?(Dt(r,(r.gzhead.text?1:0)+(r.gzhead.hcrc?2:0)+(r.gzhead.extra?4:0)+(r.gzhead.name?8:0)+(r.gzhead.comment?16:0)),Dt(r,255&r.gzhead.time),Dt(r,r.gzhead.time>>8&255),Dt(r,r.gzhead.time>>16&255),Dt(r,r.gzhead.time>>24&255),Dt(r,9===r.level?2:r.strategy>=pt||r.level<2?4:0),Dt(r,255&r.gzhead.os),r.gzhead.extra&&r.gzhead.extra.length&&(Dt(r,255&r.gzhead.extra.length),Dt(r,r.gzhead.extra.length>>8&255)),r.gzhead.hcrc&&(t.adler=O(t.adler,r.pending_buf,r.pending,0)),r.gzindex=0,r.status=69):(Dt(r,0),Dt(r,0),Dt(r,0),Dt(r,0),Dt(r,0),Dt(r,9===r.level?2:r.strategy>=pt||r.level<2?4:0),Dt(r,3),r.status=xt);else{var s=mt+(r.w_bits-8<<4)<<8;s|=(r.strategy>=pt||r.level<2?0:r.level<6?1:6===r.level?2:3)<<6,0!==r.strstart&&(s|=32),s+=31-s%31,r.status=xt,jt(r,s),0!==r.strstart&&(jt(r,t.adler>>>16),jt(r,65535&t.adler)),t.adler=1}if(69===r.status)if(r.gzhead.extra){for(a=r.pending;r.gzindex<(65535&r.gzhead.extra.length)&&(r.pending!==r.pending_buf_size||(r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),St(t),a=r.pending,r.pending!==r.pending_buf_size));)Dt(r,255&r.gzhead.extra[r.gzindex]),r.gzindex++;r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),r.gzindex===r.gzhead.extra.length&&(r.gzindex=0,r.status=73)}else r.status=73;if(73===r.status)if(r.gzhead.name){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),St(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.name.length?255&r.gzhead.name.charCodeAt(r.gzindex++):0,Dt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.gzindex=0,r.status=91)}else r.status=91;if(91===r.status)if(r.gzhead.comment){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),St(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.comment.length?255&r.gzhead.comment.charCodeAt(r.gzindex++):0,Dt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=O(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.status=zt)}else r.status=zt;if(r.status===zt&&(r.gzhead.hcrc?(r.pending+2>r.pending_buf_size&&St(t),r.pending+2<=r.pending_buf_size&&(Dt(r,255&t.adler),Dt(r,t.adler>>8&255),t.adler=0,r.status=xt)):r.status=xt),0!==r.pending){if(St(t),0===t.avail_out)return r.last_flush=-1,lt}else if(0===t.avail_in&&It(e)<=It(i)&&e!==st)return Ut(t,ut);if(r.status===At&&0!==t.avail_in)return Ut(t,ut);if(0!==t.avail_in||0!==r.lookahead||e!==nt&&r.status!==At){var h=r.strategy===pt?function(t,e){for(var a;;){if(0===t.lookahead&&(Lt(t),0===t.lookahead)){if(e===nt)return 1;break}if(t.match_length=0,a=et(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(Ct(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Ct(t,!1),0===t.strm.avail_out)?1:2}(r,e):r.strategy===gt?function(t,e){for(var a,n,r,i,s=t.window;;){if(t.lookahead<=yt){if(Lt(t),t.lookahead<=yt&&e===nt)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=s[r=t.strstart-1])===s[++r]&&n===s[++r]&&n===s[++r]){i=t.strstart+yt;do{}while(n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&r<i);t.match_length=yt-(i-r),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(a=et(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=et(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(Ct(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===st?(Ct(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(Ct(t,!1),0===t.strm.avail_out)?1:2}(r,e):Kt[r.level].func(r,e);if(3!==h&&4!==h||(r.status=At),1===h||3===h)return 0===t.avail_out&&(r.last_flush=-1),lt;if(2===h&&(e===rt?at(r):e!==ht&&($(r,0,0,!1),e===it&&(Bt(r.head),0===r.lookahead&&(r.strstart=0,r.block_start=0,r.insert=0))),St(t),0===t.avail_out))return r.last_flush=-1,lt}return e!==st?lt:r.wrap<=0?_t:(2===r.wrap?(Dt(r,255&t.adler),Dt(r,t.adler>>8&255),Dt(r,t.adler>>16&255),Dt(r,t.adler>>24&255),Dt(r,255&t.total_in),Dt(r,t.total_in>>8&255),Dt(r,t.total_in>>16&255),Dt(r,t.total_in>>24&255)):(jt(r,t.adler>>>16),jt(r,65535&t.adler)),St(t),r.wrap>0&&(r.wrap=-r.wrap),0!==r.pending?lt:_t)},deflateEnd:function(t){if(!t||!t.state)return ot;var e=t.state.status;return 42!==e&&69!==e&&73!==e&&91!==e&&e!==zt&&e!==xt&&e!==At?Ut(t,ot):(t.state=null,e===xt?Ut(t,dt):lt)},deflateSetDictionary:function(t,e){var a=e.length;if(!t||!t.state)return ot;var n=t.state,r=n.wrap;if(2===r||1===r&&42!==n.status||n.lookahead)return ot;if(1===r&&(t.adler=K(t.adler,e,a,0)),n.wrap=0,a>=n.w_size){0===r&&(Bt(n.head),n.strstart=0,n.block_start=0,n.insert=0);var i=new Uint8Array(n.w_size);i.set(e.subarray(a-n.w_size,a),0),e=i,a=n.w_size}var s=t.avail_in,h=t.next_in,l=t.input;for(t.avail_in=a,t.next_in=0,t.input=e,Lt(n);n.lookahead>=3;){var _=n.strstart,o=n.lookahead-2;do{n.ins_h=Et(n,n.ins_h,n.window[_+3-1]),n.prev[_&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=_,_++}while(--o);n.strstart=_,n.lookahead=2,Lt(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=2,n.match_available=0,t.next_in=h,t.input=l,t.avail_in=s,n.wrap=r,lt},deflateInfo:\\\"pako deflate (from Nodeca project)\\\"};for(var Jt=new Uint8Array(256),Pt=0;Pt<256;Pt++)Jt[Pt]=Pt>=252?6:Pt>=248?5:Pt>=240?4:Pt>=224?3:Pt>=192?2:1;Jt[254]=Jt[254]=1;var Qt=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\\\"\\\",this.state=null,this.data_type=2,this.adler=0},Vt=Object.prototype.toString,Wt=F,Xt=G,Yt=J,Zt=P,$t=Q,te=V,ee=W,ae=X,ne=Y;function re(){this.options={level:ee,method:ne,chunkSize:16384,windowBits:15,memLevel:8,strategy:ae};var t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg=\\\"\\\",this.ended=!1,this.chunks=[],this.strm=new Qt,this.strm.avail_out=0;var e=Gt.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(e!==$t)throw new Error(q[e]);if(t.header&&Gt.deflateSetHeader(this.strm,t.header),t.dictionary){var a;if(a=\\\"[object ArrayBuffer]\\\"===Vt.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(e=Gt.deflateSetDictionary(this.strm,a))!==$t)throw new Error(q[e]);this._dict_set=!0}}function ie(t,e,a){try{t.postMessage({type:\\\"errored\\\",error:e,streamId:a})}catch(n){t.postMessage({type:\\\"errored\\\",error:String(e),streamId:a})}}function se(t){const e=t.strm.adler;return new Uint8Array([3,0,e>>>24&255,e>>>16&255,e>>>8&255,255&e])}re.prototype.push=function(t,e){var a,n,r=this.strm,i=this.options.chunkSize;if(this.ended)return!1;for(n=e===~~e?e:!0===e?Zt:Wt,\\\"[object ArrayBuffer]\\\"===Vt.call(t)?r.input=new Uint8Array(t):r.input=t,r.next_in=0,r.avail_in=r.input.length;;)if(0===r.avail_out&&(r.output=new Uint8Array(i),r.next_out=0,r.avail_out=i),(n===Xt||n===Yt)&&r.avail_out<=6)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else{if((a=Gt.deflate(r,n))===te)return r.next_out>0&&this.onData(r.output.subarray(0,r.next_out)),a=Gt.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===$t;if(0!==r.avail_out){if(n>0&&r.next_out>0)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else if(0===r.avail_in)break}else this.onData(r.output)}return!0},re.prototype.onData=function(t){this.chunks.push(t)},re.prototype.onEnd=function(t){t===$t&&(this.result=function(t){for(var e=0,a=0,n=t.length;a<n;a++)e+=t[a].length;for(var r=new Uint8Array(e),i=0,s=0,h=t.length;i<h;i++){var l=t[i];r.set(l,s),s+=l.length}return r}(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},function(e=self){try{const a=new Map;e.addEventListener(\\\"message\\\",(n=>{try{const r=function(e,a){switch(a.action){case\\\"init\\\":return{type:\\\"initialized\\\",version:\\\"6.4.0\\\"};case\\\"write\\\":{let n=e.get(a.streamId);n||(n=new re,e.set(a.streamId,n));const r=n.chunks.length,i=function(t){if(\\\"function\\\"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);let e,a,n,r,i,s=t.length,h=0;for(r=0;r<s;r++)a=t.charCodeAt(r),55296==(64512&a)&&r+1<s&&(n=t.charCodeAt(r+1),56320==(64512&n)&&(a=65536+(a-55296<<10)+(n-56320),r++)),h+=a<128?1:a<2048?2:a<65536?3:4;for(e=new Uint8Array(h),i=0,r=0;i<h;r++)a=t.charCodeAt(r),55296==(64512&a)&&r+1<s&&(n=t.charCodeAt(r+1),56320==(64512&n)&&(a=65536+(a-55296<<10)+(n-56320),r++)),a<128?e[i++]=a:a<2048?(e[i++]=192|a>>>6,e[i++]=128|63&a):a<65536?(e[i++]=224|a>>>12,e[i++]=128|a>>>6&63,e[i++]=128|63&a):(e[i++]=240|a>>>18,e[i++]=128|a>>>12&63,e[i++]=128|a>>>6&63,e[i++]=128|63&a);return e}(a.data);return n.push(i,G),{type:\\\"wrote\\\",id:a.id,streamId:a.streamId,result:t(n.chunks.slice(r)),trailer:se(n),additionalBytesCount:i.length}}case\\\"reset\\\":e.delete(a.streamId)}}(a,n.data);r&&e.postMessage(r)}catch(t){ie(e,t,n.data&&\\\"streamId\\\"in n.data?n.data.streamId:void 0)}}))}catch(t){ie(e,t)}}()})();\"])));\n}\nlet state = { status: 0 /* DeflateWorkerStatus.Nil */ };\nexport function startDeflateWorker(configuration, source, onInitializationFailure, createDeflateWorkerImpl = createDeflateWorker) {\n    if (state.status === 0 /* DeflateWorkerStatus.Nil */) {\n        // doStartDeflateWorker updates the state to \"loading\" or \"error\"\n        doStartDeflateWorker(configuration, source, createDeflateWorkerImpl);\n    }\n    switch (state.status) {\n        case 1 /* DeflateWorkerStatus.Loading */:\n            state.initializationFailureCallbacks.push(onInitializationFailure);\n            return state.worker;\n        case 3 /* DeflateWorkerStatus.Initialized */:\n            return state.worker;\n    }\n}\nexport function resetDeflateWorkerState() {\n    if (state.status === 3 /* DeflateWorkerStatus.Initialized */ || state.status === 1 /* DeflateWorkerStatus.Loading */) {\n        state.stop();\n    }\n    state = { status: 0 /* DeflateWorkerStatus.Nil */ };\n}\nexport function getDeflateWorkerStatus() {\n    return state.status;\n}\n/**\n * Starts the deflate worker and handle messages and errors\n *\n * The spec allow browsers to handle worker errors differently:\n * - Chromium throws an exception\n * - Firefox fires an error event\n *\n * more details: https://bugzilla.mozilla.org/show_bug.cgi?id=1736865#c2\n */\nexport function doStartDeflateWorker(configuration, source, createDeflateWorkerImpl = createDeflateWorker) {\n    try {\n        const worker = createDeflateWorkerImpl(configuration);\n        const { stop: removeErrorListener } = addEventListener(configuration, worker, 'error', (error) => {\n            onError(configuration, source, error);\n        });\n        const { stop: removeMessageListener } = addEventListener(configuration, worker, 'message', ({ data }) => {\n            if (data.type === 'errored') {\n                onError(configuration, source, data.error, data.streamId);\n            }\n            else if (data.type === 'initialized') {\n                onInitialized(data.version);\n            }\n        });\n        worker.postMessage({ action: 'init' });\n        setTimeout(() => onTimeout(source), INITIALIZATION_TIME_OUT_DELAY);\n        const stop = () => {\n            removeErrorListener();\n            removeMessageListener();\n        };\n        state = { status: 1 /* DeflateWorkerStatus.Loading */, worker, stop, initializationFailureCallbacks: [] };\n    }\n    catch (error) {\n        onError(configuration, source, error);\n    }\n}\nfunction onTimeout(source) {\n    if (state.status === 1 /* DeflateWorkerStatus.Loading */) {\n        display.error(`${source} failed to start: a timeout occurred while initializing the Worker`);\n        state.initializationFailureCallbacks.forEach((callback) => callback());\n        state = { status: 2 /* DeflateWorkerStatus.Error */ };\n    }\n}\nfunction onInitialized(version) {\n    if (state.status === 1 /* DeflateWorkerStatus.Loading */) {\n        state = { status: 3 /* DeflateWorkerStatus.Initialized */, worker: state.worker, stop: state.stop, version };\n    }\n}\nfunction onError(configuration, source, error, streamId) {\n    if (state.status === 1 /* DeflateWorkerStatus.Loading */ || state.status === 0 /* DeflateWorkerStatus.Nil */) {\n        display.error(`${source} failed to start: an error occurred while creating the Worker:`, error);\n        if (error instanceof Event || (error instanceof Error && isMessageCspRelated(error.message))) {\n            let baseMessage;\n            if (configuration.workerUrl) {\n                baseMessage = `Please make sure the Worker URL ${configuration.workerUrl} is correct and CSP is correctly configured.`;\n            }\n            else {\n                baseMessage = 'Please make sure CSP is correctly configured.';\n            }\n            display.error(`${baseMessage} See documentation at ${DOCS_ORIGIN}/integrations/content_security_policy_logs/#use-csp-with-real-user-monitoring-and-session-replay`);\n        }\n        else {\n            addTelemetryError(error);\n        }\n        if (state.status === 1 /* DeflateWorkerStatus.Loading */) {\n            state.initializationFailureCallbacks.forEach((callback) => callback());\n        }\n        state = { status: 2 /* DeflateWorkerStatus.Error */ };\n    }\n    else {\n        addTelemetryError(error, {\n            worker_version: state.status === 3 /* DeflateWorkerStatus.Initialized */ && state.version,\n            stream_id: streamId,\n        });\n    }\n}\nfunction isMessageCspRelated(message) {\n    return (message.includes('Content Security Policy') ||\n        // Related to `require-trusted-types-for` CSP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/require-trusted-types-for\n        message.includes(\"requires 'TrustedScriptURL'\"));\n}\n//# sourceMappingURL=deflateWorker.js.map","/**\n * Test for Browser features used while recording\n */\nexport function isBrowserSupported() {\n    return (\n    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances\n    // to be polyfilled. Test for both to be more confident. We could add more things if we find out\n    // this test is not sufficient.\n    typeof Array.from === 'function' &&\n        typeof CSSSupportsRule === 'function' &&\n        typeof URL.createObjectURL === 'function' &&\n        'forEach' in NodeList.prototype);\n}\n//# sourceMappingURL=isBrowserSupported.js.map","import { getSessionReplayUrl } from '@datadog/browser-rum-core';\nimport { isBrowserSupported } from '../boot/isBrowserSupported';\nexport function getSessionReplayLink(configuration, sessionManager, viewHistory, isRecordingStarted) {\n    const session = sessionManager.findTrackedSession();\n    const errorType = getErrorType(session, isRecordingStarted);\n    const viewContext = viewHistory.findView();\n    return getSessionReplayUrl(configuration, {\n        viewContext,\n        errorType,\n        session,\n    });\n}\nfunction getErrorType(session, isRecordingStarted) {\n    if (!isBrowserSupported()) {\n        return 'browser-not-supported';\n    }\n    if (!session) {\n        // possibilities:\n        // - rum sampled out\n        // - session expired (edge case)\n        return 'rum-not-tracked';\n    }\n    if (session.sessionReplay === 0 /* SessionReplayState.OFF */) {\n        // possibilities\n        // - replay sampled out\n        return 'incorrect-session-plan';\n    }\n    if (!isRecordingStarted) {\n        return 'replay-not-started';\n    }\n}\n//# sourceMappingURL=getSessionReplayLink.js.map","import { asyncRunOnReadyState, monitorError, PageExitReason } from '@datadog/browser-core';\nimport { getSessionReplayLink } from '../domain/getSessionReplayLink';\nexport function createPostStartStrategy(configuration, lifeCycle, sessionManager, viewHistory, loadRecorder, getOrCreateDeflateEncoder) {\n    let status = 0 /* RecorderStatus.Stopped */;\n    let stopRecording;\n    lifeCycle.subscribe(9 /* LifeCycleEventType.SESSION_EXPIRED */, () => {\n        if (status === 2 /* RecorderStatus.Starting */ || status === 3 /* RecorderStatus.Started */) {\n            stop();\n            status = 1 /* RecorderStatus.IntentToStart */;\n        }\n    });\n    // Stop the recorder on page unload to avoid sending records after the page is ended.\n    lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_EXITED */, (pageExitEvent) => {\n        if (pageExitEvent.reason === PageExitReason.UNLOADING) {\n            stop();\n        }\n    });\n    lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, () => {\n        if (status === 1 /* RecorderStatus.IntentToStart */) {\n            start();\n        }\n    });\n    const doStart = async () => {\n        const [startRecordingImpl] = await Promise.all([loadRecorder(), asyncRunOnReadyState(configuration, 'interactive')]);\n        if (status !== 2 /* RecorderStatus.Starting */) {\n            return;\n        }\n        const deflateEncoder = getOrCreateDeflateEncoder();\n        if (!deflateEncoder || !startRecordingImpl) {\n            status = 0 /* RecorderStatus.Stopped */;\n            return;\n        }\n        ;\n        ({ stop: stopRecording } = startRecordingImpl(lifeCycle, configuration, sessionManager, viewHistory, deflateEncoder));\n        status = 3 /* RecorderStatus.Started */;\n    };\n    function start(options) {\n        const session = sessionManager.findTrackedSession();\n        if (canStartRecording(session, options)) {\n            status = 1 /* RecorderStatus.IntentToStart */;\n            return;\n        }\n        if (isRecordingInProgress(status)) {\n            return;\n        }\n        status = 2 /* RecorderStatus.Starting */;\n        // Intentionally not awaiting doStart() to keep it asynchronous\n        doStart().catch(monitorError);\n        if (shouldForceReplay(session, options)) {\n            sessionManager.setForcedReplay();\n        }\n    }\n    function stop() {\n        if (status === 3 /* RecorderStatus.Started */) {\n            stopRecording === null || stopRecording === void 0 ? void 0 : stopRecording();\n        }\n        status = 0 /* RecorderStatus.Stopped */;\n    }\n    return {\n        start,\n        stop,\n        getSessionReplayLink() {\n            return getSessionReplayLink(configuration, sessionManager, viewHistory, status !== 0 /* RecorderStatus.Stopped */);\n        },\n        isRecording: () => status === 3 /* RecorderStatus.Started */,\n    };\n}\nfunction canStartRecording(session, options) {\n    return !session || (session.sessionReplay === 0 /* SessionReplayState.OFF */ && (!options || !options.force));\n}\nfunction isRecordingInProgress(status) {\n    return status === 2 /* RecorderStatus.Starting */ || status === 3 /* RecorderStatus.Started */;\n}\nfunction shouldForceReplay(session, options) {\n    return options && options.force && session.sessionReplay === 0 /* SessionReplayState.OFF */;\n}\n//# sourceMappingURL=postStartStrategy.js.map","// Keep the following in sync with packages/rum-slim/src/entries/main.ts\nimport { defineGlobal, getGlobalObject } from '@datadog/browser-core';\nimport { makeRumPublicApi, startRum } from '@datadog/browser-rum-core';\nimport { makeRecorderApi } from '../boot/recorderApi';\nimport { createDeflateEncoder, startDeflateWorker } from '../domain/deflate';\nimport { lazyLoadRecorder } from '../boot/lazyLoadRecorder';\nexport { DefaultPrivacyLevel } from '@datadog/browser-core';\nconst recorderApi = makeRecorderApi(lazyLoadRecorder);\nexport const datadogRum = makeRumPublicApi(startRum, recorderApi, { startDeflateWorker, createDeflateEncoder });\ndefineGlobal(getGlobalObject(), 'DD_RUM', datadogRum);\n//# sourceMappingURL=main.js.map","export function buildCommonContext(globalContextManager, userContextManager, accountContextManager, recorderApi) {\n    return {\n        context: globalContextManager.getContext(),\n        user: userContextManager.getContext(),\n        account: accountContextManager.getContext(),\n        hasReplay: recorderApi.isRecording() ? true : undefined,\n    };\n}\n//# sourceMappingURL=commonContext.js.map","import { catchUserErrors } from '../tools/catchUserErrors';\nimport { setDebugMode } from '../tools/monitor';\nimport { display } from '../tools/display';\nexport function makePublicApi(stub) {\n    const publicApi = {\n        version: \"6.4.0\",\n        // This API method is intentionally not monitored, since the only thing executed is the\n        // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n        // we don't want to interfere with the user uncaught exceptions.\n        onReady(callback) {\n            callback();\n        },\n        ...stub,\n    };\n    // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n    // as much as possible but of course it's not a real protection.\n    Object.defineProperty(publicApi, '_setDebug', {\n        get() {\n            return setDebugMode;\n        },\n        enumerable: false,\n    });\n    return publicApi;\n}\nexport function defineGlobal(global, name, api) {\n    const existingGlobalVariable = global[name];\n    if (existingGlobalVariable && !existingGlobalVariable.q && existingGlobalVariable.version) {\n        display.warn('SDK is loaded more than once. This is unsupported and might have unexpected behavior.');\n    }\n    global[name] = api;\n    if (existingGlobalVariable && existingGlobalVariable.q) {\n        existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')());\n    }\n}\n//# sourceMappingURL=init.js.map","import { sendToExtension, createPageExitObservable, startTelemetry, canUseEventBridge, getEventBridge, addTelemetryDebug, drainPreStartTelemetry, } from '@datadog/browser-core';\nimport { createDOMMutationObservable } from '../browser/domMutationObservable';\nimport { createWindowOpenObservable } from '../browser/windowOpenObservable';\nimport { startRumAssembly } from '../domain/assembly';\nimport { startInternalContext } from '../domain/contexts/internalContext';\nimport { LifeCycle } from '../domain/lifeCycle';\nimport { startViewHistory } from '../domain/contexts/viewHistory';\nimport { startRequestCollection } from '../domain/requestCollection';\nimport { startActionCollection } from '../domain/action/actionCollection';\nimport { startErrorCollection } from '../domain/error/errorCollection';\nimport { startResourceCollection } from '../domain/resource/resourceCollection';\nimport { startViewCollection } from '../domain/view/viewCollection';\nimport { startRumSessionManager, startRumSessionManagerStub } from '../domain/rumSessionManager';\nimport { startRumBatch } from '../transport/startRumBatch';\nimport { startRumEventBridge } from '../transport/startRumEventBridge';\nimport { startUrlContexts } from '../domain/contexts/urlContexts';\nimport { createLocationChangeObservable } from '../browser/locationChangeObservable';\nimport { startFeatureFlagContexts } from '../domain/contexts/featureFlagContext';\nimport { startCustomerDataTelemetry } from '../domain/startCustomerDataTelemetry';\nimport { startPageStateHistory } from '../domain/contexts/pageStateHistory';\nimport { startDisplayContext } from '../domain/contexts/displayContext';\nimport { startVitalCollection } from '../domain/vital/vitalCollection';\nimport { startCiVisibilityContext } from '../domain/contexts/ciVisibilityContext';\nimport { startLongAnimationFrameCollection } from '../domain/longAnimationFrame/longAnimationFrameCollection';\nimport { RumPerformanceEntryType } from '../browser/performanceObservable';\nimport { startLongTaskCollection } from '../domain/longTask/longTaskCollection';\nimport { createHooks } from '../hooks';\nimport { startSyntheticsContext } from '../domain/contexts/syntheticsContext';\nexport function startRum(configuration, recorderApi, customerDataTrackerManager, getCommonContext, initialViewOptions, createEncoder, \n// `startRum` and its subcomponents assume tracking consent is granted initially and starts\n// collecting logs unconditionally. As such, `startRum` should be called with a\n// `trackingConsentState` set to \"granted\".\ntrackingConsentState, customVitalsState) {\n    var _a;\n    const cleanupTasks = [];\n    const lifeCycle = new LifeCycle();\n    const hooks = createHooks();\n    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, (event) => sendToExtension('rum', event));\n    const telemetry = startRumTelemetry(configuration);\n    telemetry.setContextProvider(() => {\n        var _a, _b;\n        return ({\n            application: {\n                id: configuration.applicationId,\n            },\n            session: {\n                id: (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.id,\n            },\n            view: {\n                id: (_b = viewHistory.findView()) === null || _b === void 0 ? void 0 : _b.id,\n            },\n            action: {\n                id: actionContexts.findActionId(),\n            },\n        });\n    });\n    const reportError = (error) => {\n        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });\n        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });\n    };\n    const pageExitObservable = createPageExitObservable(configuration);\n    const pageExitSubscription = pageExitObservable.subscribe((event) => {\n        lifeCycle.notify(11 /* LifeCycleEventType.PAGE_EXITED */, event);\n    });\n    cleanupTasks.push(() => pageExitSubscription.unsubscribe());\n    const session = !canUseEventBridge()\n        ? startRumSessionManager(configuration, lifeCycle, trackingConsentState)\n        : startRumSessionManagerStub();\n    if (!canUseEventBridge()) {\n        const batch = startRumBatch(configuration, lifeCycle, telemetry.observable, reportError, pageExitObservable, session.expireObservable, createEncoder);\n        cleanupTasks.push(() => batch.stop());\n        startCustomerDataTelemetry(configuration, telemetry, lifeCycle, customerDataTrackerManager, batch.flushObservable);\n    }\n    else {\n        startRumEventBridge(lifeCycle);\n    }\n    const domMutationObservable = createDOMMutationObservable();\n    const locationChangeObservable = createLocationChangeObservable(configuration, location);\n    const pageStateHistory = startPageStateHistory(configuration);\n    const viewHistory = startViewHistory(lifeCycle);\n    const urlContexts = startUrlContexts(lifeCycle, hooks, locationChangeObservable, location);\n    const featureFlagContexts = startFeatureFlagContexts(lifeCycle, hooks, configuration, customerDataTrackerManager.getOrCreateTracker(0 /* CustomerDataType.FeatureFlag */));\n    cleanupTasks.push(() => featureFlagContexts.stop());\n    const { observable: windowOpenObservable, stop: stopWindowOpen } = createWindowOpenObservable();\n    cleanupTasks.push(stopWindowOpen);\n    const { actionContexts, addAction, stop: stopRumEventCollection, } = startRumEventCollection(lifeCycle, hooks, configuration, session, pageStateHistory, domMutationObservable, windowOpenObservable, urlContexts, viewHistory, getCommonContext, reportError);\n    cleanupTasks.push(stopRumEventCollection);\n    drainPreStartTelemetry();\n    const { addTiming, startView, setViewName, setViewContext, setViewContextProperty, getViewContext, stop: stopViewCollection, } = startViewCollection(lifeCycle, hooks, configuration, location, domMutationObservable, windowOpenObservable, locationChangeObservable, pageStateHistory, recorderApi, viewHistory, initialViewOptions);\n    cleanupTasks.push(stopViewCollection);\n    const { stop: stopResourceCollection } = startResourceCollection(lifeCycle, configuration, pageStateHistory);\n    cleanupTasks.push(stopResourceCollection);\n    if (configuration.trackLongTasks) {\n        if ((_a = PerformanceObserver.supportedEntryTypes) === null || _a === void 0 ? void 0 : _a.includes(RumPerformanceEntryType.LONG_ANIMATION_FRAME)) {\n            const { stop: stopLongAnimationFrameCollection } = startLongAnimationFrameCollection(lifeCycle, configuration);\n            cleanupTasks.push(stopLongAnimationFrameCollection);\n        }\n        else {\n            startLongTaskCollection(lifeCycle, configuration);\n        }\n    }\n    const { addError } = startErrorCollection(lifeCycle, configuration, pageStateHistory);\n    startRequestCollection(lifeCycle, configuration, session);\n    const vitalCollection = startVitalCollection(lifeCycle, pageStateHistory, customVitalsState);\n    const internalContext = startInternalContext(configuration.applicationId, session, viewHistory, actionContexts, urlContexts);\n    return {\n        addAction,\n        addError,\n        addTiming,\n        addFeatureFlagEvaluation: featureFlagContexts.addFeatureFlagEvaluation,\n        startView,\n        setViewContext,\n        setViewContextProperty,\n        getViewContext,\n        setViewName,\n        lifeCycle,\n        viewHistory,\n        session,\n        stopSession: () => session.expire(),\n        getInternalContext: internalContext.get,\n        startDurationVital: vitalCollection.startDurationVital,\n        stopDurationVital: vitalCollection.stopDurationVital,\n        addDurationVital: vitalCollection.addDurationVital,\n        stop: () => {\n            cleanupTasks.forEach((task) => task());\n        },\n    };\n}\nfunction startRumTelemetry(configuration) {\n    const telemetry = startTelemetry(\"browser-rum-sdk\" /* TelemetryService.RUM */, configuration);\n    if (canUseEventBridge()) {\n        const bridge = getEventBridge();\n        telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event));\n    }\n    return telemetry;\n}\nexport function startRumEventCollection(lifeCycle, hooks, configuration, sessionManager, pageStateHistory, domMutationObservable, windowOpenObservable, urlContexts, viewHistory, getCommonContext, reportError) {\n    const actionCollection = startActionCollection(lifeCycle, hooks, domMutationObservable, windowOpenObservable, configuration, pageStateHistory);\n    const displayContext = startDisplayContext(configuration);\n    const ciVisibilityContext = startCiVisibilityContext(configuration, hooks);\n    startSyntheticsContext(hooks);\n    startRumAssembly(configuration, lifeCycle, hooks, sessionManager, viewHistory, urlContexts, displayContext, getCommonContext, reportError);\n    return {\n        pageStateHistory,\n        addAction: actionCollection.addAction,\n        actionContexts: actionCollection.actionContexts,\n        stop: () => {\n            actionCollection.stop();\n            ciVisibilityContext.stop();\n            displayContext.stop();\n            viewHistory.stop();\n            pageStateHistory.stop();\n        },\n    };\n}\n//# sourceMappingURL=startRum.js.map","import { combine } from '@datadog/browser-core';\nexport function createHooks() {\n    const callbacks = {};\n    return {\n        register(hookName, callback) {\n            if (!callbacks[hookName]) {\n                callbacks[hookName] = [];\n            }\n            callbacks[hookName].push(callback);\n            return {\n                unregister: () => {\n                    callbacks[hookName] = callbacks[hookName].filter((cb) => cb !== callback);\n                },\n            };\n        },\n        triggerHook(hookName, param) {\n            const hookCallbacks = callbacks[hookName] || [];\n            const results = hookCallbacks.map((callback) => callback(param));\n            return combine(...results);\n        },\n    };\n}\n//# sourceMappingURL=hooks.js.map","import { getEventBridge } from '@datadog/browser-core';\nexport function startRumEventBridge(lifeCycle) {\n    const bridge = getEventBridge();\n    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, (serverRumEvent) => {\n        bridge.send('rum', serverRumEvent);\n    });\n}\n//# sourceMappingURL=startRumEventBridge.js.map","import { instrumentMethod, Observable } from '@datadog/browser-core';\nexport function createWindowOpenObservable() {\n    const observable = new Observable();\n    const { stop } = instrumentMethod(window, 'open', () => observable.notify());\n    return { observable, stop };\n}\n//# sourceMappingURL=windowOpenObservable.js.map","import { monitor } from '@datadog/browser-core';\nimport { getViewportDimension, initViewportObservable } from '../../browser/viewportObservable';\nexport function startDisplayContext(configuration) {\n    let viewport;\n    // Use requestAnimationFrame to delay the calculation of viewport dimensions until after SDK initialization, preventing long tasks.\n    const animationFrameId = requestAnimationFrame(monitor(() => {\n        viewport = getViewportDimension();\n    }));\n    const unsubscribeViewport = initViewportObservable(configuration).subscribe((viewportDimension) => {\n        viewport = viewportDimension;\n    }).unsubscribe;\n    return {\n        get: () => (viewport ? { viewport } : undefined),\n        stop: () => {\n            unsubscribeViewport();\n            if (animationFrameId) {\n                cancelAnimationFrame(animationFrameId);\n            }\n        },\n    };\n}\n//# sourceMappingURL=displayContext.js.map","import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../browser/performanceObservable';\nexport function startLongAnimationFrameCollection(lifeCycle, configuration) {\n    const performanceResourceSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.LONG_ANIMATION_FRAME,\n        buffered: true,\n    }).subscribe((entries) => {\n        for (const entry of entries) {\n            const startClocks = relativeToClocks(entry.startTime);\n            const rawRumEvent = {\n                date: startClocks.timeStamp,\n                long_task: {\n                    id: generateUUID(),\n                    entry_type: \"long-animation-frame\" /* RumLongTaskEntryType.LONG_ANIMATION_FRAME */,\n                    duration: toServerDuration(entry.duration),\n                    blocking_duration: toServerDuration(entry.blockingDuration),\n                    first_ui_event_timestamp: toServerDuration(entry.firstUIEventTimestamp),\n                    render_start: toServerDuration(entry.renderStart),\n                    style_and_layout_start: toServerDuration(entry.styleAndLayoutStart),\n                    start_time: toServerDuration(entry.startTime),\n                    scripts: entry.scripts.map((script) => ({\n                        duration: toServerDuration(script.duration),\n                        pause_duration: toServerDuration(script.pauseDuration),\n                        forced_style_and_layout_duration: toServerDuration(script.forcedStyleAndLayoutDuration),\n                        start_time: toServerDuration(script.startTime),\n                        execution_start: toServerDuration(script.executionStart),\n                        source_url: script.sourceURL,\n                        source_function_name: script.sourceFunctionName,\n                        source_char_position: script.sourceCharPosition,\n                        invoker: script.invoker,\n                        invoker_type: script.invokerType,\n                        window_attribution: script.windowAttribution,\n                    })),\n                },\n                type: \"long_task\" /* RumEventType.LONG_TASK */,\n                _dd: {\n                    discarded: false,\n                },\n            };\n            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, {\n                rawRumEvent,\n                startTime: startClocks.relative,\n                domainContext: { performanceEntry: entry },\n            });\n        }\n    });\n    return {\n        stop: () => performanceResourceSubscription.unsubscribe(),\n    };\n}\n//# sourceMappingURL=longAnimationFrameCollection.js.map","import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core';\nimport { createPerformanceObservable, RumPerformanceEntryType } from '../../browser/performanceObservable';\nexport function startLongTaskCollection(lifeCycle, configuration) {\n    const performanceLongTaskSubscription = createPerformanceObservable(configuration, {\n        type: RumPerformanceEntryType.LONG_TASK,\n        buffered: true,\n    }).subscribe((entries) => {\n        for (const entry of entries) {\n            if (entry.entryType !== RumPerformanceEntryType.LONG_TASK) {\n                break;\n            }\n            if (!configuration.trackLongTasks) {\n                break;\n            }\n            const startClocks = relativeToClocks(entry.startTime);\n            const rawRumEvent = {\n                date: startClocks.timeStamp,\n                long_task: {\n                    id: generateUUID(),\n                    entry_type: \"long-task\" /* RumLongTaskEntryType.LONG_TASK */,\n                    duration: toServerDuration(entry.duration),\n                },\n                type: \"long_task\" /* RumEventType.LONG_TASK */,\n                _dd: {\n                    discarded: false,\n                },\n            };\n            lifeCycle.notify(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, {\n                rawRumEvent,\n                startTime: startClocks.relative,\n                domainContext: { performanceEntry: entry },\n            });\n        }\n    });\n    return {\n        stop() {\n            performanceLongTaskSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=longTaskCollection.js.map","/**\n * Internal context keep returning v1 format\n * to not break compatibility with logs data format\n */\nexport function startInternalContext(applicationId, sessionManager, viewHistory, actionContexts, urlContexts) {\n    return {\n        get: (startTime) => {\n            const viewContext = viewHistory.findView(startTime);\n            const urlContext = urlContexts.findUrl(startTime);\n            const session = sessionManager.findTrackedSession(startTime);\n            if (session && viewContext && urlContext) {\n                const actionId = actionContexts.findActionId(startTime);\n                return {\n                    application_id: applicationId,\n                    session_id: session.id,\n                    user_action: actionId ? { id: actionId } : undefined,\n                    view: { id: viewContext.id, name: viewContext.name, referrer: urlContext.referrer, url: urlContext.url },\n                };\n            }\n        },\n    };\n}\n//# sourceMappingURL=internalContext.js.map","import { canUseEventBridge, noop, bridgeSupports, } from '@datadog/browser-core';\nimport { getReplayStats as getReplayStatsImpl } from '../domain/replayStats';\nimport { createDeflateEncoder, getDeflateWorkerStatus, startDeflateWorker, } from '../domain/deflate';\nimport { isBrowserSupported } from './isBrowserSupported';\nimport { createPostStartStrategy } from './postStartStrategy';\nimport { createPreStartStrategy } from './preStartStrategy';\nexport function makeRecorderApi(loadRecorder, createDeflateWorkerImpl) {\n    if ((canUseEventBridge() && !bridgeSupports(\"records\" /* BridgeCapability.RECORDS */)) || !isBrowserSupported()) {\n        return {\n            start: noop,\n            stop: noop,\n            getReplayStats: () => undefined,\n            onRumStart: noop,\n            isRecording: () => false,\n            getSessionReplayLink: () => undefined,\n        };\n    }\n    // eslint-disable-next-line prefer-const\n    let { strategy, shouldStartImmediately } = createPreStartStrategy();\n    return {\n        start: (options) => strategy.start(options),\n        stop: () => strategy.stop(),\n        getSessionReplayLink: () => strategy.getSessionReplayLink(),\n        onRumStart,\n        isRecording: () => \n        // The worker is started optimistically, meaning we could have started to record but its\n        // initialization fails a bit later. This could happen when:\n        // * the worker URL (blob or plain URL) is blocked by CSP in Firefox only (Chromium and Safari\n        // throw an exception when instantiating the worker, and IE doesn't care about CSP)\n        // * the browser fails to load the worker in case the workerUrl is used\n        // * an unexpected error occurs in the Worker before initialization, ex:\n        //   * a runtime exception collected by monitor()\n        //   * a syntax error notified by the browser via an error event\n        // * the worker is unresponsive for some reason and timeouts\n        //\n        // It is not expected to happen often. Nonetheless, the \"replayable\" status on RUM events is\n        // an important part of the Datadog App:\n        // * If we have a false positive (we set has_replay: true even if no replay data is present),\n        // we might display broken links to the Session Replay player.\n        // * If we have a false negative (we don't set has_replay: true even if replay data is\n        // available), it is less noticeable because no link will be displayed.\n        //\n        // Thus, it is better to have false negative, so let's make sure the worker is correctly\n        // initialized before advertizing that we are recording.\n        //\n        // In the future, when the compression worker will also be used for RUM data, this will be\n        // less important since no RUM event will be sent when the worker fails to initialize.\n        getDeflateWorkerStatus() === 3 /* DeflateWorkerStatus.Initialized */ && strategy.isRecording(),\n        getReplayStats: (viewId) => getDeflateWorkerStatus() === 3 /* DeflateWorkerStatus.Initialized */ ? getReplayStatsImpl(viewId) : undefined,\n    };\n    function onRumStart(lifeCycle, configuration, sessionManager, viewHistory, worker) {\n        let cachedDeflateEncoder;\n        function getOrCreateDeflateEncoder() {\n            if (!cachedDeflateEncoder) {\n                worker !== null && worker !== void 0 ? worker : (worker = startDeflateWorker(configuration, 'Datadog Session Replay', () => {\n                    strategy.stop();\n                }, createDeflateWorkerImpl));\n                if (worker) {\n                    cachedDeflateEncoder = createDeflateEncoder(configuration, worker, 1 /* DeflateEncoderStreamId.REPLAY */);\n                }\n            }\n            return cachedDeflateEncoder;\n        }\n        strategy = createPostStartStrategy(configuration, lifeCycle, sessionManager, viewHistory, loadRecorder, getOrCreateDeflateEncoder);\n        if (shouldStartImmediately(configuration)) {\n            strategy.start();\n        }\n    }\n}\n//# sourceMappingURL=recorderApi.js.map","import { noop } from '@datadog/browser-core';\nexport function createPreStartStrategy() {\n    let status = 0 /* PreStartRecorderStatus.None */;\n    return {\n        strategy: {\n            start() {\n                status = 1 /* PreStartRecorderStatus.HadManualStart */;\n            },\n            stop() {\n                status = 2 /* PreStartRecorderStatus.HadManualStop */;\n            },\n            isRecording: () => false,\n            getSessionReplayLink: noop,\n        },\n        shouldStartImmediately(configuration) {\n            return (status === 1 /* PreStartRecorderStatus.HadManualStart */ ||\n                (status === 0 /* PreStartRecorderStatus.None */ && !configuration.startSessionReplayRecordingManually));\n        },\n    };\n}\n//# sourceMappingURL=preStartStrategy.js.map","export async function lazyLoadRecorder() {\n    try {\n        const module = await import(/* webpackChunkName: \"recorder\" */ './startRecording');\n        return module.startRecording;\n    }\n    catch (_a) {\n        /* Prevent collecting the webpack ChunkLoadError as it is already collected as a RUM resource. */\n    }\n}\n//# sourceMappingURL=lazyLoadRecorder.js.map","/*!\n * vue-router v4.6.3\n * (c) 2025 Eduardo San Martin Morote\n * @license MIT\n */\nimport { getCurrentInstance, inject, onActivated, onDeactivated, onUnmounted, watch } from \"vue\";\nimport { setupDevtoolsPlugin } from \"@vue/devtools-api\";\n\n//#region src/utils/env.ts\nconst isBrowser = typeof document !== \"undefined\";\n\n//#endregion\n//#region src/utils/index.ts\n/**\n* Identity function that returns the value as is.\n*\n* @param v - the value to return\n*\n* @internal\n*/\nconst identityFn = (v) => v;\n/**\n* Allows differentiating lazy components from functional components and vue-class-component\n* @internal\n*\n* @param component\n*/\nfunction isRouteComponent(component) {\n\treturn typeof component === \"object\" || \"displayName\" in component || \"props\" in component || \"__vccOpts\" in component;\n}\nfunction isESModule(obj) {\n\treturn obj.__esModule || obj[Symbol.toStringTag] === \"Module\" || obj.default && isRouteComponent(obj.default);\n}\nconst assign = Object.assign;\nfunction applyToParams(fn, params) {\n\tconst newParams = {};\n\tfor (const key in params) {\n\t\tconst value = params[key];\n\t\tnewParams[key] = isArray(value) ? value.map(fn) : fn(value);\n\t}\n\treturn newParams;\n}\nconst noop = () => {};\n/**\n* Typesafe alternative to Array.isArray\n* https://github.com/microsoft/TypeScript/pull/48228\n*/\nconst isArray = Array.isArray;\nfunction mergeOptions(defaults, partialOptions) {\n\tconst options = {};\n\tfor (const key in defaults) options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n\treturn options;\n}\n\n//#endregion\n//#region src/warning.ts\nfunction warn$1(msg) {\n\tconst args = Array.from(arguments).slice(1);\n\tconsole.warn.apply(console, [\"[Vue Router warn]: \" + msg].concat(args));\n}\n\n//#endregion\n//#region src/encoding.ts\n/**\n* Encoding Rules ( = Space)\n* - Path:  \" < > # ? { }\n* - Query:  \" < > # & =\n* - Hash:  \" < > `\n*\n* On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\n* defines some extra characters to be encoded. Most browsers do not encode them\n* in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\n* also encode `!'()*`. Leaving un-encoded only ASCII alphanumeric(`a-zA-Z0-9`)\n* plus `-._~`. This extra safety should be applied to query by patching the\n* string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\n* should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\n* into a `/` if directly typed in. The _backtick_ (`````) should also be\n* encoded everywhere because some browsers like FF encode it when directly\n* written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\n*/\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\n/**\n* NOTE: It's not clear to me if we should encode the + symbol in queries, it\n* seems to be less flexible than not doing so and I can't find out the legacy\n* systems requiring this for regular requests like text/html. In the standard,\n* the encoding of the plus character is only mentioned for\n* application/x-www-form-urlencoded\n* (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\n* leave the plus character as is in queries. To be more flexible, we allow the\n* plus character on the query, but it can also be manually encoded by the user.\n*\n* Resources:\n* - https://url.spec.whatwg.org/#urlencoded-parsing\n* - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\n*/\nconst ENC_BRACKET_OPEN_RE = /%5B/g;\nconst ENC_BRACKET_CLOSE_RE = /%5D/g;\nconst ENC_CARET_RE = /%5E/g;\nconst ENC_BACKTICK_RE = /%60/g;\nconst ENC_CURLY_OPEN_RE = /%7B/g;\nconst ENC_PIPE_RE = /%7C/g;\nconst ENC_CURLY_CLOSE_RE = /%7D/g;\nconst ENC_SPACE_RE = /%20/g;\n/**\n* Encode characters that need to be encoded on the path, search and hash\n* sections of the URL.\n*\n* @internal\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction commonEncode(text) {\n\treturn text == null ? \"\" : encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\n/**\n* Encode characters that need to be encoded on the hash section of the URL.\n*\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction encodeHash(text) {\n\treturn commonEncode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\n/**\n* Encode characters that need to be encoded query values on the query\n* section of the URL.\n*\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction encodeQueryValue(text) {\n\treturn commonEncode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\n/**\n* Like `encodeQueryValue` but also encodes the `=` character.\n*\n* @param text - string to encode\n*/\nfunction encodeQueryKey(text) {\n\treturn encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\n/**\n* Encode characters that need to be encoded on the path section of the URL.\n*\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction encodePath(text) {\n\treturn commonEncode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\");\n}\n/**\n* Encode characters that need to be encoded on the path section of the URL as a\n* param. This function encodes everything {@link encodePath} does plus the\n* slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\n* string instead.\n*\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction encodeParam(text) {\n\treturn encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text) {\n\tif (text == null) return null;\n\ttry {\n\t\treturn decodeURIComponent(\"\" + text);\n\t} catch (err) {\n\t\tprocess.env.NODE_ENV !== \"production\" && warn$1(`Error decoding \"${text}\". Using original value`);\n\t}\n\treturn \"\" + text;\n}\n\n//#endregion\n//#region src/location.ts\nconst TRAILING_SLASH_RE = /\\/$/;\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, \"\");\n/**\n* Transforms a URI into a normalized history location\n*\n* @param parseQuery\n* @param location - URI to normalize\n* @param currentLocation - current absolute location. Allows resolving relative\n* paths. Must start with `/`. Defaults to `/`\n* @returns a normalized history location\n*/\nfunction parseURL(parseQuery$1, location, currentLocation = \"/\") {\n\tlet path, query = {}, searchString = \"\", hash = \"\";\n\tconst hashPos = location.indexOf(\"#\");\n\tlet searchPos = location.indexOf(\"?\");\n\tsearchPos = hashPos >= 0 && searchPos > hashPos ? -1 : searchPos;\n\tif (searchPos >= 0) {\n\t\tpath = location.slice(0, searchPos);\n\t\tsearchString = location.slice(searchPos, hashPos > 0 ? hashPos : location.length);\n\t\tquery = parseQuery$1(searchString.slice(1));\n\t}\n\tif (hashPos >= 0) {\n\t\tpath = path || location.slice(0, hashPos);\n\t\thash = location.slice(hashPos, location.length);\n\t}\n\tpath = resolveRelativePath(path != null ? path : location, currentLocation);\n\treturn {\n\t\tfullPath: path + searchString + hash,\n\t\tpath,\n\t\tquery,\n\t\thash: decode(hash)\n\t};\n}\nfunction NEW_stringifyURL(stringifyQuery$1, path, query, hash = \"\") {\n\tconst searchText = stringifyQuery$1(query);\n\treturn path + (searchText && \"?\") + searchText + encodeHash(hash);\n}\n/**\n* Stringifies a URL object\n*\n* @param stringifyQuery\n* @param location\n*/\nfunction stringifyURL(stringifyQuery$1, location) {\n\tconst query = location.query ? stringifyQuery$1(location.query) : \"\";\n\treturn location.path + (query && \"?\") + query + (location.hash || \"\");\n}\n/**\n* Strips off the base from the beginning of a location.pathname in a non-case-sensitive way.\n*\n* @param pathname - location.pathname\n* @param base - base to strip off\n*/\nfunction stripBase(pathname, base) {\n\tif (!base || !pathname.toLowerCase().startsWith(base.toLowerCase())) return pathname;\n\treturn pathname.slice(base.length) || \"/\";\n}\n/**\n* Checks if two RouteLocation are equal. This means that both locations are\n* pointing towards the same {@link RouteRecord} and that all `params`, `query`\n* parameters and `hash` are the same\n*\n* @param stringifyQuery - A function that takes a query object of type LocationQueryRaw and returns a string representation of it.\n* @param a - first {@link RouteLocation}\n* @param b - second {@link RouteLocation}\n*/\nfunction isSameRouteLocation(stringifyQuery$1, a, b) {\n\tconst aLastIndex = a.matched.length - 1;\n\tconst bLastIndex = b.matched.length - 1;\n\treturn aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery$1(a.query) === stringifyQuery$1(b.query) && a.hash === b.hash;\n}\n/**\n* Check if two `RouteRecords` are equal. Takes into account aliases: they are\n* considered equal to the `RouteRecord` they are aliasing.\n*\n* @param a - first {@link RouteRecord}\n* @param b - second {@link RouteRecord}\n*/\nfunction isSameRouteRecord(a, b) {\n\treturn (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n\tif (Object.keys(a).length !== Object.keys(b).length) return false;\n\tfor (const key in a) if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;\n\treturn true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n\treturn isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;\n}\n/**\n* Check if two arrays are the same or if an array with one single entry is the\n* same as another primitive value. Used to check query and parameters\n*\n* @param a - array of values\n* @param b - array of values or a single value\n*/\nfunction isEquivalentArray(a, b) {\n\treturn isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;\n}\n/**\n* Resolves a relative path that starts with `.`.\n*\n* @param to - path location we are resolving\n* @param from - currentLocation.path, should start with `/`\n*/\nfunction resolveRelativePath(to, from) {\n\tif (to.startsWith(\"/\")) return to;\n\tif (process.env.NODE_ENV !== \"production\" && !from.startsWith(\"/\")) {\n\t\twarn$1(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\n\t\treturn to;\n\t}\n\tif (!to) return from;\n\tconst fromSegments = from.split(\"/\");\n\tconst toSegments = to.split(\"/\");\n\tconst lastToSegment = toSegments[toSegments.length - 1];\n\tif (lastToSegment === \"..\" || lastToSegment === \".\") toSegments.push(\"\");\n\tlet position = fromSegments.length - 1;\n\tlet toPosition;\n\tlet segment;\n\tfor (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n\t\tsegment = toSegments[toPosition];\n\t\tif (segment === \".\") continue;\n\t\tif (segment === \"..\") {\n\t\t\tif (position > 1) position--;\n\t\t} else break;\n\t}\n\treturn fromSegments.slice(0, position).join(\"/\") + \"/\" + toSegments.slice(toPosition).join(\"/\");\n}\n/**\n* Initial route location where the router is. Can be used in navigation guards\n* to differentiate the initial navigation.\n*\n* @example\n* ```js\n* import { START_LOCATION } from 'vue-router'\n*\n* router.beforeEach((to, from) => {\n*   if (from === START_LOCATION) {\n*     // initial navigation\n*   }\n* })\n* ```\n*/\nconst START_LOCATION_NORMALIZED = {\n\tpath: \"/\",\n\tname: void 0,\n\tparams: {},\n\tquery: {},\n\thash: \"\",\n\tfullPath: \"/\",\n\tmatched: [],\n\tmeta: {},\n\tredirectedFrom: void 0\n};\n\n//#endregion\n//#region src/history/common.ts\nlet NavigationType = /* @__PURE__ */ function(NavigationType$1) {\n\tNavigationType$1[\"pop\"] = \"pop\";\n\tNavigationType$1[\"push\"] = \"push\";\n\treturn NavigationType$1;\n}({});\nlet NavigationDirection = /* @__PURE__ */ function(NavigationDirection$1) {\n\tNavigationDirection$1[\"back\"] = \"back\";\n\tNavigationDirection$1[\"forward\"] = \"forward\";\n\tNavigationDirection$1[\"unknown\"] = \"\";\n\treturn NavigationDirection$1;\n}({});\n/**\n* Starting location for Histories\n*/\nconst START = \"\";\n/**\n* Normalizes a base by removing any trailing slash and reading the base tag if\n* present.\n*\n* @param base - base to normalize\n*/\nfunction normalizeBase(base) {\n\tif (!base) if (isBrowser) {\n\t\tconst baseEl = document.querySelector(\"base\");\n\t\tbase = baseEl && baseEl.getAttribute(\"href\") || \"/\";\n\t\tbase = base.replace(/^\\w+:\\/\\/[^\\/]+/, \"\");\n\t} else base = \"/\";\n\tif (base[0] !== \"/\" && base[0] !== \"#\") base = \"/\" + base;\n\treturn removeTrailingSlash(base);\n}\nconst BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location) {\n\treturn base.replace(BEFORE_HASH_RE, \"#\") + location;\n}\n\n//#endregion\n//#region src/scrollBehavior.ts\nfunction getElementPosition(el, offset) {\n\tconst docRect = document.documentElement.getBoundingClientRect();\n\tconst elRect = el.getBoundingClientRect();\n\treturn {\n\t\tbehavior: offset.behavior,\n\t\tleft: elRect.left - docRect.left - (offset.left || 0),\n\t\ttop: elRect.top - docRect.top - (offset.top || 0)\n\t};\n}\nconst computeScrollPosition = () => ({\n\tleft: window.scrollX,\n\ttop: window.scrollY\n});\nfunction scrollToPosition(position) {\n\tlet scrollToOptions;\n\tif (\"el\" in position) {\n\t\tconst positionEl = position.el;\n\t\tconst isIdSelector = typeof positionEl === \"string\" && positionEl.startsWith(\"#\");\n\t\t/**\n\t\t* `id`s can accept pretty much any characters, including CSS combinators\n\t\t* like `>` or `~`. It's still possible to retrieve elements using\n\t\t* `document.getElementById('~')` but it needs to be escaped when using\n\t\t* `document.querySelector('#\\\\~')` for it to be valid. The only\n\t\t* requirements for `id`s are them to be unique on the page and to not be\n\t\t* empty (`id=\"\"`). Because of that, when passing an id selector, it should\n\t\t* be properly escaped for it to work with `querySelector`. We could check\n\t\t* for the id selector to be simple (no CSS combinators `+ >~`) but that\n\t\t* would make things inconsistent since they are valid characters for an\n\t\t* `id` but would need to be escaped when using `querySelector`, breaking\n\t\t* their usage and ending up in no selector returned. Selectors need to be\n\t\t* escaped:\n\t\t*\n\t\t* - `#1-thing` becomes `#\\31 -thing`\n\t\t* - `#with~symbols` becomes `#with\\\\~symbols`\n\t\t*\n\t\t* - More information about  the topic can be found at\n\t\t*   https://mathiasbynens.be/notes/html5-id-class.\n\t\t* - Practical example: https://mathiasbynens.be/demo/html5-id\n\t\t*/\n\t\tif (process.env.NODE_ENV !== \"production\" && typeof position.el === \"string\") {\n\t\t\tif (!isIdSelector || !document.getElementById(position.el.slice(1))) try {\n\t\t\t\tconst foundEl = document.querySelector(position.el);\n\t\t\t\tif (isIdSelector && foundEl) {\n\t\t\t\t\twarn$1(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\twarn$1(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tconst el = typeof positionEl === \"string\" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;\n\t\tif (!el) {\n\t\t\tprocess.env.NODE_ENV !== \"production\" && warn$1(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\n\t\t\treturn;\n\t\t}\n\t\tscrollToOptions = getElementPosition(el, position);\n\t} else scrollToOptions = position;\n\tif (\"scrollBehavior\" in document.documentElement.style) window.scrollTo(scrollToOptions);\n\telse window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);\n}\nfunction getScrollKey(path, delta) {\n\treturn (history.state ? history.state.position - delta : -1) + path;\n}\nconst scrollPositions = /* @__PURE__ */ new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n\tscrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n\tconst scroll = scrollPositions.get(key);\n\tscrollPositions.delete(key);\n\treturn scroll;\n}\n/**\n* ScrollBehavior instance used by the router to compute and restore the scroll\n* position when navigating.\n*/\n\n//#endregion\n//#region src/types/typeGuards.ts\nfunction isRouteLocation(route) {\n\treturn typeof route === \"string\" || route && typeof route === \"object\";\n}\nfunction isRouteName(name) {\n\treturn typeof name === \"string\" || typeof name === \"symbol\";\n}\n\n//#endregion\n//#region src/errors.ts\n/**\n* Flags so we can combine them when checking for multiple errors. This is the internal version of\n* {@link NavigationFailureType}.\n*\n* @internal\n*/\nlet ErrorTypes = /* @__PURE__ */ function(ErrorTypes$1) {\n\tErrorTypes$1[ErrorTypes$1[\"MATCHER_NOT_FOUND\"] = 1] = \"MATCHER_NOT_FOUND\";\n\tErrorTypes$1[ErrorTypes$1[\"NAVIGATION_GUARD_REDIRECT\"] = 2] = \"NAVIGATION_GUARD_REDIRECT\";\n\tErrorTypes$1[ErrorTypes$1[\"NAVIGATION_ABORTED\"] = 4] = \"NAVIGATION_ABORTED\";\n\tErrorTypes$1[ErrorTypes$1[\"NAVIGATION_CANCELLED\"] = 8] = \"NAVIGATION_CANCELLED\";\n\tErrorTypes$1[ErrorTypes$1[\"NAVIGATION_DUPLICATED\"] = 16] = \"NAVIGATION_DUPLICATED\";\n\treturn ErrorTypes$1;\n}({});\nconst NavigationFailureSymbol = Symbol(process.env.NODE_ENV !== \"production\" ? \"navigation failure\" : \"\");\n/**\n* Enumeration with all possible types for navigation failures. Can be passed to\n* {@link isNavigationFailure} to check for specific failures.\n*/\nlet NavigationFailureType = /* @__PURE__ */ function(NavigationFailureType$1) {\n\t/**\n\t* An aborted navigation is a navigation that failed because a navigation\n\t* guard returned `false` or called `next(false)`\n\t*/\n\tNavigationFailureType$1[NavigationFailureType$1[\"aborted\"] = 4] = \"aborted\";\n\t/**\n\t* A cancelled navigation is a navigation that failed because a more recent\n\t* navigation finished started (not necessarily finished).\n\t*/\n\tNavigationFailureType$1[NavigationFailureType$1[\"cancelled\"] = 8] = \"cancelled\";\n\t/**\n\t* A duplicated navigation is a navigation that failed because it was\n\t* initiated while already being at the exact same location.\n\t*/\n\tNavigationFailureType$1[NavigationFailureType$1[\"duplicated\"] = 16] = \"duplicated\";\n\treturn NavigationFailureType$1;\n}({});\nconst ErrorTypeMessages = {\n\t[ErrorTypes.MATCHER_NOT_FOUND]({ location, currentLocation }) {\n\t\treturn `No match for\\n ${JSON.stringify(location)}${currentLocation ? \"\\nwhile being at\\n\" + JSON.stringify(currentLocation) : \"\"}`;\n\t},\n\t[ErrorTypes.NAVIGATION_GUARD_REDIRECT]({ from, to }) {\n\t\treturn `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n\t},\n\t[ErrorTypes.NAVIGATION_ABORTED]({ from, to }) {\n\t\treturn `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n\t},\n\t[ErrorTypes.NAVIGATION_CANCELLED]({ from, to }) {\n\t\treturn `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n\t},\n\t[ErrorTypes.NAVIGATION_DUPLICATED]({ from, to }) {\n\t\treturn `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n\t}\n};\n/**\n* Creates a typed NavigationFailure object.\n* @internal\n* @param type - NavigationFailureType\n* @param params - { from, to }\n*/\nfunction createRouterError(type, params) {\n\tif (process.env.NODE_ENV !== \"production\" || false) return assign(new Error(ErrorTypeMessages[type](params)), {\n\t\ttype,\n\t\t[NavigationFailureSymbol]: true\n\t}, params);\n\telse return assign(/* @__PURE__ */ new Error(), {\n\t\ttype,\n\t\t[NavigationFailureSymbol]: true\n\t}, params);\n}\nfunction isNavigationFailure(error, type) {\n\treturn error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));\n}\nconst propertiesToLog = [\n\t\"params\",\n\t\"query\",\n\t\"hash\"\n];\nfunction stringifyRoute(to) {\n\tif (typeof to === \"string\") return to;\n\tif (to.path != null) return to.path;\n\tconst location = {};\n\tfor (const key of propertiesToLog) if (key in to) location[key] = to[key];\n\treturn JSON.stringify(location, null, 2);\n}\n\n//#endregion\n//#region src/query.ts\n/**\n* Transforms a queryString into a {@link LocationQuery} object. Accept both, a\n* version with the leading `?` and without Should work as URLSearchParams\n\n* @internal\n*\n* @param search - search string to parse\n* @returns a query object\n*/\nfunction parseQuery(search) {\n\tconst query = {};\n\tif (search === \"\" || search === \"?\") return query;\n\tconst searchParams = (search[0] === \"?\" ? search.slice(1) : search).split(\"&\");\n\tfor (let i = 0; i < searchParams.length; ++i) {\n\t\tconst searchParam = searchParams[i].replace(PLUS_RE, \" \");\n\t\tconst eqPos = searchParam.indexOf(\"=\");\n\t\tconst key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n\t\tconst value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n\t\tif (key in query) {\n\t\t\tlet currentValue = query[key];\n\t\t\tif (!isArray(currentValue)) currentValue = query[key] = [currentValue];\n\t\t\tcurrentValue.push(value);\n\t\t} else query[key] = value;\n\t}\n\treturn query;\n}\n/**\n* Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\n* doesn't prepend a `?`\n*\n* @internal\n*\n* @param query - query object to stringify\n* @returns string version of the query without the leading `?`\n*/\nfunction stringifyQuery(query) {\n\tlet search = \"\";\n\tfor (let key in query) {\n\t\tconst value = query[key];\n\t\tkey = encodeQueryKey(key);\n\t\tif (value == null) {\n\t\t\tif (value !== void 0) search += (search.length ? \"&\" : \"\") + key;\n\t\t\tcontinue;\n\t\t}\n\t\t(isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)]).forEach((value$1) => {\n\t\t\tif (value$1 !== void 0) {\n\t\t\t\tsearch += (search.length ? \"&\" : \"\") + key;\n\t\t\t\tif (value$1 != null) search += \"=\" + value$1;\n\t\t\t}\n\t\t});\n\t}\n\treturn search;\n}\n/**\n* Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\n* numbers into strings, removing keys with an undefined value and replacing\n* undefined with null in arrays\n*\n* @param query - query object to normalize\n* @returns a normalized query object\n*/\nfunction normalizeQuery(query) {\n\tconst normalizedQuery = {};\n\tfor (const key in query) {\n\t\tconst value = query[key];\n\t\tif (value !== void 0) normalizedQuery[key] = isArray(value) ? value.map((v) => v == null ? null : \"\" + v) : value == null ? value : \"\" + value;\n\t}\n\treturn normalizedQuery;\n}\n\n//#endregion\n//#region src/injectionSymbols.ts\n/**\n* RouteRecord being rendered by the closest ancestor Router View. Used for\n* `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\n* Location Matched\n*\n* @internal\n*/\nconst matchedRouteKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"router view location matched\" : \"\");\n/**\n* Allows overriding the router view depth to control which component in\n* `matched` is rendered. rvd stands for Router View Depth\n*\n* @internal\n*/\nconst viewDepthKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"router view depth\" : \"\");\n/**\n* Allows overriding the router instance returned by `useRouter` in tests. r\n* stands for router\n*\n* @internal\n*/\nconst routerKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"router\" : \"\");\n/**\n* Allows overriding the current route returned by `useRoute` in tests. rl\n* stands for route location\n*\n* @internal\n*/\nconst routeLocationKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"route location\" : \"\");\n/**\n* Allows overriding the current route used by router-view. Internally this is\n* used when the `route` prop is passed.\n*\n* @internal\n*/\nconst routerViewLocationKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"router view location\" : \"\");\n\n//#endregion\n//#region src/utils/callbacks.ts\n/**\n* Create a list of callbacks that can be reset. Used to create before and after navigation guards list\n*/\nfunction useCallbacks() {\n\tlet handlers = [];\n\tfunction add(handler) {\n\t\thandlers.push(handler);\n\t\treturn () => {\n\t\t\tconst i = handlers.indexOf(handler);\n\t\t\tif (i > -1) handlers.splice(i, 1);\n\t\t};\n\t}\n\tfunction reset() {\n\t\thandlers = [];\n\t}\n\treturn {\n\t\tadd,\n\t\tlist: () => handlers.slice(),\n\t\treset\n\t};\n}\n\n//#endregion\n//#region src/navigationGuards.ts\nfunction registerGuard(record, name, guard) {\n\tconst removeFromList = () => {\n\t\trecord[name].delete(guard);\n\t};\n\tonUnmounted(removeFromList);\n\tonDeactivated(removeFromList);\n\tonActivated(() => {\n\t\trecord[name].add(guard);\n\t});\n\trecord[name].add(guard);\n}\n/**\n* Add a navigation guard that triggers whenever the component for the current\n* location is about to be left. Similar to {@link beforeRouteLeave} but can be\n* used in any component. The guard is removed when the component is unmounted.\n*\n* @param leaveGuard - {@link NavigationGuard}\n*/\nfunction onBeforeRouteLeave(leaveGuard) {\n\tif (process.env.NODE_ENV !== \"production\" && !getCurrentInstance()) {\n\t\twarn$1(\"getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function\");\n\t\treturn;\n\t}\n\tconst activeRecord = inject(matchedRouteKey, {}).value;\n\tif (!activeRecord) {\n\t\tprocess.env.NODE_ENV !== \"production\" && warn$1(\"No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?\");\n\t\treturn;\n\t}\n\tregisterGuard(activeRecord, \"leaveGuards\", leaveGuard);\n}\n/**\n* Add a navigation guard that triggers whenever the current location is about\n* to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\n* component. The guard is removed when the component is unmounted.\n*\n* @param updateGuard - {@link NavigationGuard}\n*/\nfunction onBeforeRouteUpdate(updateGuard) {\n\tif (process.env.NODE_ENV !== \"production\" && !getCurrentInstance()) {\n\t\twarn$1(\"getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function\");\n\t\treturn;\n\t}\n\tconst activeRecord = inject(matchedRouteKey, {}).value;\n\tif (!activeRecord) {\n\t\tprocess.env.NODE_ENV !== \"production\" && warn$1(\"No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?\");\n\t\treturn;\n\t}\n\tregisterGuard(activeRecord, \"updateGuards\", updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn) => fn()) {\n\tconst enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n\treturn () => new Promise((resolve, reject) => {\n\t\tconst next = (valid) => {\n\t\t\tif (valid === false) reject(createRouterError(ErrorTypes.NAVIGATION_ABORTED, {\n\t\t\t\tfrom,\n\t\t\t\tto\n\t\t\t}));\n\t\t\telse if (valid instanceof Error) reject(valid);\n\t\t\telse if (isRouteLocation(valid)) reject(createRouterError(ErrorTypes.NAVIGATION_GUARD_REDIRECT, {\n\t\t\t\tfrom: to,\n\t\t\t\tto: valid\n\t\t\t}));\n\t\t\telse {\n\t\t\t\tif (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === \"function\") enterCallbackArray.push(valid);\n\t\t\t\tresolve();\n\t\t\t}\n\t\t};\n\t\tconst guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, process.env.NODE_ENV !== \"production\" ? canOnlyBeCalledOnce(next, to, from) : next));\n\t\tlet guardCall = Promise.resolve(guardReturn);\n\t\tif (guard.length < 3) guardCall = guardCall.then(next);\n\t\tif (process.env.NODE_ENV !== \"production\" && guard.length > 2) {\n\t\t\tconst message = `The \"next\" callback was never called inside of ${guard.name ? \"\\\"\" + guard.name + \"\\\"\" : \"\"}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\n\t\t\tif (typeof guardReturn === \"object\" && \"then\" in guardReturn) guardCall = guardCall.then((resolvedValue) => {\n\t\t\t\tif (!next._called) {\n\t\t\t\t\twarn$1(message);\n\t\t\t\t\treturn Promise.reject(/* @__PURE__ */ new Error(\"Invalid navigation guard\"));\n\t\t\t\t}\n\t\t\t\treturn resolvedValue;\n\t\t\t});\n\t\t\telse if (guardReturn !== void 0) {\n\t\t\t\tif (!next._called) {\n\t\t\t\t\twarn$1(message);\n\t\t\t\t\treject(/* @__PURE__ */ new Error(\"Invalid navigation guard\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tguardCall.catch((err) => reject(err));\n\t});\n}\nfunction canOnlyBeCalledOnce(next, to, from) {\n\tlet called = 0;\n\treturn function() {\n\t\tif (called++ === 1) warn$1(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\n\t\tnext._called = true;\n\t\tif (called === 1) next.apply(null, arguments);\n\t};\n}\nfunction extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn) => fn()) {\n\tconst guards = [];\n\tfor (const record of matched) {\n\t\tif (process.env.NODE_ENV !== \"production\" && !record.components && record.children && !record.children.length) warn$1(`Record with path \"${record.path}\" is either missing a \"component(s)\" or \"children\" property.`);\n\t\tfor (const name in record.components) {\n\t\t\tlet rawComponent = record.components[name];\n\t\t\tif (process.env.NODE_ENV !== \"production\") {\n\t\t\t\tif (!rawComponent || typeof rawComponent !== \"object\" && typeof rawComponent !== \"function\") {\n\t\t\t\t\twarn$1(`Component \"${name}\" in record with path \"${record.path}\" is not a valid component. Received \"${String(rawComponent)}\".`);\n\t\t\t\t\tthrow new Error(\"Invalid route component\");\n\t\t\t\t} else if (\"then\" in rawComponent) {\n\t\t\t\t\twarn$1(`Component \"${name}\" in record with path \"${record.path}\" is a Promise instead of a function that returns a Promise. Did you write \"import('./MyPage.vue')\" instead of \"() => import('./MyPage.vue')\" ? This will break in production if not fixed.`);\n\t\t\t\t\tconst promise = rawComponent;\n\t\t\t\t\trawComponent = () => promise;\n\t\t\t\t} else if (rawComponent.__asyncLoader && !rawComponent.__warnedDefineAsync) {\n\t\t\t\t\trawComponent.__warnedDefineAsync = true;\n\t\t\t\t\twarn$1(`Component \"${name}\" in record with path \"${record.path}\" is defined using \"defineAsyncComponent()\". Write \"() => import('./MyPage.vue')\" instead of \"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (guardType !== \"beforeRouteEnter\" && !record.instances[name]) continue;\n\t\t\tif (isRouteComponent(rawComponent)) {\n\t\t\t\tconst guard = (rawComponent.__vccOpts || rawComponent)[guardType];\n\t\t\t\tguard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));\n\t\t\t} else {\n\t\t\t\tlet componentPromise = rawComponent();\n\t\t\t\tif (process.env.NODE_ENV !== \"production\" && !(\"catch\" in componentPromise)) {\n\t\t\t\t\twarn$1(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\n\t\t\t\t\tcomponentPromise = Promise.resolve(componentPromise);\n\t\t\t\t}\n\t\t\t\tguards.push(() => componentPromise.then((resolved) => {\n\t\t\t\t\tif (!resolved) throw new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`);\n\t\t\t\t\tconst resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n\t\t\t\t\trecord.mods[name] = resolved;\n\t\t\t\t\trecord.components[name] = resolvedComponent;\n\t\t\t\t\tconst guard = (resolvedComponent.__vccOpts || resolvedComponent)[guardType];\n\t\t\t\t\treturn guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t}\n\treturn guards;\n}\n/**\n* Ensures a route is loaded, so it can be passed as o prop to `<RouterView>`.\n*\n* @param route - resolved route to load\n*/\nfunction loadRouteLocation(route) {\n\treturn route.matched.every((record) => record.redirect) ? Promise.reject(/* @__PURE__ */ new Error(\"Cannot load a route that redirects.\")) : Promise.all(route.matched.map((record) => record.components && Promise.all(Object.keys(record.components).reduce((promises, name) => {\n\t\tconst rawComponent = record.components[name];\n\t\tif (typeof rawComponent === \"function\" && !(\"displayName\" in rawComponent)) promises.push(rawComponent().then((resolved) => {\n\t\t\tif (!resolved) return Promise.reject(/* @__PURE__ */ new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\". Ensure you passed a function that returns a promise.`));\n\t\t\tconst resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n\t\t\trecord.mods[name] = resolved;\n\t\t\trecord.components[name] = resolvedComponent;\n\t\t}));\n\t\treturn promises;\n\t}, [])))).then(() => route);\n}\n/**\n* Split the leaving, updating, and entering records.\n* @internal\n*\n* @param  to - Location we are navigating to\n* @param from - Location we are navigating from\n*/\nfunction extractChangingRecords(to, from) {\n\tconst leavingRecords = [];\n\tconst updatingRecords = [];\n\tconst enteringRecords = [];\n\tconst len = Math.max(from.matched.length, to.matched.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tconst recordFrom = from.matched[i];\n\t\tif (recordFrom) if (to.matched.find((record) => isSameRouteRecord(record, recordFrom))) updatingRecords.push(recordFrom);\n\t\telse leavingRecords.push(recordFrom);\n\t\tconst recordTo = to.matched[i];\n\t\tif (recordTo) {\n\t\t\tif (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) enteringRecords.push(recordTo);\n\t\t}\n\t}\n\treturn [\n\t\tleavingRecords,\n\t\tupdatingRecords,\n\t\tenteringRecords\n\t];\n}\n\n//#endregion\n//#region src/devtools.ts\n/**\n* Copies a route location and removes any problematic properties that cannot be shown in devtools (e.g. Vue instances).\n*\n* @param routeLocation - routeLocation to format\n* @param tooltip - optional tooltip\n* @returns a copy of the routeLocation\n*/\nfunction formatRouteLocation(routeLocation, tooltip) {\n\tconst copy = assign({}, routeLocation, { matched: routeLocation.matched.map((matched) => omit(matched, [\n\t\t\"instances\",\n\t\t\"children\",\n\t\t\"aliasOf\"\n\t])) });\n\treturn { _custom: {\n\t\ttype: null,\n\t\treadOnly: true,\n\t\tdisplay: routeLocation.fullPath,\n\t\ttooltip,\n\t\tvalue: copy\n\t} };\n}\nfunction formatDisplay(display) {\n\treturn { _custom: { display } };\n}\nlet routerId = 0;\nfunction addDevtools(app, router, matcher) {\n\tif (router.__hasDevtools) return;\n\trouter.__hasDevtools = true;\n\tconst id = routerId++;\n\tsetupDevtoolsPlugin({\n\t\tid: \"org.vuejs.router\" + (id ? \".\" + id : \"\"),\n\t\tlabel: \"Vue Router\",\n\t\tpackageName: \"vue-router\",\n\t\thomepage: \"https://router.vuejs.org\",\n\t\tlogo: \"https://router.vuejs.org/logo.png\",\n\t\tcomponentStateTypes: [\"Routing\"],\n\t\tapp\n\t}, (api) => {\n\t\tif (typeof api.now !== \"function\") warn$1(\"[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.\");\n\t\tapi.on.inspectComponent((payload, ctx) => {\n\t\t\tif (payload.instanceData) payload.instanceData.state.push({\n\t\t\t\ttype: \"Routing\",\n\t\t\t\tkey: \"$route\",\n\t\t\t\teditable: false,\n\t\t\t\tvalue: formatRouteLocation(router.currentRoute.value, \"Current Route\")\n\t\t\t});\n\t\t});\n\t\tapi.on.visitComponentTree(({ treeNode: node, componentInstance }) => {\n\t\t\tif (componentInstance.__vrv_devtools) {\n\t\t\t\tconst info = componentInstance.__vrv_devtools;\n\t\t\t\tnode.tags.push({\n\t\t\t\t\tlabel: (info.name ? `${info.name.toString()}: ` : \"\") + info.path,\n\t\t\t\t\ttextColor: 0,\n\t\t\t\t\ttooltip: \"This component is rendered by &lt;router-view&gt;\",\n\t\t\t\t\tbackgroundColor: PINK_500\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (isArray(componentInstance.__vrl_devtools)) {\n\t\t\t\tcomponentInstance.__devtoolsApi = api;\n\t\t\t\tcomponentInstance.__vrl_devtools.forEach((devtoolsData) => {\n\t\t\t\t\tlet label = devtoolsData.route.path;\n\t\t\t\t\tlet backgroundColor = ORANGE_400;\n\t\t\t\t\tlet tooltip = \"\";\n\t\t\t\t\tlet textColor = 0;\n\t\t\t\t\tif (devtoolsData.error) {\n\t\t\t\t\t\tlabel = devtoolsData.error;\n\t\t\t\t\t\tbackgroundColor = RED_100;\n\t\t\t\t\t\ttextColor = RED_700;\n\t\t\t\t\t} else if (devtoolsData.isExactActive) {\n\t\t\t\t\t\tbackgroundColor = LIME_500;\n\t\t\t\t\t\ttooltip = \"This is exactly active\";\n\t\t\t\t\t} else if (devtoolsData.isActive) {\n\t\t\t\t\t\tbackgroundColor = BLUE_600;\n\t\t\t\t\t\ttooltip = \"This link is active\";\n\t\t\t\t\t}\n\t\t\t\t\tnode.tags.push({\n\t\t\t\t\t\tlabel,\n\t\t\t\t\t\ttextColor,\n\t\t\t\t\t\ttooltip,\n\t\t\t\t\t\tbackgroundColor\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\twatch(router.currentRoute, () => {\n\t\t\trefreshRoutesView();\n\t\t\tapi.notifyComponentUpdate();\n\t\t\tapi.sendInspectorTree(routerInspectorId);\n\t\t\tapi.sendInspectorState(routerInspectorId);\n\t\t});\n\t\tconst navigationsLayerId = \"router:navigations:\" + id;\n\t\tapi.addTimelineLayer({\n\t\t\tid: navigationsLayerId,\n\t\t\tlabel: `Router${id ? \" \" + id : \"\"} Navigations`,\n\t\t\tcolor: 4237508\n\t\t});\n\t\trouter.onError((error, to) => {\n\t\t\tapi.addTimelineEvent({\n\t\t\t\tlayerId: navigationsLayerId,\n\t\t\t\tevent: {\n\t\t\t\t\ttitle: \"Error during Navigation\",\n\t\t\t\t\tsubtitle: to.fullPath,\n\t\t\t\t\tlogType: \"error\",\n\t\t\t\t\ttime: api.now(),\n\t\t\t\t\tdata: { error },\n\t\t\t\t\tgroupId: to.meta.__navigationId\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tlet navigationId = 0;\n\t\trouter.beforeEach((to, from) => {\n\t\t\tconst data = {\n\t\t\t\tguard: formatDisplay(\"beforeEach\"),\n\t\t\t\tfrom: formatRouteLocation(from, \"Current Location during this navigation\"),\n\t\t\t\tto: formatRouteLocation(to, \"Target location\")\n\t\t\t};\n\t\t\tObject.defineProperty(to.meta, \"__navigationId\", { value: navigationId++ });\n\t\t\tapi.addTimelineEvent({\n\t\t\t\tlayerId: navigationsLayerId,\n\t\t\t\tevent: {\n\t\t\t\t\ttime: api.now(),\n\t\t\t\t\ttitle: \"Start of navigation\",\n\t\t\t\t\tsubtitle: to.fullPath,\n\t\t\t\t\tdata,\n\t\t\t\t\tgroupId: to.meta.__navigationId\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\trouter.afterEach((to, from, failure) => {\n\t\t\tconst data = { guard: formatDisplay(\"afterEach\") };\n\t\t\tif (failure) {\n\t\t\t\tdata.failure = { _custom: {\n\t\t\t\t\ttype: Error,\n\t\t\t\t\treadOnly: true,\n\t\t\t\t\tdisplay: failure ? failure.message : \"\",\n\t\t\t\t\ttooltip: \"Navigation Failure\",\n\t\t\t\t\tvalue: failure\n\t\t\t\t} };\n\t\t\t\tdata.status = formatDisplay(\"\");\n\t\t\t} else data.status = formatDisplay(\"\");\n\t\t\tdata.from = formatRouteLocation(from, \"Current Location during this navigation\");\n\t\t\tdata.to = formatRouteLocation(to, \"Target location\");\n\t\t\tapi.addTimelineEvent({\n\t\t\t\tlayerId: navigationsLayerId,\n\t\t\t\tevent: {\n\t\t\t\t\ttitle: \"End of navigation\",\n\t\t\t\t\tsubtitle: to.fullPath,\n\t\t\t\t\ttime: api.now(),\n\t\t\t\t\tdata,\n\t\t\t\t\tlogType: failure ? \"warning\" : \"default\",\n\t\t\t\t\tgroupId: to.meta.__navigationId\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t/**\n\t\t* Inspector of Existing routes\n\t\t*/\n\t\tconst routerInspectorId = \"router-inspector:\" + id;\n\t\tapi.addInspector({\n\t\t\tid: routerInspectorId,\n\t\t\tlabel: \"Routes\" + (id ? \" \" + id : \"\"),\n\t\t\ticon: \"book\",\n\t\t\ttreeFilterPlaceholder: \"Search routes\"\n\t\t});\n\t\tfunction refreshRoutesView() {\n\t\t\tif (!activeRoutesPayload) return;\n\t\t\tconst payload = activeRoutesPayload;\n\t\t\tlet routes = matcher.getRoutes().filter((route) => !route.parent || !route.parent.record.components);\n\t\t\troutes.forEach(resetMatchStateOnRouteRecord);\n\t\t\tif (payload.filter) routes = routes.filter((route) => isRouteMatching(route, payload.filter.toLowerCase()));\n\t\t\troutes.forEach((route) => markRouteRecordActive(route, router.currentRoute.value));\n\t\t\tpayload.rootNodes = routes.map(formatRouteRecordForInspector);\n\t\t}\n\t\tlet activeRoutesPayload;\n\t\tapi.on.getInspectorTree((payload) => {\n\t\t\tactiveRoutesPayload = payload;\n\t\t\tif (payload.app === app && payload.inspectorId === routerInspectorId) refreshRoutesView();\n\t\t});\n\t\t/**\n\t\t* Display information about the currently selected route record\n\t\t*/\n\t\tapi.on.getInspectorState((payload) => {\n\t\t\tif (payload.app === app && payload.inspectorId === routerInspectorId) {\n\t\t\t\tconst route = matcher.getRoutes().find((route$1) => route$1.record.__vd_id === payload.nodeId);\n\t\t\t\tif (route) payload.state = { options: formatRouteRecordMatcherForStateInspector(route) };\n\t\t\t}\n\t\t});\n\t\tapi.sendInspectorTree(routerInspectorId);\n\t\tapi.sendInspectorState(routerInspectorId);\n\t});\n}\nfunction modifierForKey(key) {\n\tif (key.optional) return key.repeatable ? \"*\" : \"?\";\n\telse return key.repeatable ? \"+\" : \"\";\n}\nfunction formatRouteRecordMatcherForStateInspector(route) {\n\tconst { record } = route;\n\tconst fields = [{\n\t\teditable: false,\n\t\tkey: \"path\",\n\t\tvalue: record.path\n\t}];\n\tif (record.name != null) fields.push({\n\t\teditable: false,\n\t\tkey: \"name\",\n\t\tvalue: record.name\n\t});\n\tfields.push({\n\t\teditable: false,\n\t\tkey: \"regexp\",\n\t\tvalue: route.re\n\t});\n\tif (route.keys.length) fields.push({\n\t\teditable: false,\n\t\tkey: \"keys\",\n\t\tvalue: { _custom: {\n\t\t\ttype: null,\n\t\t\treadOnly: true,\n\t\t\tdisplay: route.keys.map((key) => `${key.name}${modifierForKey(key)}`).join(\" \"),\n\t\t\ttooltip: \"Param keys\",\n\t\t\tvalue: route.keys\n\t\t} }\n\t});\n\tif (record.redirect != null) fields.push({\n\t\teditable: false,\n\t\tkey: \"redirect\",\n\t\tvalue: record.redirect\n\t});\n\tif (route.alias.length) fields.push({\n\t\teditable: false,\n\t\tkey: \"aliases\",\n\t\tvalue: route.alias.map((alias) => alias.record.path)\n\t});\n\tif (Object.keys(route.record.meta).length) fields.push({\n\t\teditable: false,\n\t\tkey: \"meta\",\n\t\tvalue: route.record.meta\n\t});\n\tfields.push({\n\t\tkey: \"score\",\n\t\teditable: false,\n\t\tvalue: { _custom: {\n\t\t\ttype: null,\n\t\t\treadOnly: true,\n\t\t\tdisplay: route.score.map((score) => score.join(\", \")).join(\" | \"),\n\t\t\ttooltip: \"Score used to sort routes\",\n\t\t\tvalue: route.score\n\t\t} }\n\t});\n\treturn fields;\n}\n/**\n* Extracted from tailwind palette\n*/\nconst PINK_500 = 15485081;\nconst BLUE_600 = 2450411;\nconst LIME_500 = 8702998;\nconst CYAN_400 = 2282478;\nconst ORANGE_400 = 16486972;\nconst DARK = 6710886;\nconst RED_100 = 16704226;\nconst RED_700 = 12131356;\nfunction formatRouteRecordForInspector(route) {\n\tconst tags = [];\n\tconst { record } = route;\n\tif (record.name != null) tags.push({\n\t\tlabel: String(record.name),\n\t\ttextColor: 0,\n\t\tbackgroundColor: CYAN_400\n\t});\n\tif (record.aliasOf) tags.push({\n\t\tlabel: \"alias\",\n\t\ttextColor: 0,\n\t\tbackgroundColor: ORANGE_400\n\t});\n\tif (route.__vd_match) tags.push({\n\t\tlabel: \"matches\",\n\t\ttextColor: 0,\n\t\tbackgroundColor: PINK_500\n\t});\n\tif (route.__vd_exactActive) tags.push({\n\t\tlabel: \"exact\",\n\t\ttextColor: 0,\n\t\tbackgroundColor: LIME_500\n\t});\n\tif (route.__vd_active) tags.push({\n\t\tlabel: \"active\",\n\t\ttextColor: 0,\n\t\tbackgroundColor: BLUE_600\n\t});\n\tif (record.redirect) tags.push({\n\t\tlabel: typeof record.redirect === \"string\" ? `redirect: ${record.redirect}` : \"redirects\",\n\t\ttextColor: 16777215,\n\t\tbackgroundColor: DARK\n\t});\n\tlet id = record.__vd_id;\n\tif (id == null) {\n\t\tid = String(routeRecordId++);\n\t\trecord.__vd_id = id;\n\t}\n\treturn {\n\t\tid,\n\t\tlabel: record.path,\n\t\ttags,\n\t\tchildren: route.children.map(formatRouteRecordForInspector)\n\t};\n}\nlet routeRecordId = 0;\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\nfunction markRouteRecordActive(route, currentRoute) {\n\tconst isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n\troute.__vd_exactActive = route.__vd_active = isExactActive;\n\tif (!isExactActive) route.__vd_active = currentRoute.matched.some((match) => isSameRouteRecord(match, route.record));\n\troute.children.forEach((childRoute) => markRouteRecordActive(childRoute, currentRoute));\n}\nfunction resetMatchStateOnRouteRecord(route) {\n\troute.__vd_match = false;\n\troute.children.forEach(resetMatchStateOnRouteRecord);\n}\nfunction isRouteMatching(route, filter) {\n\tconst found = String(route.re).match(EXTRACT_REGEXP_RE);\n\troute.__vd_match = false;\n\tif (!found || found.length < 3) return false;\n\tif (new RegExp(found[1].replace(/\\$$/, \"\"), found[2]).test(filter)) {\n\t\troute.children.forEach((child) => isRouteMatching(child, filter));\n\t\tif (route.record.path !== \"/\" || filter === \"/\") {\n\t\t\troute.__vd_match = route.re.test(filter);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tconst path = route.record.path.toLowerCase();\n\tconst decodedPath = decode(path);\n\tif (!filter.startsWith(\"/\") && (decodedPath.includes(filter) || path.includes(filter))) return true;\n\tif (decodedPath.startsWith(filter) || path.startsWith(filter)) return true;\n\tif (route.record.name && String(route.record.name).includes(filter)) return true;\n\treturn route.children.some((child) => isRouteMatching(child, filter));\n}\nfunction omit(obj, keys) {\n\tconst ret = {};\n\tfor (const key in obj) if (!keys.includes(key)) ret[key] = obj[key];\n\treturn ret;\n}\n\n//#endregion\nexport { ErrorTypes, NEW_stringifyURL, NavigationDirection, NavigationFailureType, NavigationType, START, START_LOCATION_NORMALIZED, addDevtools, applyToParams, assign, computeScrollPosition, createHref, createRouterError, decode, encodeHash, encodeParam, encodePath, extractChangingRecords, extractComponentsGuards, getSavedScrollPosition, getScrollKey, guardToPromiseFn, identityFn, isArray, isBrowser, isNavigationFailure, isRouteLocation, isRouteName, isSameRouteLocation, isSameRouteLocationParams, isSameRouteRecord, loadRouteLocation, matchedRouteKey, mergeOptions, noop, normalizeBase, normalizeQuery, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, parseURL, resolveRelativePath, routeLocationKey, routerKey, routerViewLocationKey, saveScrollPosition, scrollToPosition, stringifyQuery, stringifyURL, stripBase, useCallbacks, viewDepthKey, warn$1 as warn };","/*!\n * vue-router v4.6.3\n * (c) 2025 Eduardo San Martin Morote\n * @license MIT\n */\nimport { ErrorTypes, NavigationDirection, NavigationFailureType, NavigationType, START, START_LOCATION_NORMALIZED, addDevtools, applyToParams, assign, computeScrollPosition, createHref, createRouterError, decode, encodeHash, encodeParam, extractChangingRecords, extractComponentsGuards, getSavedScrollPosition, getScrollKey, guardToPromiseFn, isArray, isBrowser, isNavigationFailure, isRouteLocation, isRouteName, isSameRouteLocation, isSameRouteLocationParams, isSameRouteRecord, loadRouteLocation, matchedRouteKey, mergeOptions, noop, normalizeBase, normalizeQuery, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, parseURL, routeLocationKey, routerKey, routerViewLocationKey, saveScrollPosition, scrollToPosition, stringifyQuery, stringifyURL, stripBase, useCallbacks, viewDepthKey, warn as warn$1 } from \"./devtools-BLCumUwL.mjs\";\nimport { computed, defineComponent, getCurrentInstance, h, inject, nextTick, provide, reactive, ref, shallowReactive, shallowRef, unref, watch, watchEffect } from \"vue\";\n\n//#region src/history/html5.ts\nlet createBaseLocation = () => location.protocol + \"//\" + location.host;\n/**\n* Creates a normalized history location from a window.location object\n* @param base - The base path\n* @param location - The window.location object\n*/\nfunction createCurrentLocation(base, location$1) {\n\tconst { pathname, search, hash } = location$1;\n\tconst hashPos = base.indexOf(\"#\");\n\tif (hashPos > -1) {\n\t\tlet slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n\t\tlet pathFromHash = hash.slice(slicePos);\n\t\tif (pathFromHash[0] !== \"/\") pathFromHash = \"/\" + pathFromHash;\n\t\treturn stripBase(pathFromHash, \"\");\n\t}\n\treturn stripBase(pathname, base) + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n\tlet listeners = [];\n\tlet teardowns = [];\n\tlet pauseState = null;\n\tconst popStateHandler = ({ state }) => {\n\t\tconst to = createCurrentLocation(base, location);\n\t\tconst from = currentLocation.value;\n\t\tconst fromState = historyState.value;\n\t\tlet delta = 0;\n\t\tif (state) {\n\t\t\tcurrentLocation.value = to;\n\t\t\thistoryState.value = state;\n\t\t\tif (pauseState && pauseState === from) {\n\t\t\t\tpauseState = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdelta = fromState ? state.position - fromState.position : 0;\n\t\t} else replace(to);\n\t\tlisteners.forEach((listener) => {\n\t\t\tlistener(currentLocation.value, from, {\n\t\t\t\tdelta,\n\t\t\t\ttype: NavigationType.pop,\n\t\t\t\tdirection: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown\n\t\t\t});\n\t\t});\n\t};\n\tfunction pauseListeners() {\n\t\tpauseState = currentLocation.value;\n\t}\n\tfunction listen(callback) {\n\t\tlisteners.push(callback);\n\t\tconst teardown = () => {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index > -1) listeners.splice(index, 1);\n\t\t};\n\t\tteardowns.push(teardown);\n\t\treturn teardown;\n\t}\n\tfunction beforeUnloadListener() {\n\t\tif (document.visibilityState === \"hidden\") {\n\t\t\tconst { history: history$1 } = window;\n\t\t\tif (!history$1.state) return;\n\t\t\thistory$1.replaceState(assign({}, history$1.state, { scroll: computeScrollPosition() }), \"\");\n\t\t}\n\t}\n\tfunction destroy() {\n\t\tfor (const teardown of teardowns) teardown();\n\t\tteardowns = [];\n\t\twindow.removeEventListener(\"popstate\", popStateHandler);\n\t\twindow.removeEventListener(\"pagehide\", beforeUnloadListener);\n\t\tdocument.removeEventListener(\"visibilitychange\", beforeUnloadListener);\n\t}\n\twindow.addEventListener(\"popstate\", popStateHandler);\n\twindow.addEventListener(\"pagehide\", beforeUnloadListener);\n\tdocument.addEventListener(\"visibilitychange\", beforeUnloadListener);\n\treturn {\n\t\tpauseListeners,\n\t\tlisten,\n\t\tdestroy\n\t};\n}\n/**\n* Creates a state object\n*/\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n\treturn {\n\t\tback,\n\t\tcurrent,\n\t\tforward,\n\t\treplaced,\n\t\tposition: window.history.length,\n\t\tscroll: computeScroll ? computeScrollPosition() : null\n\t};\n}\nfunction useHistoryStateNavigation(base) {\n\tconst { history: history$1, location: location$1 } = window;\n\tconst currentLocation = { value: createCurrentLocation(base, location$1) };\n\tconst historyState = { value: history$1.state };\n\tif (!historyState.value) changeLocation(currentLocation.value, {\n\t\tback: null,\n\t\tcurrent: currentLocation.value,\n\t\tforward: null,\n\t\tposition: history$1.length - 1,\n\t\treplaced: true,\n\t\tscroll: null\n\t}, true);\n\tfunction changeLocation(to, state, replace$1) {\n\t\t/**\n\t\t* if a base tag is provided, and we are on a normal domain, we have to\n\t\t* respect the provided `base` attribute because pushState() will use it and\n\t\t* potentially erase anything before the `#` like at\n\t\t* https://github.com/vuejs/router/issues/685 where a base of\n\t\t* `/folder/#` but a base of `/` would erase the `/folder/` section. If\n\t\t* there is no host, the `<base>` tag makes no sense and if there isn't a\n\t\t* base tag we can just use everything after the `#`.\n\t\t*/\n\t\tconst hashIndex = base.indexOf(\"#\");\n\t\tconst url = hashIndex > -1 ? (location$1.host && document.querySelector(\"base\") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;\n\t\ttry {\n\t\t\thistory$1[replace$1 ? \"replaceState\" : \"pushState\"](state, \"\", url);\n\t\t\thistoryState.value = state;\n\t\t} catch (err) {\n\t\t\tif (process.env.NODE_ENV !== \"production\") warn$1(\"Error with push/replace State\", err);\n\t\t\telse console.error(err);\n\t\t\tlocation$1[replace$1 ? \"replace\" : \"assign\"](url);\n\t\t}\n\t}\n\tfunction replace(to, data) {\n\t\tchangeLocation(to, assign({}, history$1.state, buildState(historyState.value.back, to, historyState.value.forward, true), data, { position: historyState.value.position }), true);\n\t\tcurrentLocation.value = to;\n\t}\n\tfunction push(to, data) {\n\t\tconst currentState = assign({}, historyState.value, history$1.state, {\n\t\t\tforward: to,\n\t\t\tscroll: computeScrollPosition()\n\t\t});\n\t\tif (process.env.NODE_ENV !== \"production\" && !history$1.state) warn$1(\"history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\nhistory.replaceState(history.state, '', url)\\n\\nYou can find more information at https://router.vuejs.org/guide/migration/#Usage-of-history-state\");\n\t\tchangeLocation(currentState.current, currentState, true);\n\t\tchangeLocation(to, assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data), false);\n\t\tcurrentLocation.value = to;\n\t}\n\treturn {\n\t\tlocation: currentLocation,\n\t\tstate: historyState,\n\t\tpush,\n\t\treplace\n\t};\n}\n/**\n* Creates an HTML5 history. Most common history for single page applications.\n*\n* @param base -\n*/\nfunction createWebHistory(base) {\n\tbase = normalizeBase(base);\n\tconst historyNavigation = useHistoryStateNavigation(base);\n\tconst historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n\tfunction go(delta, triggerListeners = true) {\n\t\tif (!triggerListeners) historyListeners.pauseListeners();\n\t\thistory.go(delta);\n\t}\n\tconst routerHistory = assign({\n\t\tlocation: \"\",\n\t\tbase,\n\t\tgo,\n\t\tcreateHref: createHref.bind(null, base)\n\t}, historyNavigation, historyListeners);\n\tObject.defineProperty(routerHistory, \"location\", {\n\t\tenumerable: true,\n\t\tget: () => historyNavigation.location.value\n\t});\n\tObject.defineProperty(routerHistory, \"state\", {\n\t\tenumerable: true,\n\t\tget: () => historyNavigation.state.value\n\t});\n\treturn routerHistory;\n}\n\n//#endregion\n//#region src/history/memory.ts\n/**\n* Creates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\n* It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\n*\n* @param base - Base applied to all urls, defaults to '/'\n* @returns a history object that can be passed to the router constructor\n*/\nfunction createMemoryHistory(base = \"\") {\n\tlet listeners = [];\n\tlet queue = [[START, {}]];\n\tlet position = 0;\n\tbase = normalizeBase(base);\n\tfunction setLocation(location$1, state = {}) {\n\t\tposition++;\n\t\tif (position !== queue.length) queue.splice(position);\n\t\tqueue.push([location$1, state]);\n\t}\n\tfunction triggerListeners(to, from, { direction, delta }) {\n\t\tconst info = {\n\t\t\tdirection,\n\t\t\tdelta,\n\t\t\ttype: NavigationType.pop\n\t\t};\n\t\tfor (const callback of listeners) callback(to, from, info);\n\t}\n\tconst routerHistory = {\n\t\tlocation: START,\n\t\tstate: {},\n\t\tbase,\n\t\tcreateHref: createHref.bind(null, base),\n\t\treplace(to, state) {\n\t\t\tqueue.splice(position--, 1);\n\t\t\tsetLocation(to, state);\n\t\t},\n\t\tpush(to, state) {\n\t\t\tsetLocation(to, state);\n\t\t},\n\t\tlisten(callback) {\n\t\t\tlisteners.push(callback);\n\t\t\treturn () => {\n\t\t\t\tconst index = listeners.indexOf(callback);\n\t\t\t\tif (index > -1) listeners.splice(index, 1);\n\t\t\t};\n\t\t},\n\t\tdestroy() {\n\t\t\tlisteners = [];\n\t\t\tqueue = [[START, {}]];\n\t\t\tposition = 0;\n\t\t},\n\t\tgo(delta, shouldTrigger = true) {\n\t\t\tconst from = this.location;\n\t\t\tconst direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n\t\t\tposition = Math.max(0, Math.min(position + delta, queue.length - 1));\n\t\t\tif (shouldTrigger) triggerListeners(this.location, from, {\n\t\t\t\tdirection,\n\t\t\t\tdelta\n\t\t\t});\n\t\t}\n\t};\n\tObject.defineProperty(routerHistory, \"location\", {\n\t\tenumerable: true,\n\t\tget: () => queue[position][0]\n\t});\n\tObject.defineProperty(routerHistory, \"state\", {\n\t\tenumerable: true,\n\t\tget: () => queue[position][1]\n\t});\n\treturn routerHistory;\n}\n\n//#endregion\n//#region src/history/hash.ts\n/**\n* Creates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to\n* handle any URL is not possible.\n*\n* @param base - optional base to provide. Defaults to `location.pathname + location.search` If there is a `<base>` tag\n* in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState()\n* calls**, meaning that if you use a `<base>` tag, it's `href` value **has to match this parameter** (ignoring anything\n* after the `#`).\n*\n* @example\n* ```js\n* // at https://example.com/folder\n* createWebHashHistory() // gives a url of `https://example.com/folder#`\n* createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n* // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n* createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n* // you should avoid doing this because it changes the original url and breaks copying urls\n* createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n*\n* // at file:///usr/etc/folder/index.html\n* // for locations with no `host`, the base is ignored\n* createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n* ```\n*/\nfunction createWebHashHistory(base) {\n\tbase = location.host ? base || location.pathname + location.search : \"\";\n\tif (!base.includes(\"#\")) base += \"#\";\n\tif (process.env.NODE_ENV !== \"production\" && !base.endsWith(\"#/\") && !base.endsWith(\"#\")) warn$1(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, \"#\")}\".`);\n\treturn createWebHistory(base);\n}\n\n//#endregion\n//#region src/matcher/pathTokenizer.ts\nlet TokenType = /* @__PURE__ */ function(TokenType$1) {\n\tTokenType$1[TokenType$1[\"Static\"] = 0] = \"Static\";\n\tTokenType$1[TokenType$1[\"Param\"] = 1] = \"Param\";\n\tTokenType$1[TokenType$1[\"Group\"] = 2] = \"Group\";\n\treturn TokenType$1;\n}({});\nvar TokenizerState = /* @__PURE__ */ function(TokenizerState$1) {\n\tTokenizerState$1[TokenizerState$1[\"Static\"] = 0] = \"Static\";\n\tTokenizerState$1[TokenizerState$1[\"Param\"] = 1] = \"Param\";\n\tTokenizerState$1[TokenizerState$1[\"ParamRegExp\"] = 2] = \"ParamRegExp\";\n\tTokenizerState$1[TokenizerState$1[\"ParamRegExpEnd\"] = 3] = \"ParamRegExpEnd\";\n\tTokenizerState$1[TokenizerState$1[\"EscapeNext\"] = 4] = \"EscapeNext\";\n\treturn TokenizerState$1;\n}(TokenizerState || {});\nconst ROOT_TOKEN = {\n\ttype: TokenType.Static,\n\tvalue: \"\"\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\nfunction tokenizePath(path) {\n\tif (!path) return [[]];\n\tif (path === \"/\") return [[ROOT_TOKEN]];\n\tif (!path.startsWith(\"/\")) throw new Error(process.env.NODE_ENV !== \"production\" ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".` : `Invalid path \"${path}\"`);\n\tfunction crash(message) {\n\t\tthrow new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n\t}\n\tlet state = TokenizerState.Static;\n\tlet previousState = state;\n\tconst tokens = [];\n\tlet segment;\n\tfunction finalizeSegment() {\n\t\tif (segment) tokens.push(segment);\n\t\tsegment = [];\n\t}\n\tlet i = 0;\n\tlet char;\n\tlet buffer = \"\";\n\tlet customRe = \"\";\n\tfunction consumeBuffer() {\n\t\tif (!buffer) return;\n\t\tif (state === TokenizerState.Static) segment.push({\n\t\t\ttype: TokenType.Static,\n\t\t\tvalue: buffer\n\t\t});\n\t\telse if (state === TokenizerState.Param || state === TokenizerState.ParamRegExp || state === TokenizerState.ParamRegExpEnd) {\n\t\t\tif (segment.length > 1 && (char === \"*\" || char === \"+\")) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n\t\t\tsegment.push({\n\t\t\t\ttype: TokenType.Param,\n\t\t\t\tvalue: buffer,\n\t\t\t\tregexp: customRe,\n\t\t\t\trepeatable: char === \"*\" || char === \"+\",\n\t\t\t\toptional: char === \"*\" || char === \"?\"\n\t\t\t});\n\t\t} else crash(\"Invalid state to consume buffer\");\n\t\tbuffer = \"\";\n\t}\n\tfunction addCharToBuffer() {\n\t\tbuffer += char;\n\t}\n\twhile (i < path.length) {\n\t\tchar = path[i++];\n\t\tif (char === \"\\\\\" && state !== TokenizerState.ParamRegExp) {\n\t\t\tpreviousState = state;\n\t\t\tstate = TokenizerState.EscapeNext;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (state) {\n\t\t\tcase TokenizerState.Static:\n\t\t\t\tif (char === \"/\") {\n\t\t\t\t\tif (buffer) consumeBuffer();\n\t\t\t\t\tfinalizeSegment();\n\t\t\t\t} else if (char === \":\") {\n\t\t\t\t\tconsumeBuffer();\n\t\t\t\t\tstate = TokenizerState.Param;\n\t\t\t\t} else addCharToBuffer();\n\t\t\t\tbreak;\n\t\t\tcase TokenizerState.EscapeNext:\n\t\t\t\taddCharToBuffer();\n\t\t\t\tstate = previousState;\n\t\t\t\tbreak;\n\t\t\tcase TokenizerState.Param:\n\t\t\t\tif (char === \"(\") state = TokenizerState.ParamRegExp;\n\t\t\t\telse if (VALID_PARAM_RE.test(char)) addCharToBuffer();\n\t\t\t\telse {\n\t\t\t\t\tconsumeBuffer();\n\t\t\t\t\tstate = TokenizerState.Static;\n\t\t\t\t\tif (char !== \"*\" && char !== \"?\" && char !== \"+\") i--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TokenizerState.ParamRegExp:\n\t\t\t\tif (char === \")\") if (customRe[customRe.length - 1] == \"\\\\\") customRe = customRe.slice(0, -1) + char;\n\t\t\t\telse state = TokenizerState.ParamRegExpEnd;\n\t\t\t\telse customRe += char;\n\t\t\t\tbreak;\n\t\t\tcase TokenizerState.ParamRegExpEnd:\n\t\t\t\tconsumeBuffer();\n\t\t\t\tstate = TokenizerState.Static;\n\t\t\t\tif (char !== \"*\" && char !== \"?\" && char !== \"+\") i--;\n\t\t\t\tcustomRe = \"\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcrash(\"Unknown state\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (state === TokenizerState.ParamRegExp) crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n\tconsumeBuffer();\n\tfinalizeSegment();\n\treturn tokens;\n}\n\n//#endregion\n//#region src/matcher/pathParserRanker.ts\nconst BASE_PARAM_PATTERN = \"[^/]+?\";\nconst BASE_PATH_PARSER_OPTIONS = {\n\tsensitive: false,\n\tstrict: false,\n\tstart: true,\n\tend: true\n};\nvar PathScore = /* @__PURE__ */ function(PathScore$1) {\n\tPathScore$1[PathScore$1[\"_multiplier\"] = 10] = \"_multiplier\";\n\tPathScore$1[PathScore$1[\"Root\"] = 90] = \"Root\";\n\tPathScore$1[PathScore$1[\"Segment\"] = 40] = \"Segment\";\n\tPathScore$1[PathScore$1[\"SubSegment\"] = 30] = \"SubSegment\";\n\tPathScore$1[PathScore$1[\"Static\"] = 40] = \"Static\";\n\tPathScore$1[PathScore$1[\"Dynamic\"] = 20] = \"Dynamic\";\n\tPathScore$1[PathScore$1[\"BonusCustomRegExp\"] = 10] = \"BonusCustomRegExp\";\n\tPathScore$1[PathScore$1[\"BonusWildcard\"] = -50] = \"BonusWildcard\";\n\tPathScore$1[PathScore$1[\"BonusRepeatable\"] = -20] = \"BonusRepeatable\";\n\tPathScore$1[PathScore$1[\"BonusOptional\"] = -8] = \"BonusOptional\";\n\tPathScore$1[PathScore$1[\"BonusStrict\"] = .7000000000000001] = \"BonusStrict\";\n\tPathScore$1[PathScore$1[\"BonusCaseSensitive\"] = .25] = \"BonusCaseSensitive\";\n\treturn PathScore$1;\n}(PathScore || {});\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\n* Creates a path parser from an array of Segments (a segment is an array of Tokens)\n*\n* @param segments - array of segments returned by tokenizePath\n* @param extraOptions - optional options for the regexp\n* @returns a PathParser\n*/\nfunction tokensToParser(segments, extraOptions) {\n\tconst options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n\tconst score = [];\n\tlet pattern = options.start ? \"^\" : \"\";\n\tconst keys = [];\n\tfor (const segment of segments) {\n\t\tconst segmentScores = segment.length ? [] : [PathScore.Root];\n\t\tif (options.strict && !segment.length) pattern += \"/\";\n\t\tfor (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n\t\t\tconst token = segment[tokenIndex];\n\t\t\tlet subSegmentScore = PathScore.Segment + (options.sensitive ? PathScore.BonusCaseSensitive : 0);\n\t\t\tif (token.type === TokenType.Static) {\n\t\t\t\tif (!tokenIndex) pattern += \"/\";\n\t\t\t\tpattern += token.value.replace(REGEX_CHARS_RE, \"\\\\$&\");\n\t\t\t\tsubSegmentScore += PathScore.Static;\n\t\t\t} else if (token.type === TokenType.Param) {\n\t\t\t\tconst { value, repeatable, optional, regexp } = token;\n\t\t\t\tkeys.push({\n\t\t\t\t\tname: value,\n\t\t\t\t\trepeatable,\n\t\t\t\t\toptional\n\t\t\t\t});\n\t\t\t\tconst re$1 = regexp ? regexp : BASE_PARAM_PATTERN;\n\t\t\t\tif (re$1 !== BASE_PARAM_PATTERN) {\n\t\t\t\t\tsubSegmentScore += PathScore.BonusCustomRegExp;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t`${re$1}`;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tthrow new Error(`Invalid custom RegExp for param \"${value}\" (${re$1}): ` + err.message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet subPattern = repeatable ? `((?:${re$1})(?:/(?:${re$1}))*)` : `(${re$1})`;\n\t\t\t\tif (!tokenIndex) subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : \"/\" + subPattern;\n\t\t\t\tif (optional) subPattern += \"?\";\n\t\t\t\tpattern += subPattern;\n\t\t\t\tsubSegmentScore += PathScore.Dynamic;\n\t\t\t\tif (optional) subSegmentScore += PathScore.BonusOptional;\n\t\t\t\tif (repeatable) subSegmentScore += PathScore.BonusRepeatable;\n\t\t\t\tif (re$1 === \".*\") subSegmentScore += PathScore.BonusWildcard;\n\t\t\t}\n\t\t\tsegmentScores.push(subSegmentScore);\n\t\t}\n\t\tscore.push(segmentScores);\n\t}\n\tif (options.strict && options.end) {\n\t\tconst i = score.length - 1;\n\t\tscore[i][score[i].length - 1] += PathScore.BonusStrict;\n\t}\n\tif (!options.strict) pattern += \"/?\";\n\tif (options.end) pattern += \"$\";\n\telse if (options.strict && !pattern.endsWith(\"/\")) pattern += \"(?:/|$)\";\n\tconst re = new RegExp(pattern, options.sensitive ? \"\" : \"i\");\n\tfunction parse(path) {\n\t\tconst match = path.match(re);\n\t\tconst params = {};\n\t\tif (!match) return null;\n\t\tfor (let i = 1; i < match.length; i++) {\n\t\t\tconst value = match[i] || \"\";\n\t\t\tconst key = keys[i - 1];\n\t\t\tparams[key.name] = value && key.repeatable ? value.split(\"/\") : value;\n\t\t}\n\t\treturn params;\n\t}\n\tfunction stringify(params) {\n\t\tlet path = \"\";\n\t\tlet avoidDuplicatedSlash = false;\n\t\tfor (const segment of segments) {\n\t\t\tif (!avoidDuplicatedSlash || !path.endsWith(\"/\")) path += \"/\";\n\t\t\tavoidDuplicatedSlash = false;\n\t\t\tfor (const token of segment) if (token.type === TokenType.Static) path += token.value;\n\t\t\telse if (token.type === TokenType.Param) {\n\t\t\t\tconst { value, repeatable, optional } = token;\n\t\t\t\tconst param = value in params ? params[value] : \"\";\n\t\t\t\tif (isArray(param) && !repeatable) throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n\t\t\t\tconst text = isArray(param) ? param.join(\"/\") : param;\n\t\t\t\tif (!text) if (optional) {\n\t\t\t\t\tif (segment.length < 2) if (path.endsWith(\"/\")) path = path.slice(0, -1);\n\t\t\t\t\telse avoidDuplicatedSlash = true;\n\t\t\t\t} else throw new Error(`Missing required param \"${value}\"`);\n\t\t\t\tpath += text;\n\t\t\t}\n\t\t}\n\t\treturn path || \"/\";\n\t}\n\treturn {\n\t\tre,\n\t\tscore,\n\t\tkeys,\n\t\tparse,\n\t\tstringify\n\t};\n}\n/**\n* Compares an array of numbers as used in PathParser.score and returns a\n* number. This function can be used to `sort` an array\n*\n* @param a - first array of numbers\n* @param b - second array of numbers\n* @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n* should be sorted first\n*/\nfunction compareScoreArray(a, b) {\n\tlet i = 0;\n\twhile (i < a.length && i < b.length) {\n\t\tconst diff = b[i] - a[i];\n\t\tif (diff) return diff;\n\t\ti++;\n\t}\n\tif (a.length < b.length) return a.length === 1 && a[0] === PathScore.Static + PathScore.Segment ? -1 : 1;\n\telse if (a.length > b.length) return b.length === 1 && b[0] === PathScore.Static + PathScore.Segment ? 1 : -1;\n\treturn 0;\n}\n/**\n* Compare function that can be used with `sort` to sort an array of PathParser\n*\n* @param a - first PathParser\n* @param b - second PathParser\n* @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n*/\nfunction comparePathParserScore(a, b) {\n\tlet i = 0;\n\tconst aScore = a.score;\n\tconst bScore = b.score;\n\twhile (i < aScore.length && i < bScore.length) {\n\t\tconst comp = compareScoreArray(aScore[i], bScore[i]);\n\t\tif (comp) return comp;\n\t\ti++;\n\t}\n\tif (Math.abs(bScore.length - aScore.length) === 1) {\n\t\tif (isLastScoreNegative(aScore)) return 1;\n\t\tif (isLastScoreNegative(bScore)) return -1;\n\t}\n\treturn bScore.length - aScore.length;\n}\n/**\n* This allows detecting splats at the end of a path: /home/:id(.*)*\n*\n* @param score - score to check\n* @returns true if the last entry is negative\n*/\nfunction isLastScoreNegative(score) {\n\tconst last = score[score.length - 1];\n\treturn score.length > 0 && last[last.length - 1] < 0;\n}\nconst PATH_PARSER_OPTIONS_DEFAULTS = {\n\tstrict: false,\n\tend: true,\n\tsensitive: false\n};\n\n//#endregion\n//#region src/matcher/pathMatcher.ts\nfunction createRouteRecordMatcher(record, parent, options) {\n\tconst parser = tokensToParser(tokenizePath(record.path), options);\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst existingKeys = /* @__PURE__ */ new Set();\n\t\tfor (const key of parser.keys) {\n\t\t\tif (existingKeys.has(key.name)) warn$1(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\n\t\t\texistingKeys.add(key.name);\n\t\t}\n\t}\n\tconst matcher = assign(parser, {\n\t\trecord,\n\t\tparent,\n\t\tchildren: [],\n\t\talias: []\n\t});\n\tif (parent) {\n\t\tif (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);\n\t}\n\treturn matcher;\n}\n\n//#endregion\n//#region src/matcher/index.ts\n/**\n* Creates a Router Matcher.\n*\n* @internal\n* @param routes - array of initial routes\n* @param globalOptions - global route options\n*/\nfunction createRouterMatcher(routes, globalOptions) {\n\tconst matchers = [];\n\tconst matcherMap = /* @__PURE__ */ new Map();\n\tglobalOptions = mergeOptions(PATH_PARSER_OPTIONS_DEFAULTS, globalOptions);\n\tfunction getRecordMatcher(name) {\n\t\treturn matcherMap.get(name);\n\t}\n\tfunction addRoute(record, parent, originalRecord) {\n\t\tconst isRootAdd = !originalRecord;\n\t\tconst mainNormalizedRecord = normalizeRouteRecord(record);\n\t\tif (process.env.NODE_ENV !== \"production\") checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);\n\t\tmainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n\t\tconst options = mergeOptions(globalOptions, record);\n\t\tconst normalizedRecords = [mainNormalizedRecord];\n\t\tif (\"alias\" in record) {\n\t\t\tconst aliases = typeof record.alias === \"string\" ? [record.alias] : record.alias;\n\t\t\tfor (const alias of aliases) normalizedRecords.push(normalizeRouteRecord(assign({}, mainNormalizedRecord, {\n\t\t\t\tcomponents: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,\n\t\t\t\tpath: alias,\n\t\t\t\taliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord\n\t\t\t})));\n\t\t}\n\t\tlet matcher;\n\t\tlet originalMatcher;\n\t\tfor (const normalizedRecord of normalizedRecords) {\n\t\t\tconst { path } = normalizedRecord;\n\t\t\tif (parent && path[0] !== \"/\") {\n\t\t\t\tconst parentPath = parent.record.path;\n\t\t\t\tconst connectingSlash = parentPath[parentPath.length - 1] === \"/\" ? \"\" : \"/\";\n\t\t\t\tnormalizedRecord.path = parent.record.path + (path && connectingSlash + path);\n\t\t\t}\n\t\t\tif (process.env.NODE_ENV !== \"production\" && normalizedRecord.path === \"*\") throw new Error(\"Catch all routes (\\\"*\\\") must now be defined using a param with a custom regexp.\\nSee more at https://router.vuejs.org/guide/migration/#Removed-star-or-catch-all-routes.\");\n\t\t\tmatcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n\t\t\tif (process.env.NODE_ENV !== \"production\" && parent && path[0] === \"/\") checkMissingParamsInAbsolutePath(matcher, parent);\n\t\t\tif (originalRecord) {\n\t\t\t\toriginalRecord.alias.push(matcher);\n\t\t\t\tif (process.env.NODE_ENV !== \"production\") checkSameParams(originalRecord, matcher);\n\t\t\t} else {\n\t\t\t\toriginalMatcher = originalMatcher || matcher;\n\t\t\t\tif (originalMatcher !== matcher) originalMatcher.alias.push(matcher);\n\t\t\t\tif (isRootAdd && record.name && !isAliasRecord(matcher)) {\n\t\t\t\t\tif (process.env.NODE_ENV !== \"production\") checkSameNameAsAncestor(record, parent);\n\t\t\t\t\tremoveRoute(record.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isMatchable(matcher)) insertMatcher(matcher);\n\t\t\tif (mainNormalizedRecord.children) {\n\t\t\t\tconst children = mainNormalizedRecord.children;\n\t\t\t\tfor (let i = 0; i < children.length; i++) addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n\t\t\t}\n\t\t\toriginalRecord = originalRecord || matcher;\n\t\t}\n\t\treturn originalMatcher ? () => {\n\t\t\tremoveRoute(originalMatcher);\n\t\t} : noop;\n\t}\n\tfunction removeRoute(matcherRef) {\n\t\tif (isRouteName(matcherRef)) {\n\t\t\tconst matcher = matcherMap.get(matcherRef);\n\t\t\tif (matcher) {\n\t\t\t\tmatcherMap.delete(matcherRef);\n\t\t\t\tmatchers.splice(matchers.indexOf(matcher), 1);\n\t\t\t\tmatcher.children.forEach(removeRoute);\n\t\t\t\tmatcher.alias.forEach(removeRoute);\n\t\t\t}\n\t\t} else {\n\t\t\tconst index = matchers.indexOf(matcherRef);\n\t\t\tif (index > -1) {\n\t\t\t\tmatchers.splice(index, 1);\n\t\t\t\tif (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);\n\t\t\t\tmatcherRef.children.forEach(removeRoute);\n\t\t\t\tmatcherRef.alias.forEach(removeRoute);\n\t\t\t}\n\t\t}\n\t}\n\tfunction getRoutes() {\n\t\treturn matchers;\n\t}\n\tfunction insertMatcher(matcher) {\n\t\tconst index = findInsertionIndex(matcher, matchers);\n\t\tmatchers.splice(index, 0, matcher);\n\t\tif (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);\n\t}\n\tfunction resolve(location$1, currentLocation) {\n\t\tlet matcher;\n\t\tlet params = {};\n\t\tlet path;\n\t\tlet name;\n\t\tif (\"name\" in location$1 && location$1.name) {\n\t\t\tmatcher = matcherMap.get(location$1.name);\n\t\t\tif (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, { location: location$1 });\n\t\t\tif (process.env.NODE_ENV !== \"production\") {\n\t\t\t\tconst invalidParams = Object.keys(location$1.params || {}).filter((paramName) => !matcher.keys.find((k) => k.name === paramName));\n\t\t\t\tif (invalidParams.length) warn$1(`Discarded invalid param(s) \"${invalidParams.join(\"\\\", \\\"\")}\" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);\n\t\t\t}\n\t\t\tname = matcher.record.name;\n\t\t\tparams = assign(pickParams(currentLocation.params, matcher.keys.filter((k) => !k.optional).concat(matcher.parent ? matcher.parent.keys.filter((k) => k.optional) : []).map((k) => k.name)), location$1.params && pickParams(location$1.params, matcher.keys.map((k) => k.name)));\n\t\t\tpath = matcher.stringify(params);\n\t\t} else if (location$1.path != null) {\n\t\t\tpath = location$1.path;\n\t\t\tif (process.env.NODE_ENV !== \"production\" && !path.startsWith(\"/\")) warn$1(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`);\n\t\t\tmatcher = matchers.find((m) => m.re.test(path));\n\t\t\tif (matcher) {\n\t\t\t\tparams = matcher.parse(path);\n\t\t\t\tname = matcher.record.name;\n\t\t\t}\n\t\t} else {\n\t\t\tmatcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));\n\t\t\tif (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, {\n\t\t\t\tlocation: location$1,\n\t\t\t\tcurrentLocation\n\t\t\t});\n\t\t\tname = matcher.record.name;\n\t\t\tparams = assign({}, currentLocation.params, location$1.params);\n\t\t\tpath = matcher.stringify(params);\n\t\t}\n\t\tconst matched = [];\n\t\tlet parentMatcher = matcher;\n\t\twhile (parentMatcher) {\n\t\t\tmatched.unshift(parentMatcher.record);\n\t\t\tparentMatcher = parentMatcher.parent;\n\t\t}\n\t\treturn {\n\t\t\tname,\n\t\t\tpath,\n\t\t\tparams,\n\t\t\tmatched,\n\t\t\tmeta: mergeMetaFields(matched)\n\t\t};\n\t}\n\troutes.forEach((route) => addRoute(route));\n\tfunction clearRoutes() {\n\t\tmatchers.length = 0;\n\t\tmatcherMap.clear();\n\t}\n\treturn {\n\t\taddRoute,\n\t\tresolve,\n\t\tremoveRoute,\n\t\tclearRoutes,\n\t\tgetRoutes,\n\t\tgetRecordMatcher\n\t};\n}\n/**\n* Picks an object param to contain only specified keys.\n*\n* @param params - params object to pick from\n* @param keys - keys to pick\n*/\nfunction pickParams(params, keys) {\n\tconst newParams = {};\n\tfor (const key of keys) if (key in params) newParams[key] = params[key];\n\treturn newParams;\n}\n/**\n* Normalizes a RouteRecordRaw. Creates a copy\n*\n* @param record\n* @returns the normalized version\n*/\nfunction normalizeRouteRecord(record) {\n\tconst normalized = {\n\t\tpath: record.path,\n\t\tredirect: record.redirect,\n\t\tname: record.name,\n\t\tmeta: record.meta || {},\n\t\taliasOf: record.aliasOf,\n\t\tbeforeEnter: record.beforeEnter,\n\t\tprops: normalizeRecordProps(record),\n\t\tchildren: record.children || [],\n\t\tinstances: {},\n\t\tleaveGuards: /* @__PURE__ */ new Set(),\n\t\tupdateGuards: /* @__PURE__ */ new Set(),\n\t\tenterCallbacks: {},\n\t\tcomponents: \"components\" in record ? record.components || null : record.component && { default: record.component }\n\t};\n\tObject.defineProperty(normalized, \"mods\", { value: {} });\n\treturn normalized;\n}\n/**\n* Normalize the optional `props` in a record to always be an object similar to\n* components. Also accept a boolean for components.\n* @param record\n*/\nfunction normalizeRecordProps(record) {\n\tconst propsObject = {};\n\tconst props = record.props || false;\n\tif (\"component\" in record) propsObject.default = props;\n\telse for (const name in record.components) propsObject[name] = typeof props === \"object\" ? props[name] : props;\n\treturn propsObject;\n}\n/**\n* Checks if a record or any of its parent is an alias\n* @param record\n*/\nfunction isAliasRecord(record) {\n\twhile (record) {\n\t\tif (record.record.aliasOf) return true;\n\t\trecord = record.parent;\n\t}\n\treturn false;\n}\n/**\n* Merge meta fields of an array of records\n*\n* @param matched - array of matched records\n*/\nfunction mergeMetaFields(matched) {\n\treturn matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction isSameParam(a, b) {\n\treturn a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;\n}\n/**\n* Check if a path and its alias have the same required params\n*\n* @param a - original record\n* @param b - alias record\n*/\nfunction checkSameParams(a, b) {\n\tfor (const key of a.keys) if (!key.optional && !b.keys.find(isSameParam.bind(null, key))) return warn$1(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n\tfor (const key of b.keys) if (!key.optional && !a.keys.find(isSameParam.bind(null, key))) return warn$1(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" must have the exact same param named \"${key.name}\"`);\n}\n/**\n* A route with a name and a child with an empty path without a name should warn when adding the route\n*\n* @param mainNormalizedRecord - RouteRecordNormalized\n* @param parent - RouteRecordMatcher\n*/\nfunction checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {\n\tif (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path) warn$1(`The route named \"${String(parent.record.name)}\" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);\n}\nfunction checkSameNameAsAncestor(record, parent) {\n\tfor (let ancestor = parent; ancestor; ancestor = ancestor.parent) if (ancestor.record.name === record.name) throw new Error(`A route named \"${String(record.name)}\" has been added as a ${parent === ancestor ? \"child\" : \"descendant\"} of a route with the same name. Route names must be unique and a nested route cannot use the same name as an ancestor.`);\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n\tfor (const key of parent.keys) if (!record.keys.find(isSameParam.bind(null, key))) return warn$1(`Absolute path \"${record.record.path}\" must have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n}\n/**\n* Performs a binary search to find the correct insertion index for a new matcher.\n*\n* Matchers are primarily sorted by their score. If scores are tied then we also consider parent/child relationships,\n* with descendants coming before ancestors. If there's still a tie, new routes are inserted after existing routes.\n*\n* @param matcher - new matcher to be inserted\n* @param matchers - existing matchers\n*/\nfunction findInsertionIndex(matcher, matchers) {\n\tlet lower = 0;\n\tlet upper = matchers.length;\n\twhile (lower !== upper) {\n\t\tconst mid = lower + upper >> 1;\n\t\tif (comparePathParserScore(matcher, matchers[mid]) < 0) upper = mid;\n\t\telse lower = mid + 1;\n\t}\n\tconst insertionAncestor = getInsertionAncestor(matcher);\n\tif (insertionAncestor) {\n\t\tupper = matchers.lastIndexOf(insertionAncestor, upper - 1);\n\t\tif (process.env.NODE_ENV !== \"production\" && upper < 0) warn$1(`Finding ancestor route \"${insertionAncestor.record.path}\" failed for \"${matcher.record.path}\"`);\n\t}\n\treturn upper;\n}\nfunction getInsertionAncestor(matcher) {\n\tlet ancestor = matcher;\n\twhile (ancestor = ancestor.parent) if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) return ancestor;\n}\n/**\n* Checks if a matcher can be reachable. This means if it's possible to reach it as a route. For example, routes without\n* a component, or name, or redirect, are just used to group other routes.\n* @param matcher\n* @param matcher.record record of the matcher\n* @returns\n*/\nfunction isMatchable({ record }) {\n\treturn !!(record.name || record.components && Object.keys(record.components).length || record.redirect);\n}\n\n//#endregion\n//#region src/RouterLink.ts\n/**\n* Returns the internal behavior of a {@link RouterLink} without the rendering part.\n*\n* @param props - a `to` location and an optional `replace` flag\n*/\nfunction useLink(props) {\n\tconst router = inject(routerKey);\n\tconst currentRoute = inject(routeLocationKey);\n\tlet hasPrevious = false;\n\tlet previousTo = null;\n\tconst route = computed(() => {\n\t\tconst to = unref(props.to);\n\t\tif (process.env.NODE_ENV !== \"production\" && (!hasPrevious || to !== previousTo)) {\n\t\t\tif (!isRouteLocation(to)) if (hasPrevious) warn$1(`Invalid value for prop \"to\" in useLink()\\n- to:`, to, `\\n- previous to:`, previousTo, `\\n- props:`, props);\n\t\t\telse warn$1(`Invalid value for prop \"to\" in useLink()\\n- to:`, to, `\\n- props:`, props);\n\t\t\tpreviousTo = to;\n\t\t\thasPrevious = true;\n\t\t}\n\t\treturn router.resolve(to);\n\t});\n\tconst activeRecordIndex = computed(() => {\n\t\tconst { matched } = route.value;\n\t\tconst { length } = matched;\n\t\tconst routeMatched = matched[length - 1];\n\t\tconst currentMatched = currentRoute.matched;\n\t\tif (!routeMatched || !currentMatched.length) return -1;\n\t\tconst index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n\t\tif (index > -1) return index;\n\t\tconst parentRecordPath = getOriginalPath(matched[length - 2]);\n\t\treturn length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;\n\t});\n\tconst isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));\n\tconst isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));\n\tfunction navigate(e = {}) {\n\t\tif (guardEvent(e)) {\n\t\t\tconst p = router[unref(props.replace) ? \"replace\" : \"push\"](unref(props.to)).catch(noop);\n\t\t\tif (props.viewTransition && typeof document !== \"undefined\" && \"startViewTransition\" in document) document.startViewTransition(() => p);\n\t\t\treturn p;\n\t\t}\n\t\treturn Promise.resolve();\n\t}\n\tif ((process.env.NODE_ENV !== \"production\" || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n\t\tconst instance = getCurrentInstance();\n\t\tif (instance) {\n\t\t\tconst linkContextDevtools = {\n\t\t\t\troute: route.value,\n\t\t\t\tisActive: isActive.value,\n\t\t\t\tisExactActive: isExactActive.value,\n\t\t\t\terror: null\n\t\t\t};\n\t\t\tinstance.__vrl_devtools = instance.__vrl_devtools || [];\n\t\t\tinstance.__vrl_devtools.push(linkContextDevtools);\n\t\t\twatchEffect(() => {\n\t\t\t\tlinkContextDevtools.route = route.value;\n\t\t\t\tlinkContextDevtools.isActive = isActive.value;\n\t\t\t\tlinkContextDevtools.isExactActive = isExactActive.value;\n\t\t\t\tlinkContextDevtools.error = isRouteLocation(unref(props.to)) ? null : \"Invalid \\\"to\\\" value\";\n\t\t\t}, { flush: \"post\" });\n\t\t}\n\t}\n\t/**\n\t* NOTE: update {@link _RouterLinkI}'s `$slots` type when updating this\n\t*/\n\treturn {\n\t\troute,\n\t\thref: computed(() => route.value.href),\n\t\tisActive,\n\t\tisExactActive,\n\t\tnavigate\n\t};\n}\nfunction preferSingleVNode(vnodes) {\n\treturn vnodes.length === 1 ? vnodes[0] : vnodes;\n}\nconst RouterLinkImpl = /* @__PURE__ */ defineComponent({\n\tname: \"RouterLink\",\n\tcompatConfig: { MODE: 3 },\n\tprops: {\n\t\tto: {\n\t\t\ttype: [String, Object],\n\t\t\trequired: true\n\t\t},\n\t\treplace: Boolean,\n\t\tactiveClass: String,\n\t\texactActiveClass: String,\n\t\tcustom: Boolean,\n\t\tariaCurrentValue: {\n\t\t\ttype: String,\n\t\t\tdefault: \"page\"\n\t\t},\n\t\tviewTransition: Boolean\n\t},\n\tuseLink,\n\tsetup(props, { slots }) {\n\t\tconst link = reactive(useLink(props));\n\t\tconst { options } = inject(routerKey);\n\t\tconst elClass = computed(() => ({\n\t\t\t[getLinkClass(props.activeClass, options.linkActiveClass, \"router-link-active\")]: link.isActive,\n\t\t\t[getLinkClass(props.exactActiveClass, options.linkExactActiveClass, \"router-link-exact-active\")]: link.isExactActive\n\t\t}));\n\t\treturn () => {\n\t\t\tconst children = slots.default && preferSingleVNode(slots.default(link));\n\t\t\treturn props.custom ? children : h(\"a\", {\n\t\t\t\t\"aria-current\": link.isExactActive ? props.ariaCurrentValue : null,\n\t\t\t\thref: link.href,\n\t\t\t\tonClick: link.navigate,\n\t\t\t\tclass: elClass.value\n\t\t\t}, children);\n\t\t};\n\t}\n});\n/**\n* Component to render a link that triggers a navigation on click.\n*/\nconst RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n\tif (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;\n\tif (e.defaultPrevented) return;\n\tif (e.button !== void 0 && e.button !== 0) return;\n\tif (e.currentTarget && e.currentTarget.getAttribute) {\n\t\tconst target = e.currentTarget.getAttribute(\"target\");\n\t\tif (/\\b_blank\\b/i.test(target)) return;\n\t}\n\tif (e.preventDefault) e.preventDefault();\n\treturn true;\n}\nfunction includesParams(outer, inner) {\n\tfor (const key in inner) {\n\t\tconst innerValue = inner[key];\n\t\tconst outerValue = outer[key];\n\t\tif (typeof innerValue === \"string\") {\n\t\t\tif (innerValue !== outerValue) return false;\n\t\t} else if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i])) return false;\n\t}\n\treturn true;\n}\n/**\n* Get the original path value of a record by following its aliasOf\n* @param record\n*/\nfunction getOriginalPath(record) {\n\treturn record ? record.aliasOf ? record.aliasOf.path : record.path : \"\";\n}\n/**\n* Utility class to get the active class based on defaults.\n* @param propClass\n* @param globalClass\n* @param defaultClass\n*/\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;\n\n//#endregion\n//#region src/RouterView.ts\nconst RouterViewImpl = /* @__PURE__ */ defineComponent({\n\tname: \"RouterView\",\n\tinheritAttrs: false,\n\tprops: {\n\t\tname: {\n\t\t\ttype: String,\n\t\t\tdefault: \"default\"\n\t\t},\n\t\troute: Object\n\t},\n\tcompatConfig: { MODE: 3 },\n\tsetup(props, { attrs, slots }) {\n\t\tprocess.env.NODE_ENV !== \"production\" && warnDeprecatedUsage();\n\t\tconst injectedRoute = inject(routerViewLocationKey);\n\t\tconst routeToDisplay = computed(() => props.route || injectedRoute.value);\n\t\tconst injectedDepth = inject(viewDepthKey, 0);\n\t\tconst depth = computed(() => {\n\t\t\tlet initialDepth = unref(injectedDepth);\n\t\t\tconst { matched } = routeToDisplay.value;\n\t\t\tlet matchedRoute;\n\t\t\twhile ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) initialDepth++;\n\t\t\treturn initialDepth;\n\t\t});\n\t\tconst matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);\n\t\tprovide(viewDepthKey, computed(() => depth.value + 1));\n\t\tprovide(matchedRouteKey, matchedRouteRef);\n\t\tprovide(routerViewLocationKey, routeToDisplay);\n\t\tconst viewRef = ref();\n\t\twatch(() => [\n\t\t\tviewRef.value,\n\t\t\tmatchedRouteRef.value,\n\t\t\tprops.name\n\t\t], ([instance, to, name], [oldInstance, from, oldName]) => {\n\t\t\tif (to) {\n\t\t\t\tto.instances[name] = instance;\n\t\t\t\tif (from && from !== to && instance && instance === oldInstance) {\n\t\t\t\t\tif (!to.leaveGuards.size) to.leaveGuards = from.leaveGuards;\n\t\t\t\t\tif (!to.updateGuards.size) to.updateGuards = from.updateGuards;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));\n\t\t}, { flush: \"post\" });\n\t\treturn () => {\n\t\t\tconst route = routeToDisplay.value;\n\t\t\tconst currentName = props.name;\n\t\t\tconst matchedRoute = matchedRouteRef.value;\n\t\t\tconst ViewComponent = matchedRoute && matchedRoute.components[currentName];\n\t\t\tif (!ViewComponent) return normalizeSlot(slots.default, {\n\t\t\t\tComponent: ViewComponent,\n\t\t\t\troute\n\t\t\t});\n\t\t\tconst routePropsOption = matchedRoute.props[currentName];\n\t\t\tconst routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === \"function\" ? routePropsOption(route) : routePropsOption : null;\n\t\t\tconst onVnodeUnmounted = (vnode) => {\n\t\t\t\tif (vnode.component.isUnmounted) matchedRoute.instances[currentName] = null;\n\t\t\t};\n\t\t\tconst component = h(ViewComponent, assign({}, routeProps, attrs, {\n\t\t\t\tonVnodeUnmounted,\n\t\t\t\tref: viewRef\n\t\t\t}));\n\t\t\tif ((process.env.NODE_ENV !== \"production\" || __VUE_PROD_DEVTOOLS__) && isBrowser && component.ref) {\n\t\t\t\tconst info = {\n\t\t\t\t\tdepth: depth.value,\n\t\t\t\t\tname: matchedRoute.name,\n\t\t\t\t\tpath: matchedRoute.path,\n\t\t\t\t\tmeta: matchedRoute.meta\n\t\t\t\t};\n\t\t\t\t(isArray(component.ref) ? component.ref.map((r) => r.i) : [component.ref.i]).forEach((instance) => {\n\t\t\t\t\tinstance.__vrv_devtools = info;\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn normalizeSlot(slots.default, {\n\t\t\t\tComponent: component,\n\t\t\t\troute\n\t\t\t}) || component;\n\t\t};\n\t}\n});\nfunction normalizeSlot(slot, data) {\n\tif (!slot) return null;\n\tconst slotContent = slot(data);\n\treturn slotContent.length === 1 ? slotContent[0] : slotContent;\n}\n/**\n* Component to display the current route the user is at.\n*/\nconst RouterView = RouterViewImpl;\nfunction warnDeprecatedUsage() {\n\tconst instance = getCurrentInstance();\n\tconst parentName = instance.parent && instance.parent.type.name;\n\tconst parentSubTreeType = instance.parent && instance.parent.subTree && instance.parent.subTree.type;\n\tif (parentName && (parentName === \"KeepAlive\" || parentName.includes(\"Transition\")) && typeof parentSubTreeType === \"object\" && parentSubTreeType.name === \"RouterView\") {\n\t\tconst comp = parentName === \"KeepAlive\" ? \"keep-alive\" : \"transition\";\n\t\twarn$1(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\nUse slot props instead:\n\n<router-view v-slot=\"{ Component }\">\n  <${comp}>\\n    <component :is=\"Component\" />\\n  </${comp}>\\n</router-view>`);\n\t}\n}\n\n//#endregion\n//#region src/router.ts\n/**\n* Creates a Router instance that can be used by a Vue app.\n*\n* @param options - {@link RouterOptions}\n*/\nfunction createRouter(options) {\n\tconst matcher = createRouterMatcher(options.routes, options);\n\tconst parseQuery$1 = options.parseQuery || parseQuery;\n\tconst stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n\tconst routerHistory = options.history;\n\tif (process.env.NODE_ENV !== \"production\" && !routerHistory) throw new Error(\"Provide the \\\"history\\\" option when calling \\\"createRouter()\\\": https://router.vuejs.org/api/interfaces/RouterOptions.html#history\");\n\tconst beforeGuards = useCallbacks();\n\tconst beforeResolveGuards = useCallbacks();\n\tconst afterGuards = useCallbacks();\n\tconst currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n\tlet pendingLocation = START_LOCATION_NORMALIZED;\n\tif (isBrowser && options.scrollBehavior && \"scrollRestoration\" in history) history.scrollRestoration = \"manual\";\n\tconst normalizeParams = applyToParams.bind(null, (paramValue) => \"\" + paramValue);\n\tconst encodeParams = applyToParams.bind(null, encodeParam);\n\tconst decodeParams = applyToParams.bind(null, decode);\n\tfunction addRoute(parentOrRoute, route) {\n\t\tlet parent;\n\t\tlet record;\n\t\tif (isRouteName(parentOrRoute)) {\n\t\t\tparent = matcher.getRecordMatcher(parentOrRoute);\n\t\t\tif (process.env.NODE_ENV !== \"production\" && !parent) warn$1(`Parent route \"${String(parentOrRoute)}\" not found when adding child route`, route);\n\t\t\trecord = route;\n\t\t} else record = parentOrRoute;\n\t\treturn matcher.addRoute(record, parent);\n\t}\n\tfunction removeRoute(name) {\n\t\tconst recordMatcher = matcher.getRecordMatcher(name);\n\t\tif (recordMatcher) matcher.removeRoute(recordMatcher);\n\t\telse if (process.env.NODE_ENV !== \"production\") warn$1(`Cannot remove non-existent route \"${String(name)}\"`);\n\t}\n\tfunction getRoutes() {\n\t\treturn matcher.getRoutes().map((routeMatcher) => routeMatcher.record);\n\t}\n\tfunction hasRoute(name) {\n\t\treturn !!matcher.getRecordMatcher(name);\n\t}\n\tfunction resolve(rawLocation, currentLocation) {\n\t\tcurrentLocation = assign({}, currentLocation || currentRoute.value);\n\t\tif (typeof rawLocation === \"string\") {\n\t\t\tconst locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n\t\t\tconst matchedRoute$1 = matcher.resolve({ path: locationNormalized.path }, currentLocation);\n\t\t\tconst href$1 = routerHistory.createHref(locationNormalized.fullPath);\n\t\t\tif (process.env.NODE_ENV !== \"production\") {\n\t\t\t\tif (href$1.startsWith(\"//\")) warn$1(`Location \"${rawLocation}\" resolved to \"${href$1}\". A resolved location cannot start with multiple slashes.`);\n\t\t\t\telse if (!matchedRoute$1.matched.length) warn$1(`No match found for location with path \"${rawLocation}\"`);\n\t\t\t}\n\t\t\treturn assign(locationNormalized, matchedRoute$1, {\n\t\t\t\tparams: decodeParams(matchedRoute$1.params),\n\t\t\t\thash: decode(locationNormalized.hash),\n\t\t\t\tredirectedFrom: void 0,\n\t\t\t\thref: href$1\n\t\t\t});\n\t\t}\n\t\tif (process.env.NODE_ENV !== \"production\" && !isRouteLocation(rawLocation)) {\n\t\t\twarn$1(`router.resolve() was passed an invalid location. This will fail in production.\\n- Location:`, rawLocation);\n\t\t\treturn resolve({});\n\t\t}\n\t\tlet matcherLocation;\n\t\tif (rawLocation.path != null) {\n\t\t\tif (process.env.NODE_ENV !== \"production\" && \"params\" in rawLocation && !(\"name\" in rawLocation) && Object.keys(rawLocation.params).length) warn$1(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\n\t\t\tmatcherLocation = assign({}, rawLocation, { path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path });\n\t\t} else {\n\t\t\tconst targetParams = assign({}, rawLocation.params);\n\t\t\tfor (const key in targetParams) if (targetParams[key] == null) delete targetParams[key];\n\t\t\tmatcherLocation = assign({}, rawLocation, { params: encodeParams(targetParams) });\n\t\t\tcurrentLocation.params = encodeParams(currentLocation.params);\n\t\t}\n\t\tconst matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n\t\tconst hash = rawLocation.hash || \"\";\n\t\tif (process.env.NODE_ENV !== \"production\" && hash && !hash.startsWith(\"#\")) warn$1(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\n\t\tmatchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n\t\tconst fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n\t\t\thash: encodeHash(hash),\n\t\t\tpath: matchedRoute.path\n\t\t}));\n\t\tconst href = routerHistory.createHref(fullPath);\n\t\tif (process.env.NODE_ENV !== \"production\") {\n\t\t\tif (href.startsWith(\"//\")) warn$1(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n\t\t\telse if (!matchedRoute.matched.length) warn$1(`No match found for location with path \"${rawLocation.path != null ? rawLocation.path : rawLocation}\"`);\n\t\t}\n\t\treturn assign({\n\t\t\tfullPath,\n\t\t\thash,\n\t\t\tquery: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}\n\t\t}, matchedRoute, {\n\t\t\tredirectedFrom: void 0,\n\t\t\thref\n\t\t});\n\t}\n\tfunction locationAsObject(to) {\n\t\treturn typeof to === \"string\" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);\n\t}\n\tfunction checkCanceledNavigation(to, from) {\n\t\tif (pendingLocation !== to) return createRouterError(ErrorTypes.NAVIGATION_CANCELLED, {\n\t\t\tfrom,\n\t\t\tto\n\t\t});\n\t}\n\tfunction push(to) {\n\t\treturn pushWithRedirect(to);\n\t}\n\tfunction replace(to) {\n\t\treturn push(assign(locationAsObject(to), { replace: true }));\n\t}\n\tfunction handleRedirectRecord(to, from) {\n\t\tconst lastMatched = to.matched[to.matched.length - 1];\n\t\tif (lastMatched && lastMatched.redirect) {\n\t\t\tconst { redirect } = lastMatched;\n\t\t\tlet newTargetLocation = typeof redirect === \"function\" ? redirect(to, from) : redirect;\n\t\t\tif (typeof newTargetLocation === \"string\") {\n\t\t\t\tnewTargetLocation = newTargetLocation.includes(\"?\") || newTargetLocation.includes(\"#\") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };\n\t\t\t\tnewTargetLocation.params = {};\n\t\t\t}\n\t\t\tif (process.env.NODE_ENV !== \"production\" && newTargetLocation.path == null && !(\"name\" in newTargetLocation)) {\n\t\t\t\twarn$1(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\n\t\t\t\tthrow new Error(\"Invalid redirect\");\n\t\t\t}\n\t\t\treturn assign({\n\t\t\t\tquery: to.query,\n\t\t\t\thash: to.hash,\n\t\t\t\tparams: newTargetLocation.path != null ? {} : to.params\n\t\t\t}, newTargetLocation);\n\t\t}\n\t}\n\tfunction pushWithRedirect(to, redirectedFrom) {\n\t\tconst targetLocation = pendingLocation = resolve(to);\n\t\tconst from = currentRoute.value;\n\t\tconst data = to.state;\n\t\tconst force = to.force;\n\t\tconst replace$1 = to.replace === true;\n\t\tconst shouldRedirect = handleRedirectRecord(targetLocation, from);\n\t\tif (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\n\t\t\tstate: typeof shouldRedirect === \"object\" ? assign({}, data, shouldRedirect.state) : data,\n\t\t\tforce,\n\t\t\treplace: replace$1\n\t\t}), redirectedFrom || targetLocation);\n\t\tconst toLocation = targetLocation;\n\t\ttoLocation.redirectedFrom = redirectedFrom;\n\t\tlet failure;\n\t\tif (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n\t\t\tfailure = createRouterError(ErrorTypes.NAVIGATION_DUPLICATED, {\n\t\t\t\tto: toLocation,\n\t\t\t\tfrom\n\t\t\t});\n\t\t\thandleScroll(from, from, true, false);\n\t\t}\n\t\treturn (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure$1) => {\n\t\t\tif (failure$1) {\n\t\t\t\tif (isNavigationFailure(failure$1, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {\n\t\t\t\t\tif (process.env.NODE_ENV !== \"production\" && isSameRouteLocation(stringifyQuery$1, resolve(failure$1.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 30) {\n\t\t\t\t\t\twarn$1(`Detected a possibly infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow.\\n Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`);\n\t\t\t\t\t\treturn Promise.reject(/* @__PURE__ */ new Error(\"Infinite redirect in navigation guard\"));\n\t\t\t\t\t}\n\t\t\t\t\treturn pushWithRedirect(assign({ replace: replace$1 }, locationAsObject(failure$1.to), {\n\t\t\t\t\t\tstate: typeof failure$1.to === \"object\" ? assign({}, data, failure$1.to.state) : data,\n\t\t\t\t\t\tforce\n\t\t\t\t\t}), redirectedFrom || toLocation);\n\t\t\t\t}\n\t\t\t} else failure$1 = finalizeNavigation(toLocation, from, true, replace$1, data);\n\t\t\ttriggerAfterEach(toLocation, from, failure$1);\n\t\t\treturn failure$1;\n\t\t});\n\t}\n\t/**\n\t* Helper to reject and skip all navigation guards if a new navigation happened\n\t* @param to\n\t* @param from\n\t*/\n\tfunction checkCanceledNavigationAndReject(to, from) {\n\t\tconst error = checkCanceledNavigation(to, from);\n\t\treturn error ? Promise.reject(error) : Promise.resolve();\n\t}\n\tfunction runWithContext(fn) {\n\t\tconst app = installedApps.values().next().value;\n\t\treturn app && typeof app.runWithContext === \"function\" ? app.runWithContext(fn) : fn();\n\t}\n\tfunction navigate(to, from) {\n\t\tlet guards;\n\t\tconst [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n\t\tguards = extractComponentsGuards(leavingRecords.reverse(), \"beforeRouteLeave\", to, from);\n\t\tfor (const record of leavingRecords) record.leaveGuards.forEach((guard) => {\n\t\t\tguards.push(guardToPromiseFn(guard, to, from));\n\t\t});\n\t\tconst canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n\t\tguards.push(canceledNavigationCheck);\n\t\treturn runGuardQueue(guards).then(() => {\n\t\t\tguards = [];\n\t\t\tfor (const guard of beforeGuards.list()) guards.push(guardToPromiseFn(guard, to, from));\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).then(() => {\n\t\t\tguards = extractComponentsGuards(updatingRecords, \"beforeRouteUpdate\", to, from);\n\t\t\tfor (const record of updatingRecords) record.updateGuards.forEach((guard) => {\n\t\t\t\tguards.push(guardToPromiseFn(guard, to, from));\n\t\t\t});\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).then(() => {\n\t\t\tguards = [];\n\t\t\tfor (const record of enteringRecords) if (record.beforeEnter) if (isArray(record.beforeEnter)) for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to, from));\n\t\t\telse guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).then(() => {\n\t\t\tto.matched.forEach((record) => record.enterCallbacks = {});\n\t\t\tguards = extractComponentsGuards(enteringRecords, \"beforeRouteEnter\", to, from, runWithContext);\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).then(() => {\n\t\t\tguards = [];\n\t\t\tfor (const guard of beforeResolveGuards.list()) guards.push(guardToPromiseFn(guard, to, from));\n\t\t\tguards.push(canceledNavigationCheck);\n\t\t\treturn runGuardQueue(guards);\n\t\t}).catch((err) => isNavigationFailure(err, ErrorTypes.NAVIGATION_CANCELLED) ? err : Promise.reject(err));\n\t}\n\tfunction triggerAfterEach(to, from, failure) {\n\t\tafterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));\n\t}\n\t/**\n\t* - Cleans up any navigation guards\n\t* - Changes the url if necessary\n\t* - Calls the scrollBehavior\n\t*/\n\tfunction finalizeNavigation(toLocation, from, isPush, replace$1, data) {\n\t\tconst error = checkCanceledNavigation(toLocation, from);\n\t\tif (error) return error;\n\t\tconst isFirstNavigation = from === START_LOCATION_NORMALIZED;\n\t\tconst state = !isBrowser ? {} : history.state;\n\t\tif (isPush) if (replace$1 || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({ scroll: isFirstNavigation && state && state.scroll }, data));\n\t\telse routerHistory.push(toLocation.fullPath, data);\n\t\tcurrentRoute.value = toLocation;\n\t\thandleScroll(toLocation, from, isPush, isFirstNavigation);\n\t\tmarkAsReady();\n\t}\n\tlet removeHistoryListener;\n\tfunction setupListeners() {\n\t\tif (removeHistoryListener) return;\n\t\tremoveHistoryListener = routerHistory.listen((to, _from, info) => {\n\t\t\tif (!router.listening) return;\n\t\t\tconst toLocation = resolve(to);\n\t\t\tconst shouldRedirect = handleRedirectRecord(toLocation, router.currentRoute.value);\n\t\t\tif (shouldRedirect) {\n\t\t\t\tpushWithRedirect(assign(shouldRedirect, {\n\t\t\t\t\treplace: true,\n\t\t\t\t\tforce: true\n\t\t\t\t}), toLocation).catch(noop);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpendingLocation = toLocation;\n\t\t\tconst from = currentRoute.value;\n\t\t\tif (isBrowser) saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n\t\t\tnavigate(toLocation, from).catch((error) => {\n\t\t\t\tif (isNavigationFailure(error, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_CANCELLED)) return error;\n\t\t\t\tif (isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {\n\t\t\t\t\tpushWithRedirect(assign(locationAsObject(error.to), { force: true }), toLocation).then((failure) => {\n\t\t\t\t\t\tif (isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED) && !info.delta && info.type === NavigationType.pop) routerHistory.go(-1, false);\n\t\t\t\t\t}).catch(noop);\n\t\t\t\t\treturn Promise.reject();\n\t\t\t\t}\n\t\t\t\tif (info.delta) routerHistory.go(-info.delta, false);\n\t\t\t\treturn triggerError(error, toLocation, from);\n\t\t\t}).then((failure) => {\n\t\t\t\tfailure = failure || finalizeNavigation(toLocation, from, false);\n\t\t\t\tif (failure) {\n\t\t\t\t\tif (info.delta && !isNavigationFailure(failure, ErrorTypes.NAVIGATION_CANCELLED)) routerHistory.go(-info.delta, false);\n\t\t\t\t\telse if (info.type === NavigationType.pop && isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED)) routerHistory.go(-1, false);\n\t\t\t\t}\n\t\t\t\ttriggerAfterEach(toLocation, from, failure);\n\t\t\t}).catch(noop);\n\t\t});\n\t}\n\tlet readyHandlers = useCallbacks();\n\tlet errorListeners = useCallbacks();\n\tlet ready;\n\t/**\n\t* Trigger errorListeners added via onError and throws the error as well\n\t*\n\t* @param error - error to throw\n\t* @param to - location we were navigating to when the error happened\n\t* @param from - location we were navigating from when the error happened\n\t* @returns the error as a rejected promise\n\t*/\n\tfunction triggerError(error, to, from) {\n\t\tmarkAsReady(error);\n\t\tconst list = errorListeners.list();\n\t\tif (list.length) list.forEach((handler) => handler(error, to, from));\n\t\telse {\n\t\t\tif (process.env.NODE_ENV !== \"production\") warn$1(\"uncaught error during route navigation:\");\n\t\t\tconsole.error(error);\n\t\t}\n\t\treturn Promise.reject(error);\n\t}\n\tfunction isReady() {\n\t\tif (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();\n\t\treturn new Promise((resolve$1, reject) => {\n\t\t\treadyHandlers.add([resolve$1, reject]);\n\t\t});\n\t}\n\tfunction markAsReady(err) {\n\t\tif (!ready) {\n\t\t\tready = !err;\n\t\t\tsetupListeners();\n\t\t\treadyHandlers.list().forEach(([resolve$1, reject]) => err ? reject(err) : resolve$1());\n\t\t\treadyHandlers.reset();\n\t\t}\n\t\treturn err;\n\t}\n\tfunction handleScroll(to, from, isPush, isFirstNavigation) {\n\t\tconst { scrollBehavior } = options;\n\t\tif (!isBrowser || !scrollBehavior) return Promise.resolve();\n\t\tconst scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;\n\t\treturn nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));\n\t}\n\tconst go = (delta) => routerHistory.go(delta);\n\tlet started;\n\tconst installedApps = /* @__PURE__ */ new Set();\n\tconst router = {\n\t\tcurrentRoute,\n\t\tlistening: true,\n\t\taddRoute,\n\t\tremoveRoute,\n\t\tclearRoutes: matcher.clearRoutes,\n\t\thasRoute,\n\t\tgetRoutes,\n\t\tresolve,\n\t\toptions,\n\t\tpush,\n\t\treplace,\n\t\tgo,\n\t\tback: () => go(-1),\n\t\tforward: () => go(1),\n\t\tbeforeEach: beforeGuards.add,\n\t\tbeforeResolve: beforeResolveGuards.add,\n\t\tafterEach: afterGuards.add,\n\t\tonError: errorListeners.add,\n\t\tisReady,\n\t\tinstall(app) {\n\t\t\tapp.component(\"RouterLink\", RouterLink);\n\t\t\tapp.component(\"RouterView\", RouterView);\n\t\t\tapp.config.globalProperties.$router = router;\n\t\t\tObject.defineProperty(app.config.globalProperties, \"$route\", {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: () => unref(currentRoute)\n\t\t\t});\n\t\t\tif (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {\n\t\t\t\tstarted = true;\n\t\t\t\tpush(routerHistory.location).catch((err) => {\n\t\t\t\t\tif (process.env.NODE_ENV !== \"production\") warn$1(\"Unexpected error when starting the router:\", err);\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst reactiveRoute = {};\n\t\t\tfor (const key in START_LOCATION_NORMALIZED) Object.defineProperty(reactiveRoute, key, {\n\t\t\t\tget: () => currentRoute.value[key],\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t\tapp.provide(routerKey, router);\n\t\t\tapp.provide(routeLocationKey, shallowReactive(reactiveRoute));\n\t\t\tapp.provide(routerViewLocationKey, currentRoute);\n\t\t\tconst unmountApp = app.unmount;\n\t\t\tinstalledApps.add(app);\n\t\t\tapp.unmount = function() {\n\t\t\t\tinstalledApps.delete(app);\n\t\t\t\tif (installedApps.size < 1) {\n\t\t\t\t\tpendingLocation = START_LOCATION_NORMALIZED;\n\t\t\t\t\tremoveHistoryListener && removeHistoryListener();\n\t\t\t\t\tremoveHistoryListener = null;\n\t\t\t\t\tcurrentRoute.value = START_LOCATION_NORMALIZED;\n\t\t\t\t\tstarted = false;\n\t\t\t\t\tready = false;\n\t\t\t\t}\n\t\t\t\tunmountApp();\n\t\t\t};\n\t\t\tif ((process.env.NODE_ENV !== \"production\" || __VUE_PROD_DEVTOOLS__) && isBrowser) addDevtools(app, router, matcher);\n\t\t}\n\t};\n\tfunction runGuardQueue(guards) {\n\t\treturn guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());\n\t}\n\treturn router;\n}\n\n//#endregion\n//#region src/useApi.ts\n/**\n* Returns the router instance. Equivalent to using `$router` inside\n* templates.\n*/\nfunction useRouter() {\n\treturn inject(routerKey);\n}\n/**\n* Returns the current route location. Equivalent to using `$route` inside\n* templates.\n*/\nfunction useRoute(_name) {\n\treturn inject(routeLocationKey);\n}\n\n//#endregion\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, loadRouteLocation, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };","import { h, defineComponent, ref, shallowRef, onMounted, watch, onUnmounted, nextTick } from 'vue';\n\nconst matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nconst stringToIcon = (value, validate, allowSimpleName, provider = \"\") => {\n  const colonSeparated = value.split(\":\");\n  if (value.slice(0, 1) === \"@\") {\n    if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n      return null;\n    }\n    provider = colonSeparated.shift().slice(1);\n  }\n  if (colonSeparated.length > 3 || !colonSeparated.length) {\n    return null;\n  }\n  if (colonSeparated.length > 1) {\n    const name2 = colonSeparated.pop();\n    const prefix = colonSeparated.pop();\n    const result = {\n      // Allow provider without '@': \"provider:prefix:name\"\n      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n      prefix,\n      name: name2\n    };\n    return validate && !validateIconName(result) ? null : result;\n  }\n  const name = colonSeparated[0];\n  const dashSeparated = name.split(\"-\");\n  if (dashSeparated.length > 1) {\n    const result = {\n      provider,\n      prefix: dashSeparated.shift(),\n      name: dashSeparated.join(\"-\")\n    };\n    return validate && !validateIconName(result) ? null : result;\n  }\n  if (allowSimpleName && provider === \"\") {\n    const result = {\n      provider,\n      prefix: \"\",\n      name\n    };\n    return validate && !validateIconName(result, allowSimpleName) ? null : result;\n  }\n  return null;\n};\nconst validateIconName = (icon, allowSimpleName) => {\n  if (!icon) {\n    return false;\n  }\n  return !!// Check prefix: cannot be empty, unless allowSimpleName is enabled\n  // Check name: cannot be empty\n  ((allowSimpleName && icon.prefix === \"\" || !!icon.prefix) && !!icon.name);\n};\n\nconst defaultIconDimensions = Object.freeze(\n  {\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n  }\n);\nconst defaultIconTransformations = Object.freeze({\n  rotate: 0,\n  vFlip: false,\n  hFlip: false\n});\nconst defaultIconProps = Object.freeze({\n  ...defaultIconDimensions,\n  ...defaultIconTransformations\n});\nconst defaultExtendedIconProps = Object.freeze({\n  ...defaultIconProps,\n  body: \"\",\n  hidden: false\n});\n\nfunction mergeIconTransformations(obj1, obj2) {\n  const result = {};\n  if (!obj1.hFlip !== !obj2.hFlip) {\n    result.hFlip = true;\n  }\n  if (!obj1.vFlip !== !obj2.vFlip) {\n    result.vFlip = true;\n  }\n  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n  if (rotate) {\n    result.rotate = rotate;\n  }\n  return result;\n}\n\nfunction mergeIconData(parent, child) {\n  const result = mergeIconTransformations(parent, child);\n  for (const key in defaultExtendedIconProps) {\n    if (key in defaultIconTransformations) {\n      if (key in parent && !(key in result)) {\n        result[key] = defaultIconTransformations[key];\n      }\n    } else if (key in child) {\n      result[key] = child[key];\n    } else if (key in parent) {\n      result[key] = parent[key];\n    }\n  }\n  return result;\n}\n\nfunction getIconsTree(data, names) {\n  const icons = data.icons;\n  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n  const resolved = /* @__PURE__ */ Object.create(null);\n  function resolve(name) {\n    if (icons[name]) {\n      return resolved[name] = [];\n    }\n    if (!(name in resolved)) {\n      resolved[name] = null;\n      const parent = aliases[name] && aliases[name].parent;\n      const value = parent && resolve(parent);\n      if (value) {\n        resolved[name] = [parent].concat(value);\n      }\n    }\n    return resolved[name];\n  }\n  (Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);\n  return resolved;\n}\n\nfunction internalGetIconData(data, name, tree) {\n  const icons = data.icons;\n  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n  let currentProps = {};\n  function parse(name2) {\n    currentProps = mergeIconData(\n      icons[name2] || aliases[name2],\n      currentProps\n    );\n  }\n  parse(name);\n  tree.forEach(parse);\n  return mergeIconData(data, currentProps);\n}\n\nfunction parseIconSet(data, callback) {\n  const names = [];\n  if (typeof data !== \"object\" || typeof data.icons !== \"object\") {\n    return names;\n  }\n  if (data.not_found instanceof Array) {\n    data.not_found.forEach((name) => {\n      callback(name, null);\n      names.push(name);\n    });\n  }\n  const tree = getIconsTree(data);\n  for (const name in tree) {\n    const item = tree[name];\n    if (item) {\n      callback(name, internalGetIconData(data, name, item));\n      names.push(name);\n    }\n  }\n  return names;\n}\n\nconst optionalPropertyDefaults = {\n  provider: \"\",\n  aliases: {},\n  not_found: {},\n  ...defaultIconDimensions\n};\nfunction checkOptionalProps(item, defaults) {\n  for (const prop in defaults) {\n    if (prop in item && typeof item[prop] !== typeof defaults[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction quicklyValidateIconSet(obj) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return null;\n  }\n  const data = obj;\n  if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") {\n    return null;\n  }\n  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {\n    return null;\n  }\n  const icons = data.icons;\n  for (const name in icons) {\n    const icon = icons[name];\n    if (\n      // Name cannot be empty\n      !name || // Must have body\n      typeof icon.body !== \"string\" || // Check other props\n      !checkOptionalProps(\n        icon,\n        defaultExtendedIconProps\n      )\n    ) {\n      return null;\n    }\n  }\n  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n  for (const name in aliases) {\n    const icon = aliases[name];\n    const parent = icon.parent;\n    if (\n      // Name cannot be empty\n      !name || // Parent must be set and point to existing icon\n      typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || // Check other props\n      !checkOptionalProps(\n        icon,\n        defaultExtendedIconProps\n      )\n    ) {\n      return null;\n    }\n  }\n  return data;\n}\n\nconst dataStorage = /* @__PURE__ */ Object.create(null);\nfunction newStorage(provider, prefix) {\n  return {\n    provider,\n    prefix,\n    icons: /* @__PURE__ */ Object.create(null),\n    missing: /* @__PURE__ */ new Set()\n  };\n}\nfunction getStorage(provider, prefix) {\n  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));\n  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\nfunction addIconSet(storage, data) {\n  if (!quicklyValidateIconSet(data)) {\n    return [];\n  }\n  return parseIconSet(data, (name, icon) => {\n    if (icon) {\n      storage.icons[name] = icon;\n    } else {\n      storage.missing.add(name);\n    }\n  });\n}\nfunction addIconToStorage(storage, name, icon) {\n  try {\n    if (typeof icon.body === \"string\") {\n      storage.icons[name] = { ...icon };\n      return true;\n    }\n  } catch (err) {\n  }\n  return false;\n}\nfunction listIcons(provider, prefix) {\n  let allIcons = [];\n  const providers = typeof provider === \"string\" ? [provider] : Object.keys(dataStorage);\n  providers.forEach((provider2) => {\n    const prefixes = typeof provider2 === \"string\" && typeof prefix === \"string\" ? [prefix] : Object.keys(dataStorage[provider2] || {});\n    prefixes.forEach((prefix2) => {\n      const storage = getStorage(provider2, prefix2);\n      allIcons = allIcons.concat(\n        Object.keys(storage.icons).map(\n          (name) => (provider2 !== \"\" ? \"@\" + provider2 + \":\" : \"\") + prefix2 + \":\" + name\n        )\n      );\n    });\n  });\n  return allIcons;\n}\n\nlet simpleNames = false;\nfunction allowSimpleNames(allow) {\n  if (typeof allow === \"boolean\") {\n    simpleNames = allow;\n  }\n  return simpleNames;\n}\nfunction getIconData(name) {\n  const icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n  if (icon) {\n    const storage = getStorage(icon.provider, icon.prefix);\n    const iconName = icon.name;\n    return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n  }\n}\nfunction addIcon(name, data) {\n  const icon = stringToIcon(name, true, simpleNames);\n  if (!icon) {\n    return false;\n  }\n  const storage = getStorage(icon.provider, icon.prefix);\n  if (data) {\n    return addIconToStorage(storage, icon.name, data);\n  } else {\n    storage.missing.add(icon.name);\n    return true;\n  }\n}\nfunction addCollection(data, provider) {\n  if (typeof data !== \"object\") {\n    return false;\n  }\n  if (typeof provider !== \"string\") {\n    provider = data.provider || \"\";\n  }\n  if (simpleNames && !provider && !data.prefix) {\n    let added = false;\n    if (quicklyValidateIconSet(data)) {\n      data.prefix = \"\";\n      parseIconSet(data, (name, icon) => {\n        if (addIcon(name, icon)) {\n          added = true;\n        }\n      });\n    }\n    return added;\n  }\n  const prefix = data.prefix;\n  if (!validateIconName({\n    prefix,\n    name: \"a\"\n  })) {\n    return false;\n  }\n  const storage = getStorage(provider, prefix);\n  return !!addIconSet(storage, data);\n}\nfunction iconLoaded(name) {\n  return !!getIconData(name);\n}\nfunction getIcon(name) {\n  const result = getIconData(name);\n  return result ? {\n    ...defaultIconProps,\n    ...result\n  } : result;\n}\n\nconst defaultIconSizeCustomisations = Object.freeze({\n  width: null,\n  height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n  // Dimensions\n  ...defaultIconSizeCustomisations,\n  // Transformations\n  ...defaultIconTransformations\n});\n\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n  if (ratio === 1) {\n    return size;\n  }\n  precision = precision || 100;\n  if (typeof size === \"number\") {\n    return Math.ceil(size * ratio * precision) / precision;\n  }\n  if (typeof size !== \"string\") {\n    return size;\n  }\n  const oldParts = size.split(unitsSplit);\n  if (oldParts === null || !oldParts.length) {\n    return size;\n  }\n  const newParts = [];\n  let code = oldParts.shift();\n  let isNumber = unitsTest.test(code);\n  while (true) {\n    if (isNumber) {\n      const num = parseFloat(code);\n      if (isNaN(num)) {\n        newParts.push(code);\n      } else {\n        newParts.push(Math.ceil(num * ratio * precision) / precision);\n      }\n    } else {\n      newParts.push(code);\n    }\n    code = oldParts.shift();\n    if (code === void 0) {\n      return newParts.join(\"\");\n    }\n    isNumber = !isNumber;\n  }\n}\n\nfunction splitSVGDefs(content, tag = \"defs\") {\n  let defs = \"\";\n  const index = content.indexOf(\"<\" + tag);\n  while (index >= 0) {\n    const start = content.indexOf(\">\", index);\n    const end = content.indexOf(\"</\" + tag);\n    if (start === -1 || end === -1) {\n      break;\n    }\n    const endEnd = content.indexOf(\">\", end);\n    if (endEnd === -1) {\n      break;\n    }\n    defs += content.slice(start + 1, end).trim();\n    content = content.slice(0, index).trim() + content.slice(endEnd + 1);\n  }\n  return {\n    defs,\n    content\n  };\n}\nfunction mergeDefsAndContent(defs, content) {\n  return defs ? \"<defs>\" + defs + \"</defs>\" + content : content;\n}\nfunction wrapSVGContent(body, start, end) {\n  const split = splitSVGDefs(body);\n  return mergeDefsAndContent(split.defs, start + split.content + end);\n}\n\nconst isUnsetKeyword = (value) => value === \"unset\" || value === \"undefined\" || value === \"none\";\nfunction iconToSVG(icon, customisations) {\n  const fullIcon = {\n    ...defaultIconProps,\n    ...icon\n  };\n  const fullCustomisations = {\n    ...defaultIconCustomisations,\n    ...customisations\n  };\n  const box = {\n    left: fullIcon.left,\n    top: fullIcon.top,\n    width: fullIcon.width,\n    height: fullIcon.height\n  };\n  let body = fullIcon.body;\n  [fullIcon, fullCustomisations].forEach((props) => {\n    const transformations = [];\n    const hFlip = props.hFlip;\n    const vFlip = props.vFlip;\n    let rotation = props.rotate;\n    if (hFlip) {\n      if (vFlip) {\n        rotation += 2;\n      } else {\n        transformations.push(\n          \"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\"\n        );\n        transformations.push(\"scale(-1 1)\");\n        box.top = box.left = 0;\n      }\n    } else if (vFlip) {\n      transformations.push(\n        \"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\"\n      );\n      transformations.push(\"scale(1 -1)\");\n      box.top = box.left = 0;\n    }\n    let tempValue;\n    if (rotation < 0) {\n      rotation -= Math.floor(rotation / 4) * 4;\n    }\n    rotation = rotation % 4;\n    switch (rotation) {\n      case 1:\n        tempValue = box.height / 2 + box.top;\n        transformations.unshift(\n          \"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\"\n        );\n        break;\n      case 2:\n        transformations.unshift(\n          \"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\"\n        );\n        break;\n      case 3:\n        tempValue = box.width / 2 + box.left;\n        transformations.unshift(\n          \"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\"\n        );\n        break;\n    }\n    if (rotation % 2 === 1) {\n      if (box.left !== box.top) {\n        tempValue = box.left;\n        box.left = box.top;\n        box.top = tempValue;\n      }\n      if (box.width !== box.height) {\n        tempValue = box.width;\n        box.width = box.height;\n        box.height = tempValue;\n      }\n    }\n    if (transformations.length) {\n      body = wrapSVGContent(\n        body,\n        '<g transform=\"' + transformations.join(\" \") + '\">',\n        \"</g>\"\n      );\n    }\n  });\n  const customisationsWidth = fullCustomisations.width;\n  const customisationsHeight = fullCustomisations.height;\n  const boxWidth = box.width;\n  const boxHeight = box.height;\n  let width;\n  let height;\n  if (customisationsWidth === null) {\n    height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    width = calculateSize(height, boxWidth / boxHeight);\n  } else {\n    width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n  }\n  const attributes = {};\n  const setAttr = (prop, value) => {\n    if (!isUnsetKeyword(value)) {\n      attributes[prop] = value.toString();\n    }\n  };\n  setAttr(\"width\", width);\n  setAttr(\"height\", height);\n  const viewBox = [box.left, box.top, boxWidth, boxHeight];\n  attributes.viewBox = viewBox.join(\" \");\n  return {\n    attributes,\n    viewBox,\n    body\n  };\n}\n\nconst regex = /\\sid=\"(\\S+)\"/g;\nconst randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\nlet counter = 0;\nfunction replaceIDs(body, prefix = randomPrefix) {\n  const ids = [];\n  let match;\n  while (match = regex.exec(body)) {\n    ids.push(match[1]);\n  }\n  if (!ids.length) {\n    return body;\n  }\n  const suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n  ids.forEach((id) => {\n    const newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n    const escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    body = body.replace(\n      // Allowed characters before id: [#;\"]\n      // Allowed characters after id: [)\"], .[a-z]\n      new RegExp('([#;\"])(' + escapedID + ')([\")]|\\\\.[a-z])', \"g\"),\n      \"$1\" + newID + suffix + \"$3\"\n    );\n  });\n  body = body.replace(new RegExp(suffix, \"g\"), \"\");\n  return body;\n}\n\nconst storage = /* @__PURE__ */ Object.create(null);\nfunction setAPIModule(provider, item) {\n  storage[provider] = item;\n}\nfunction getAPIModule(provider) {\n  return storage[provider] || storage[\"\"];\n}\n\nfunction createAPIConfig(source) {\n  let resources;\n  if (typeof source.resources === \"string\") {\n    resources = [source.resources];\n  } else {\n    resources = source.resources;\n    if (!(resources instanceof Array) || !resources.length) {\n      return null;\n    }\n  }\n  const result = {\n    // API hosts\n    resources,\n    // Root path\n    path: source.path || \"/\",\n    // URL length limit\n    maxURL: source.maxURL || 500,\n    // Timeout before next host is used.\n    rotate: source.rotate || 750,\n    // Timeout before failing query.\n    timeout: source.timeout || 5e3,\n    // Randomise default API end point.\n    random: source.random === true,\n    // Start index\n    index: source.index || 0,\n    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n    dataAfterTimeout: source.dataAfterTimeout !== false\n  };\n  return result;\n}\nconst configStorage = /* @__PURE__ */ Object.create(null);\nconst fallBackAPISources = [\n  \"https://api.simplesvg.com\",\n  \"https://api.unisvg.com\"\n];\nconst fallBackAPI = [];\nwhile (fallBackAPISources.length > 0) {\n  if (fallBackAPISources.length === 1) {\n    fallBackAPI.push(fallBackAPISources.shift());\n  } else {\n    if (Math.random() > 0.5) {\n      fallBackAPI.push(fallBackAPISources.shift());\n    } else {\n      fallBackAPI.push(fallBackAPISources.pop());\n    }\n  }\n}\nconfigStorage[\"\"] = createAPIConfig({\n  resources: [\"https://api.iconify.design\"].concat(fallBackAPI)\n});\nfunction addAPIProvider(provider, customConfig) {\n  const config = createAPIConfig(customConfig);\n  if (config === null) {\n    return false;\n  }\n  configStorage[provider] = config;\n  return true;\n}\nfunction getAPIConfig(provider) {\n  return configStorage[provider];\n}\nfunction listAPIProviders() {\n  return Object.keys(configStorage);\n}\n\nconst detectFetch = () => {\n  let callback;\n  try {\n    callback = fetch;\n    if (typeof callback === \"function\") {\n      return callback;\n    }\n  } catch (err) {\n  }\n};\nlet fetchModule = detectFetch();\nfunction setFetch(fetch2) {\n  fetchModule = fetch2;\n}\nfunction getFetch() {\n  return fetchModule;\n}\nfunction calculateMaxLength(provider, prefix) {\n  const config = getAPIConfig(provider);\n  if (!config) {\n    return 0;\n  }\n  let result;\n  if (!config.maxURL) {\n    result = 0;\n  } else {\n    let maxHostLength = 0;\n    config.resources.forEach((item) => {\n      const host = item;\n      maxHostLength = Math.max(maxHostLength, host.length);\n    });\n    const url = prefix + \".json?icons=\";\n    result = config.maxURL - maxHostLength - config.path.length - url.length;\n  }\n  return result;\n}\nfunction shouldAbort(status) {\n  return status === 404;\n}\nconst prepare = (provider, prefix, icons) => {\n  const results = [];\n  const maxLength = calculateMaxLength(provider, prefix);\n  const type = \"icons\";\n  let item = {\n    type,\n    provider,\n    prefix,\n    icons: []\n  };\n  let length = 0;\n  icons.forEach((name, index) => {\n    length += name.length + 1;\n    if (length >= maxLength && index > 0) {\n      results.push(item);\n      item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n      };\n      length = name.length;\n    }\n    item.icons.push(name);\n  });\n  results.push(item);\n  return results;\n};\nfunction getPath(provider) {\n  if (typeof provider === \"string\") {\n    const config = getAPIConfig(provider);\n    if (config) {\n      return config.path;\n    }\n  }\n  return \"/\";\n}\nconst send = (host, params, callback) => {\n  if (!fetchModule) {\n    callback(\"abort\", 424);\n    return;\n  }\n  let path = getPath(params.provider);\n  switch (params.type) {\n    case \"icons\": {\n      const prefix = params.prefix;\n      const icons = params.icons;\n      const iconsList = icons.join(\",\");\n      const urlParams = new URLSearchParams({\n        icons: iconsList\n      });\n      path += prefix + \".json?\" + urlParams.toString();\n      break;\n    }\n    case \"custom\": {\n      const uri = params.uri;\n      path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n      break;\n    }\n    default:\n      callback(\"abort\", 400);\n      return;\n  }\n  let defaultError = 503;\n  fetchModule(host + path).then((response) => {\n    const status = response.status;\n    if (status !== 200) {\n      setTimeout(() => {\n        callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n      });\n      return;\n    }\n    defaultError = 501;\n    return response.json();\n  }).then((data) => {\n    if (typeof data !== \"object\" || data === null) {\n      setTimeout(() => {\n        if (data === 404) {\n          callback(\"abort\", data);\n        } else {\n          callback(\"next\", defaultError);\n        }\n      });\n      return;\n    }\n    setTimeout(() => {\n      callback(\"success\", data);\n    });\n  }).catch(() => {\n    callback(\"next\", defaultError);\n  });\n};\nconst fetchAPIModule = {\n  prepare,\n  send\n};\n\nfunction sortIcons(icons) {\n  const result = {\n    loaded: [],\n    missing: [],\n    pending: []\n  };\n  const storage = /* @__PURE__ */ Object.create(null);\n  icons.sort((a, b) => {\n    if (a.provider !== b.provider) {\n      return a.provider.localeCompare(b.provider);\n    }\n    if (a.prefix !== b.prefix) {\n      return a.prefix.localeCompare(b.prefix);\n    }\n    return a.name.localeCompare(b.name);\n  });\n  let lastIcon = {\n    provider: \"\",\n    prefix: \"\",\n    name: \"\"\n  };\n  icons.forEach((icon) => {\n    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {\n      return;\n    }\n    lastIcon = icon;\n    const provider = icon.provider;\n    const prefix = icon.prefix;\n    const name = icon.name;\n    const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));\n    const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n    let list;\n    if (name in localStorage.icons) {\n      list = result.loaded;\n    } else if (prefix === \"\" || localStorage.missing.has(name)) {\n      list = result.missing;\n    } else {\n      list = result.pending;\n    }\n    const item = {\n      provider,\n      prefix,\n      name\n    };\n    list.push(item);\n  });\n  return result;\n}\n\nfunction removeCallback(storages, id) {\n  storages.forEach((storage) => {\n    const items = storage.loaderCallbacks;\n    if (items) {\n      storage.loaderCallbacks = items.filter((row) => row.id !== id);\n    }\n  });\n}\nfunction updateCallbacks(storage) {\n  if (!storage.pendingCallbacksFlag) {\n    storage.pendingCallbacksFlag = true;\n    setTimeout(() => {\n      storage.pendingCallbacksFlag = false;\n      const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n      if (!items.length) {\n        return;\n      }\n      let hasPending = false;\n      const provider = storage.provider;\n      const prefix = storage.prefix;\n      items.forEach((item) => {\n        const icons = item.icons;\n        const oldLength = icons.pending.length;\n        icons.pending = icons.pending.filter((icon) => {\n          if (icon.prefix !== prefix) {\n            return true;\n          }\n          const name = icon.name;\n          if (storage.icons[name]) {\n            icons.loaded.push({\n              provider,\n              prefix,\n              name\n            });\n          } else if (storage.missing.has(name)) {\n            icons.missing.push({\n              provider,\n              prefix,\n              name\n            });\n          } else {\n            hasPending = true;\n            return true;\n          }\n          return false;\n        });\n        if (icons.pending.length !== oldLength) {\n          if (!hasPending) {\n            removeCallback([storage], item.id);\n          }\n          item.callback(\n            icons.loaded.slice(0),\n            icons.missing.slice(0),\n            icons.pending.slice(0),\n            item.abort\n          );\n        }\n      });\n    });\n  }\n}\nlet idCounter = 0;\nfunction storeCallback(callback, icons, pendingSources) {\n  const id = idCounter++;\n  const abort = removeCallback.bind(null, pendingSources, id);\n  if (!icons.pending.length) {\n    return abort;\n  }\n  const item = {\n    id,\n    icons,\n    callback,\n    abort\n  };\n  pendingSources.forEach((storage) => {\n    (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n  });\n  return abort;\n}\n\nfunction listToIcons(list, validate = true, simpleNames = false) {\n  const result = [];\n  list.forEach((item) => {\n    const icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n    if (icon) {\n      result.push(icon);\n    }\n  });\n  return result;\n}\n\n// src/config.ts\nvar defaultConfig = {\n  resources: [],\n  index: 0,\n  timeout: 2e3,\n  rotate: 750,\n  random: false,\n  dataAfterTimeout: false\n};\n\n// src/query.ts\nfunction sendQuery(config, payload, query, done) {\n  const resourcesCount = config.resources.length;\n  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n  let resources;\n  if (config.random) {\n    let list = config.resources.slice(0);\n    resources = [];\n    while (list.length > 1) {\n      const nextIndex = Math.floor(Math.random() * list.length);\n      resources.push(list[nextIndex]);\n      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n    }\n    resources = resources.concat(list);\n  } else {\n    resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n  }\n  const startTime = Date.now();\n  let status = \"pending\";\n  let queriesSent = 0;\n  let lastError;\n  let timer = null;\n  let queue = [];\n  let doneCallbacks = [];\n  if (typeof done === \"function\") {\n    doneCallbacks.push(done);\n  }\n  function resetTimer() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function abort() {\n    if (status === \"pending\") {\n      status = \"aborted\";\n    }\n    resetTimer();\n    queue.forEach((item) => {\n      if (item.status === \"pending\") {\n        item.status = \"aborted\";\n      }\n    });\n    queue = [];\n  }\n  function subscribe(callback, overwrite) {\n    if (overwrite) {\n      doneCallbacks = [];\n    }\n    if (typeof callback === \"function\") {\n      doneCallbacks.push(callback);\n    }\n  }\n  function getQueryStatus() {\n    return {\n      startTime,\n      payload,\n      status,\n      queriesSent,\n      queriesPending: queue.length,\n      subscribe,\n      abort\n    };\n  }\n  function failQuery() {\n    status = \"failed\";\n    doneCallbacks.forEach((callback) => {\n      callback(void 0, lastError);\n    });\n  }\n  function clearQueue() {\n    queue.forEach((item) => {\n      if (item.status === \"pending\") {\n        item.status = \"aborted\";\n      }\n    });\n    queue = [];\n  }\n  function moduleResponse(item, response, data) {\n    const isError = response !== \"success\";\n    queue = queue.filter((queued) => queued !== item);\n    switch (status) {\n      case \"pending\":\n        break;\n      case \"failed\":\n        if (isError || !config.dataAfterTimeout) {\n          return;\n        }\n        break;\n      default:\n        return;\n    }\n    if (response === \"abort\") {\n      lastError = data;\n      failQuery();\n      return;\n    }\n    if (isError) {\n      lastError = data;\n      if (!queue.length) {\n        if (!resources.length) {\n          failQuery();\n        } else {\n          execNext();\n        }\n      }\n      return;\n    }\n    resetTimer();\n    clearQueue();\n    if (!config.random) {\n      const index = config.resources.indexOf(item.resource);\n      if (index !== -1 && index !== config.index) {\n        config.index = index;\n      }\n    }\n    status = \"completed\";\n    doneCallbacks.forEach((callback) => {\n      callback(data);\n    });\n  }\n  function execNext() {\n    if (status !== \"pending\") {\n      return;\n    }\n    resetTimer();\n    const resource = resources.shift();\n    if (resource === void 0) {\n      if (queue.length) {\n        timer = setTimeout(() => {\n          resetTimer();\n          if (status === \"pending\") {\n            clearQueue();\n            failQuery();\n          }\n        }, config.timeout);\n        return;\n      }\n      failQuery();\n      return;\n    }\n    const item = {\n      status: \"pending\",\n      resource,\n      callback: (status2, data) => {\n        moduleResponse(item, status2, data);\n      }\n    };\n    queue.push(item);\n    queriesSent++;\n    timer = setTimeout(execNext, config.rotate);\n    query(resource, payload, item.callback);\n  }\n  setTimeout(execNext);\n  return getQueryStatus;\n}\n\n// src/index.ts\nfunction initRedundancy(cfg) {\n  const config = {\n    ...defaultConfig,\n    ...cfg\n  };\n  let queries = [];\n  function cleanup() {\n    queries = queries.filter((item) => item().status === \"pending\");\n  }\n  function query(payload, queryCallback, doneCallback) {\n    const query2 = sendQuery(\n      config,\n      payload,\n      queryCallback,\n      (data, error) => {\n        cleanup();\n        if (doneCallback) {\n          doneCallback(data, error);\n        }\n      }\n    );\n    queries.push(query2);\n    return query2;\n  }\n  function find(callback) {\n    return queries.find((value) => {\n      return callback(value);\n    }) || null;\n  }\n  const instance = {\n    query,\n    find,\n    setIndex: (index) => {\n      config.index = index;\n    },\n    getIndex: () => config.index,\n    cleanup\n  };\n  return instance;\n}\n\nfunction emptyCallback$1() {\n}\nconst redundancyCache = /* @__PURE__ */ Object.create(null);\nfunction getRedundancyCache(provider) {\n  if (!redundancyCache[provider]) {\n    const config = getAPIConfig(provider);\n    if (!config) {\n      return;\n    }\n    const redundancy = initRedundancy(config);\n    const cachedReundancy = {\n      config,\n      redundancy\n    };\n    redundancyCache[provider] = cachedReundancy;\n  }\n  return redundancyCache[provider];\n}\nfunction sendAPIQuery(target, query, callback) {\n  let redundancy;\n  let send;\n  if (typeof target === \"string\") {\n    const api = getAPIModule(target);\n    if (!api) {\n      callback(void 0, 424);\n      return emptyCallback$1;\n    }\n    send = api.send;\n    const cached = getRedundancyCache(target);\n    if (cached) {\n      redundancy = cached.redundancy;\n    }\n  } else {\n    const config = createAPIConfig(target);\n    if (config) {\n      redundancy = initRedundancy(config);\n      const moduleKey = target.resources ? target.resources[0] : \"\";\n      const api = getAPIModule(moduleKey);\n      if (api) {\n        send = api.send;\n      }\n    }\n  }\n  if (!redundancy || !send) {\n    callback(void 0, 424);\n    return emptyCallback$1;\n  }\n  return redundancy.query(query, send, callback)().abort;\n}\n\nfunction emptyCallback() {\n}\nfunction loadedNewIcons(storage) {\n  if (!storage.iconsLoaderFlag) {\n    storage.iconsLoaderFlag = true;\n    setTimeout(() => {\n      storage.iconsLoaderFlag = false;\n      updateCallbacks(storage);\n    });\n  }\n}\nfunction checkIconNamesForAPI(icons) {\n  const valid = [];\n  const invalid = [];\n  icons.forEach((name) => {\n    (name.match(matchIconName) ? valid : invalid).push(name);\n  });\n  return {\n    valid,\n    invalid\n  };\n}\nfunction parseLoaderResponse(storage, icons, data) {\n  function checkMissing() {\n    const pending = storage.pendingIcons;\n    icons.forEach((name) => {\n      if (pending) {\n        pending.delete(name);\n      }\n      if (!storage.icons[name]) {\n        storage.missing.add(name);\n      }\n    });\n  }\n  if (data && typeof data === \"object\") {\n    try {\n      const parsed = addIconSet(storage, data);\n      if (!parsed.length) {\n        checkMissing();\n        return;\n      }\n    } catch (err) {\n      console.error(err);\n    }\n  }\n  checkMissing();\n  loadedNewIcons(storage);\n}\nfunction parsePossiblyAsyncResponse(response, callback) {\n  if (response instanceof Promise) {\n    response.then((data) => {\n      callback(data);\n    }).catch(() => {\n      callback(null);\n    });\n  } else {\n    callback(response);\n  }\n}\nfunction loadNewIcons(storage, icons) {\n  if (!storage.iconsToLoad) {\n    storage.iconsToLoad = icons;\n  } else {\n    storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n  }\n  if (!storage.iconsQueueFlag) {\n    storage.iconsQueueFlag = true;\n    setTimeout(() => {\n      storage.iconsQueueFlag = false;\n      const { provider, prefix } = storage;\n      const icons2 = storage.iconsToLoad;\n      delete storage.iconsToLoad;\n      if (!icons2 || !icons2.length) {\n        return;\n      }\n      const customIconLoader = storage.loadIcon;\n      if (storage.loadIcons && (icons2.length > 1 || !customIconLoader)) {\n        parsePossiblyAsyncResponse(\n          storage.loadIcons(icons2, prefix, provider),\n          (data) => {\n            parseLoaderResponse(storage, icons2, data);\n          }\n        );\n        return;\n      }\n      if (customIconLoader) {\n        icons2.forEach((name) => {\n          const response = customIconLoader(name, prefix, provider);\n          parsePossiblyAsyncResponse(response, (data) => {\n            const iconSet = data ? {\n              prefix,\n              icons: {\n                [name]: data\n              }\n            } : null;\n            parseLoaderResponse(storage, [name], iconSet);\n          });\n        });\n        return;\n      }\n      const { valid, invalid } = checkIconNamesForAPI(icons2);\n      if (invalid.length) {\n        parseLoaderResponse(storage, invalid, null);\n      }\n      if (!valid.length) {\n        return;\n      }\n      const api = prefix.match(matchIconName) ? getAPIModule(provider) : null;\n      if (!api) {\n        parseLoaderResponse(storage, valid, null);\n        return;\n      }\n      const params = api.prepare(provider, prefix, valid);\n      params.forEach((item) => {\n        sendAPIQuery(provider, item, (data) => {\n          parseLoaderResponse(storage, item.icons, data);\n        });\n      });\n    });\n  }\n}\nconst loadIcons = (icons, callback) => {\n  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n  const sortedIcons = sortIcons(cleanedIcons);\n  if (!sortedIcons.pending.length) {\n    let callCallback = true;\n    if (callback) {\n      setTimeout(() => {\n        if (callCallback) {\n          callback(\n            sortedIcons.loaded,\n            sortedIcons.missing,\n            sortedIcons.pending,\n            emptyCallback\n          );\n        }\n      });\n    }\n    return () => {\n      callCallback = false;\n    };\n  }\n  const newIcons = /* @__PURE__ */ Object.create(null);\n  const sources = [];\n  let lastProvider, lastPrefix;\n  sortedIcons.pending.forEach((icon) => {\n    const { provider, prefix } = icon;\n    if (prefix === lastPrefix && provider === lastProvider) {\n      return;\n    }\n    lastProvider = provider;\n    lastPrefix = prefix;\n    sources.push(getStorage(provider, prefix));\n    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));\n    if (!providerNewIcons[prefix]) {\n      providerNewIcons[prefix] = [];\n    }\n  });\n  sortedIcons.pending.forEach((icon) => {\n    const { provider, prefix, name } = icon;\n    const storage = getStorage(provider, prefix);\n    const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n    if (!pendingQueue.has(name)) {\n      pendingQueue.add(name);\n      newIcons[provider][prefix].push(name);\n    }\n  });\n  sources.forEach((storage) => {\n    const list = newIcons[storage.provider][storage.prefix];\n    if (list.length) {\n      loadNewIcons(storage, list);\n    }\n  });\n  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\nconst loadIcon = (icon) => {\n  return new Promise((fulfill, reject) => {\n    const iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n    if (!iconObj) {\n      reject(icon);\n      return;\n    }\n    loadIcons([iconObj || icon], (loaded) => {\n      if (loaded.length && iconObj) {\n        const data = getIconData(iconObj);\n        if (data) {\n          fulfill({\n            ...defaultIconProps,\n            ...data\n          });\n          return;\n        }\n      }\n      reject(icon);\n    });\n  });\n};\n\nfunction setCustomIconsLoader(loader, prefix, provider) {\n  getStorage(provider || \"\", prefix).loadIcons = loader;\n}\nfunction setCustomIconLoader(loader, prefix, provider) {\n  getStorage(provider || \"\", prefix).loadIcon = loader;\n}\n\nfunction mergeCustomisations(defaults, item) {\n  const result = {\n    ...defaults\n  };\n  for (const key in item) {\n    const value = item[key];\n    const valueType = typeof value;\n    if (key in defaultIconSizeCustomisations) {\n      if (value === null || value && (valueType === \"string\" || valueType === \"number\")) {\n        result[key] = value;\n      }\n    } else if (valueType === typeof result[key]) {\n      result[key] = key === \"rotate\" ? value % 4 : value;\n    }\n  }\n  return result;\n}\n\nconst separator = /[\\s,]+/;\nfunction flipFromString(custom, flip) {\n  flip.split(separator).forEach((str) => {\n    const value = str.trim();\n    switch (value) {\n      case \"horizontal\":\n        custom.hFlip = true;\n        break;\n      case \"vertical\":\n        custom.vFlip = true;\n        break;\n    }\n  });\n}\n\nfunction rotateFromString(value, defaultValue = 0) {\n  const units = value.replace(/^-?[0-9.]*/, \"\");\n  function cleanup(value2) {\n    while (value2 < 0) {\n      value2 += 4;\n    }\n    return value2 % 4;\n  }\n  if (units === \"\") {\n    const num = parseInt(value);\n    return isNaN(num) ? 0 : cleanup(num);\n  } else if (units !== value) {\n    let split = 0;\n    switch (units) {\n      case \"%\":\n        split = 25;\n        break;\n      case \"deg\":\n        split = 90;\n    }\n    if (split) {\n      let num = parseFloat(value.slice(0, value.length - units.length));\n      if (isNaN(num)) {\n        return 0;\n      }\n      num = num / split;\n      return num % 1 === 0 ? cleanup(num) : 0;\n    }\n  }\n  return defaultValue;\n}\n\nfunction iconToHTML(body, attributes) {\n  let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n  for (const attr in attributes) {\n    renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n  }\n  return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\n\nfunction encodeSVGforURL(svg) {\n  return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction svgToData(svg) {\n  return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n  return 'url(\"' + svgToData(svg) + '\")';\n}\n\nconst defaultExtendedIconCustomisations = {\n    ...defaultIconCustomisations,\n    inline: false,\n};\n\n/**\n * Default SVG attributes\n */\nconst svgDefaults = {\n    'xmlns': 'http://www.w3.org/2000/svg',\n    'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n    'aria-hidden': true,\n    'role': 'img',\n};\n/**\n * Style modes\n */\nconst commonProps = {\n    display: 'inline-block',\n};\nconst monotoneProps = {\n    backgroundColor: 'currentColor',\n};\nconst coloredProps = {\n    backgroundColor: 'transparent',\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    Image: 'var(--svg)',\n    Repeat: 'no-repeat',\n    Size: '100% 100%',\n};\nconst propsToAddTo = {\n    webkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps,\n};\nfor (const prefix in propsToAddTo) {\n    const list = propsToAddTo[prefix];\n    for (const prop in propsToAdd) {\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Aliases for customisations.\n * In Vue 'v-' properties are reserved, so v-flip must be renamed\n */\nconst customisationAliases = {};\n['horizontal', 'vertical'].forEach((prefix) => {\n    const attr = prefix.slice(0, 1) + 'Flip';\n    // vertical-flip\n    customisationAliases[prefix + '-flip'] = attr;\n    // v-flip\n    customisationAliases[prefix.slice(0, 1) + '-flip'] = attr;\n    // verticalFlip\n    customisationAliases[prefix + 'Flip'] = attr;\n});\n/**\n * Fix size: add 'px' to numbers\n */\nfunction fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? 'px' : '');\n}\n/**\n * Render icon\n */\nconst render = (\n// Icon must be validated before calling this function\nicon, \n// Partial properties\nprops) => {\n    // Split properties\n    const customisations = mergeCustomisations(defaultExtendedIconCustomisations, props);\n    const componentProps = { ...svgDefaults };\n    // Check mode\n    const mode = props.mode || 'svg';\n    // Copy style\n    const style = {};\n    const propsStyle = props.style;\n    const customStyle = typeof propsStyle === 'object' && !(propsStyle instanceof Array)\n        ? propsStyle\n        : {};\n    // Get element properties\n    for (let key in props) {\n        const value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch (key) {\n            // Properties to ignore\n            case 'icon':\n            case 'style':\n            case 'onLoad':\n            case 'mode':\n            case 'ssr':\n                break;\n            // Boolean attributes\n            case 'inline':\n            case 'hFlip':\n            case 'vFlip':\n                customisations[key] =\n                    value === true || value === 'true' || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case 'flip':\n                if (typeof value === 'string') {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: override style\n            case 'color':\n                style.color = value;\n                break;\n            // Rotation as string\n            case 'rotate':\n                if (typeof value === 'string') {\n                    customisations[key] = rotateFromString(value);\n                }\n                else if (typeof value === 'number') {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case 'ariaHidden':\n            case 'aria-hidden':\n                // Vue transforms 'aria-hidden' property to 'ariaHidden'\n                if (value !== true && value !== 'true') {\n                    delete componentProps['aria-hidden'];\n                }\n                break;\n            default: {\n                const alias = customisationAliases[key];\n                if (alias) {\n                    // Aliases for boolean customisations\n                    if (value === true || value === 'true' || value === 1) {\n                        customisations[alias] = true;\n                    }\n                }\n                else if (defaultExtendedIconCustomisations[key] === void 0) {\n                    // Copy missing property if it does not exist in customisations\n                    componentProps[key] = value;\n                }\n            }\n        }\n    }\n    // Generate icon\n    const item = iconToSVG(icon, customisations);\n    const renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = '-0.125em';\n    }\n    if (mode === 'svg') {\n        // Add style\n        componentProps.style = {\n            ...style,\n            ...customStyle,\n        };\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        let localCounter = 0;\n        let id = props.id;\n        if (typeof id === 'string') {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, '_');\n        }\n        // Add innerHTML and style to props\n        componentProps['innerHTML'] = replaceIDs(item.body, id ? () => id + 'ID' + localCounter++ : 'iconifyVue');\n        // Render icon\n        return h('svg', componentProps);\n    }\n    // Render <span> with style\n    const { body, width, height } = icon;\n    const useMask = mode === 'mask' ||\n        (mode === 'bg' ? false : body.indexOf('currentColor') !== -1);\n    // Generate SVG\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: width + '',\n        height: height + '',\n    });\n    // Generate style\n    componentProps.style = {\n        ...style,\n        '--svg': svgToURL(html),\n        'width': fixSize(renderAttribs.width),\n        'height': fixSize(renderAttribs.height),\n        ...commonProps,\n        ...(useMask ? monotoneProps : coloredProps),\n        ...customStyle,\n    };\n    return h('span', componentProps);\n};\n\n/**\n * Initialise stuff\n */\n// Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule('', fetchAPIModule);\n/**\n * Browser stuff\n */\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\n    const _window = window;\n    // Load icons from global \"IconifyPreload\"\n    if (_window.IconifyPreload !== void 0) {\n        const preload = _window.IconifyPreload;\n        const err = 'Invalid IconifyPreload syntax.';\n        if (typeof preload === 'object' && preload !== null) {\n            (preload instanceof Array ? preload : [preload]).forEach((item) => {\n                try {\n                    if (\n                    // Check if item is an object and not null/array\n                    typeof item !== 'object' ||\n                        item === null ||\n                        item instanceof Array ||\n                        // Check for 'icons' and 'prefix'\n                        typeof item.icons !== 'object' ||\n                        typeof item.prefix !== 'string' ||\n                        // Add icon set\n                        !addCollection(item)) {\n                        console.error(err);\n                    }\n                }\n                catch (e) {\n                    console.error(err);\n                }\n            });\n        }\n    }\n    // Set API from global \"IconifyProviders\"\n    if (_window.IconifyProviders !== void 0) {\n        const providers = _window.IconifyProviders;\n        if (typeof providers === 'object' && providers !== null) {\n            for (let key in providers) {\n                const err = 'IconifyProviders[' + key + '] is invalid.';\n                try {\n                    const value = providers[key];\n                    if (typeof value !== 'object' ||\n                        !value ||\n                        value.resources === void 0) {\n                        continue;\n                    }\n                    if (!addAPIProvider(key, value)) {\n                        console.error(err);\n                    }\n                }\n                catch (e) {\n                    console.error(err);\n                }\n            }\n        }\n    }\n}\n/**\n * Empty icon data, rendered when icon is not available\n */\nconst emptyIcon = {\n    ...defaultIconProps,\n    body: '',\n};\n/**\n * Component\n */\nconst Icon = defineComponent((props, { emit }) => {\n    const loader = ref(null);\n    function abortLoading() {\n        if (loader.value) {\n            loader.value.abort?.();\n            loader.value = null;\n        }\n    }\n    // Render state\n    const rendering = ref(!!props.ssr);\n    const lastRenderedIconName = ref('');\n    const iconData = shallowRef(null);\n    // Update icon data\n    function getIcon() {\n        const icon = props.icon;\n        // Icon is an object\n        if (typeof icon === 'object' &&\n            icon !== null &&\n            typeof icon.body === 'string') {\n            lastRenderedIconName.value = '';\n            return {\n                data: icon,\n            };\n        }\n        // Check for valid icon name\n        let iconName;\n        if (typeof icon !== 'string' ||\n            (iconName = stringToIcon(icon, false, true)) === null) {\n            return null;\n        }\n        // Load icon\n        let data = getIconData(iconName);\n        if (!data) {\n            // Icon data is not available\n            const oldState = loader.value;\n            if (!oldState || oldState.name !== icon) {\n                // Icon name does not match old loader state\n                if (data === null) {\n                    // Failed to load\n                    loader.value = {\n                        name: icon,\n                    };\n                }\n                else {\n                    loader.value = {\n                        name: icon,\n                        abort: loadIcons([iconName], updateIconData),\n                    };\n                }\n            }\n            return null;\n        }\n        // Icon data is available\n        abortLoading();\n        if (lastRenderedIconName.value !== icon) {\n            lastRenderedIconName.value = icon;\n            // Emit on next tick because render will be called on next tick\n            nextTick(() => {\n                emit('load', icon);\n            });\n        }\n        // Customise icon\n        const customise = props.customise;\n        if (customise) {\n            // Clone data and customise it\n            data = Object.assign({}, data);\n            const customised = customise(data.body, iconName.name, iconName.prefix, iconName.provider);\n            if (typeof customised === 'string') {\n                data.body = customised;\n            }\n        }\n        // Add classes\n        const classes = ['iconify'];\n        if (iconName.prefix !== '') {\n            classes.push('iconify--' + iconName.prefix);\n        }\n        if (iconName.provider !== '') {\n            classes.push('iconify--' + iconName.provider);\n        }\n        return { data, classes };\n    }\n    function updateIconData() {\n        const icon = getIcon();\n        if (!icon) {\n            iconData.value = null;\n        }\n        else if (icon.data !== iconData.value?.data) {\n            iconData.value = icon;\n        }\n    }\n    // Set icon data\n    if (rendering.value) {\n        updateIconData();\n    }\n    else {\n        onMounted(() => {\n            rendering.value = true;\n            updateIconData();\n        });\n    }\n    watch(() => props.icon, updateIconData);\n    // Abort loading on unmount\n    onUnmounted(abortLoading);\n    // Render function\n    return () => {\n        // Get icon data\n        const icon = iconData.value;\n        if (!icon) {\n            // Icon is not available\n            return render(emptyIcon, props);\n        }\n        // Add classes\n        let newProps = props;\n        if (icon.classes) {\n            newProps = {\n                ...props,\n                class: icon.classes.join(' '),\n            };\n        }\n        // Render icon\n        return render({\n            ...defaultIconProps,\n            ...icon.data,\n        }, newProps);\n    };\n}, {\n    props: [\n        // Icon and render mode\n        'icon',\n        'mode',\n        'ssr',\n        // Layout and style\n        'width',\n        'height',\n        'style',\n        'color',\n        'inline',\n        // Transformations\n        'rotate',\n        'hFlip',\n        'horizontalFlip',\n        'vFlip',\n        'verticalFlip',\n        'flip',\n        // Misc\n        'id',\n        'ariaHidden',\n        'customise',\n        'title',\n    ],\n    emits: ['load'],\n});\n/**\n * Internal API\n */\nconst _api = {\n    getAPIConfig,\n    setAPIModule,\n    sendAPIQuery,\n    setFetch,\n    getFetch,\n    listAPIProviders,\n};\n\nexport { Icon, _api, addAPIProvider, addCollection, addIcon, iconToSVG as buildIcon, calculateSize, getIcon, iconLoaded, listIcons, loadIcon, loadIcons, replaceIDs, setCustomIconLoader, setCustomIconsLoader };\n","import { buildUrl } from '@datadog/browser-core';\nimport { getParentNode, isNodeShadowRoot, CENSORED_STRING_MARK, shouldMaskNode } from '@datadog/browser-rum-core';\nconst serializedNodeIds = new WeakMap();\nexport function hasSerializedNode(node) {\n    return serializedNodeIds.has(node);\n}\nexport function nodeAndAncestorsHaveSerializedNode(node) {\n    let current = node;\n    while (current) {\n        if (!hasSerializedNode(current) && !isNodeShadowRoot(current)) {\n            return false;\n        }\n        current = getParentNode(current);\n    }\n    return true;\n}\nexport function getSerializedNodeId(node) {\n    return serializedNodeIds.get(node);\n}\nexport function setSerializedNodeId(node, serializeNodeId) {\n    serializedNodeIds.set(node, serializeNodeId);\n}\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element, nodePrivacyLevel) {\n    /*\n     BROWSER SPEC NOTE: <input>, <select>\n     For some <input> elements, the `value` is an exceptional property/attribute that has the\n     value synced between el.value and el.getAttribute()\n     input[type=button,checkbox,hidden,image,radio,reset,submit]\n     */\n    const tagName = element.tagName;\n    const value = element.value;\n    if (shouldMaskNode(element, nodePrivacyLevel)) {\n        const type = element.type;\n        if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n            // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n            // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n            return value;\n        }\n        else if (!value || tagName === 'OPTION') {\n            // <Option> value provides no benefit\n            return;\n        }\n        return CENSORED_STRING_MARK;\n    }\n    if (tagName === 'OPTION' || tagName === 'SELECT') {\n        return element.value;\n    }\n    if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n        return;\n    }\n    return value;\n}\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//;\nexport const DATA_URI = /^data:.*,/i;\nexport function switchToAbsoluteUrl(cssText, cssHref) {\n    return cssText.replace(URL_IN_CSS_REF, (matchingSubstring, singleQuote, urlWrappedInSingleQuotes, doubleQuote, urlWrappedInDoubleQuotes, urlNotWrappedInQuotes) => {\n        const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes;\n        if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n            return matchingSubstring;\n        }\n        const quote = singleQuote || doubleQuote || '';\n        return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`;\n    });\n}\nexport function makeUrlAbsolute(url, baseUrl) {\n    try {\n        return buildUrl(url, baseUrl).href;\n    }\n    catch (_a) {\n        return url;\n    }\n}\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/;\nexport function getValidTagName(tagName) {\n    const processedTagName = tagName.toLowerCase().trim();\n    if (TAG_NAME_REGEX.test(processedTagName)) {\n        // if the tag name is odd and we cannot extract\n        // anything from the string, then we return a\n        // generic div\n        return 'div';\n    }\n    return processedTagName;\n}\nexport function censoredImageForSize(width, height) {\n    return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' style='background-color:silver'%3E%3C/svg%3E`;\n}\n//# sourceMappingURL=serializationUtils.js.map","export const RecordType = {\n    FullSnapshot: 2,\n    IncrementalSnapshot: 3,\n    Meta: 4,\n    Focus: 6,\n    ViewEnd: 7,\n    VisualViewport: 8,\n    FrustrationRecord: 9,\n};\nexport const NodeType = {\n    Document: 0,\n    DocumentType: 1,\n    Element: 2,\n    Text: 3,\n    CDATA: 4,\n    DocumentFragment: 11,\n};\nexport const IncrementalSource = {\n    Mutation: 0,\n    MouseMove: 1,\n    MouseInteraction: 2,\n    Scroll: 3,\n    ViewportResize: 4,\n    Input: 5,\n    TouchMove: 6,\n    MediaInteraction: 7,\n    StyleSheetRule: 8,\n    // CanvasMutation : 9,\n    // Font : 10,\n};\nexport const MouseInteractionType = {\n    MouseUp: 0,\n    MouseDown: 1,\n    Click: 2,\n    ContextMenu: 3,\n    DblClick: 4,\n    Focus: 5,\n    Blur: 6,\n    TouchStart: 7,\n    TouchEnd: 9,\n};\nexport const MediaInteractionType = {\n    Play: 0,\n    Pause: 1,\n};\n//# sourceMappingURL=sessionReplayConstants.js.map","export function serializeStyleSheets(cssStyleSheets) {\n    if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n        return undefined;\n    }\n    return cssStyleSheets.map((cssStyleSheet) => {\n        const rules = cssStyleSheet.cssRules || cssStyleSheet.rules;\n        const cssRules = Array.from(rules, (cssRule) => cssRule.cssText);\n        const styleSheet = {\n            cssRules,\n            disabled: cssStyleSheet.disabled || undefined,\n            media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n        };\n        return styleSheet;\n    });\n}\n//# sourceMappingURL=serializeStyleSheets.js.map","import { NodePrivacyLevel, PRIVACY_ATTR_NAME, CENSORED_STRING_MARK, CENSORED_IMG_MARK, STABLE_ATTRIBUTES, isLongDataUrl, sanitizeDataUrl, } from '@datadog/browser-rum-core';\nimport { censoredImageForSize } from './serializationUtils';\nexport function serializeAttribute(element, nodePrivacyLevel, attributeName, configuration) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        // dup condition for direct access case\n        return null;\n    }\n    const attributeValue = element.getAttribute(attributeName);\n    if (nodePrivacyLevel === NodePrivacyLevel.MASK &&\n        attributeName !== PRIVACY_ATTR_NAME &&\n        !STABLE_ATTRIBUTES.includes(attributeName) &&\n        attributeName !== configuration.actionNameAttribute) {\n        const tagName = element.tagName;\n        switch (attributeName) {\n            // Mask Attribute text content\n            case 'title':\n            case 'alt':\n            case 'placeholder':\n                return CENSORED_STRING_MARK;\n        }\n        // mask image URLs\n        if (tagName === 'IMG' && (attributeName === 'src' || attributeName === 'srcset')) {\n            // generate image with similar dimension than the original to have the same rendering behaviour\n            const image = element;\n            if (image.naturalWidth > 0) {\n                return censoredImageForSize(image.naturalWidth, image.naturalHeight);\n            }\n            const { width, height } = element.getBoundingClientRect();\n            if (width > 0 || height > 0) {\n                return censoredImageForSize(width, height);\n            }\n            // if we can't get the image size, fallback to the censored image\n            return CENSORED_IMG_MARK;\n        }\n        // mask source URLs\n        if (tagName === 'SOURCE' && (attributeName === 'src' || attributeName === 'srcset')) {\n            return CENSORED_IMG_MARK;\n        }\n        // mask <a> URLs\n        if (tagName === 'A' && attributeName === 'href') {\n            return CENSORED_STRING_MARK;\n        }\n        // mask data-* attributes\n        if (attributeValue && attributeName.startsWith('data-')) {\n            // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n            return CENSORED_STRING_MARK;\n        }\n        // mask iframe srcdoc\n        if (tagName === 'IFRAME' && attributeName === 'srcdoc') {\n            return CENSORED_STRING_MARK;\n        }\n    }\n    if (!attributeValue || typeof attributeValue !== 'string') {\n        return attributeValue;\n    }\n    // Minimum Fix for customer.\n    if (isLongDataUrl(attributeValue)) {\n        return sanitizeDataUrl(attributeValue);\n    }\n    return attributeValue;\n}\n//# sourceMappingURL=serializeAttribute.js.map","import { NodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';\nimport { isSafari } from '@datadog/browser-core';\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils';\nimport { serializeAttribute } from './serializeAttribute';\nexport function serializeAttributes(element, nodePrivacyLevel, options) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        return {};\n    }\n    const safeAttrs = {};\n    const tagName = getValidTagName(element.tagName);\n    const doc = element.ownerDocument;\n    for (let i = 0; i < element.attributes.length; i += 1) {\n        const attribute = element.attributes.item(i);\n        const attributeName = attribute.name;\n        const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration);\n        if (attributeValue !== null) {\n            safeAttrs[attributeName] = attributeValue;\n        }\n    }\n    if (element.value &&\n        (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {\n        const formValue = getElementInputValue(element, nodePrivacyLevel);\n        if (formValue !== undefined) {\n            safeAttrs.value = formValue;\n        }\n    }\n    /**\n     * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n     */\n    if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n        // For privacy=`MASK`, all the values would be the same, so skip.\n        const optionElement = element;\n        if (optionElement.selected) {\n            safeAttrs.selected = optionElement.selected;\n        }\n    }\n    // remote css\n    if (tagName === 'link') {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === element.href);\n        const cssText = getCssRulesString(stylesheet);\n        if (cssText && stylesheet) {\n            safeAttrs._cssText = cssText;\n        }\n    }\n    // dynamic stylesheet\n    if (tagName === 'style' && element.sheet) {\n        const cssText = getCssRulesString(element.sheet);\n        if (cssText) {\n            safeAttrs._cssText = cssText;\n        }\n    }\n    /**\n     * Forms: input[type=checkbox,radio]\n     * The `checked` property for <input> is a little bit special:\n     * 1. el.checked is a setter that returns if truthy.\n     * 2. getAttribute returns the string value\n     * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n     * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n     */\n    const inputElement = element;\n    if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n        if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n            safeAttrs.checked = !!inputElement.checked;\n        }\n        else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n            delete safeAttrs.checked;\n        }\n    }\n    /**\n     * Serialize the media playback state\n     */\n    if (tagName === 'audio' || tagName === 'video') {\n        const mediaElement = element;\n        safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';\n    }\n    /**\n     * Serialize the scroll state for each element only for full snapshot\n     */\n    let scrollTop;\n    let scrollLeft;\n    const serializationContext = options.serializationContext;\n    switch (serializationContext.status) {\n        case 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */:\n            scrollTop = Math.round(element.scrollTop);\n            scrollLeft = Math.round(element.scrollLeft);\n            if (scrollTop || scrollLeft) {\n                serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft });\n            }\n            break;\n        case 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */:\n            if (serializationContext.elementsScrollPositions.has(element)) {\n                ;\n                ({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element));\n            }\n            break;\n    }\n    if (scrollLeft) {\n        safeAttrs.rr_scrollLeft = scrollLeft;\n    }\n    if (scrollTop) {\n        safeAttrs.rr_scrollTop = scrollTop;\n    }\n    return safeAttrs;\n}\nexport function getCssRulesString(cssStyleSheet) {\n    if (!cssStyleSheet) {\n        return null;\n    }\n    let rules;\n    try {\n        rules = cssStyleSheet.rules || cssStyleSheet.cssRules;\n    }\n    catch (_a) {\n        // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n    }\n    if (!rules) {\n        return null;\n    }\n    const styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('');\n    return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href);\n}\nfunction getCssRuleStringForSafari(rule) {\n    // Safari does not escape attribute selectors containing : properly\n    // https://bugs.webkit.org/show_bug.cgi?id=184604\n    if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n        // This regex replaces [foo:bar] by [foo\\\\:bar]\n        const escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g;\n        return rule.cssText.replace(escapeColon, '$1\\\\$2');\n    }\n    return getCssRuleString(rule);\n}\nfunction getCssRuleString(rule) {\n    // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n    // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n    // to the @import rule CSS text.\n    return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction isCSSStyleRule(rule) {\n    return 'selectorText' in rule;\n}\n//# sourceMappingURL=serializeAttributes.js.map","import { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent, isNodeShadowRoot, hasChildNodes, forEachChildNodes, NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN, } from '@datadog/browser-rum-core';\nimport { NodeType } from '../../../types';\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils';\nimport { serializeStyleSheets } from './serializeStyleSheets';\nimport { serializeAttributes } from './serializeAttributes';\nexport function serializeNodeWithId(node, options) {\n    const serializedNode = serializeNode(node, options);\n    if (!serializedNode) {\n        return null;\n    }\n    // Try to reuse the previous id\n    const id = getSerializedNodeId(node) || generateNextId();\n    const serializedNodeWithId = serializedNode;\n    serializedNodeWithId.id = id;\n    setSerializedNodeId(node, id);\n    if (options.serializedNodeIds) {\n        options.serializedNodeIds.add(id);\n    }\n    return serializedNodeWithId;\n}\nlet _nextId = 1;\nexport function generateNextId() {\n    return _nextId++;\n}\nexport function serializeChildNodes(node, options) {\n    const result = [];\n    forEachChildNodes(node, (childNode) => {\n        const serializedChildNode = serializeNodeWithId(childNode, options);\n        if (serializedChildNode) {\n            result.push(serializedChildNode);\n        }\n    });\n    return result;\n}\nfunction serializeNode(node, options) {\n    switch (node.nodeType) {\n        case node.DOCUMENT_NODE:\n            return serializeDocumentNode(node, options);\n        case node.DOCUMENT_FRAGMENT_NODE:\n            return serializeDocumentFragmentNode(node, options);\n        case node.DOCUMENT_TYPE_NODE:\n            return serializeDocumentTypeNode(node);\n        case node.ELEMENT_NODE:\n            return serializeElementNode(node, options);\n        case node.TEXT_NODE:\n            return serializeTextNode(node, options);\n        case node.CDATA_SECTION_NODE:\n            return serializeCDataNode();\n    }\n}\nexport function serializeDocumentNode(document, options) {\n    return {\n        type: NodeType.Document,\n        childNodes: serializeChildNodes(document, options),\n        adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n    };\n}\nfunction serializeDocumentFragmentNode(element, options) {\n    const isShadowRoot = isNodeShadowRoot(element);\n    if (isShadowRoot) {\n        options.serializationContext.shadowRootsController.addShadowRoot(element);\n    }\n    return {\n        type: NodeType.DocumentFragment,\n        childNodes: serializeChildNodes(element, options),\n        isShadowRoot,\n        adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n    };\n}\nfunction serializeDocumentTypeNode(documentType) {\n    return {\n        type: NodeType.DocumentType,\n        name: documentType.name,\n        publicId: documentType.publicId,\n        systemId: documentType.systemId,\n    };\n}\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nfunction serializeElementNode(element, options) {\n    const tagName = getValidTagName(element.tagName);\n    const isSVG = isSVGElement(element) || undefined;\n    // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n    // parentNodePrivacyLevel option to avoid iterating over all parents\n    const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel);\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        const { width, height } = element.getBoundingClientRect();\n        return {\n            type: NodeType.Element,\n            tagName,\n            attributes: {\n                rr_width: `${width}px`,\n                rr_height: `${height}px`,\n                [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n            },\n            childNodes: [],\n            isSVG,\n        };\n    }\n    // Ignore Elements like Script and some Link, Metas\n    if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n        return;\n    }\n    const attributes = serializeAttributes(element, nodePrivacyLevel, options);\n    let childNodes = [];\n    if (hasChildNodes(element) &&\n        // Do not serialize style children as the css rules are already in the _cssText attribute\n        tagName !== 'style') {\n        // OBJECT POOLING OPTIMIZATION:\n        // We should not create a new object systematically as it could impact performances. Try to reuse\n        // the same object as much as possible, and clone it only if we need to.\n        let childNodesSerializationOptions;\n        if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n            childNodesSerializationOptions = options;\n        }\n        else {\n            childNodesSerializationOptions = {\n                ...options,\n                parentNodePrivacyLevel: nodePrivacyLevel,\n                ignoreWhiteSpace: tagName === 'head',\n            };\n        }\n        childNodes = serializeChildNodes(element, childNodesSerializationOptions);\n    }\n    return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes,\n        isSVG,\n    };\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode, options) {\n    const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);\n    if (textContent === undefined) {\n        return;\n    }\n    return {\n        type: NodeType.Text,\n        textContent,\n    };\n}\nfunction serializeCDataNode() {\n    return {\n        type: NodeType.CDATA,\n        textContent: '',\n    };\n}\n//# sourceMappingURL=serializeNode.js.map","import { serializeNodeWithId } from './serializeNode';\nexport function serializeDocument(document, configuration, serializationContext) {\n    // We are sure that Documents are never ignored, so this function never returns null\n    return serializeNodeWithId(document, {\n        serializationContext,\n        parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n        configuration,\n    });\n}\n//# sourceMappingURL=serializeDocument.js.map","import { isNodeShadowHost } from '@datadog/browser-rum-core';\nexport function isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nexport function getEventTarget(event) {\n    if (event.composed === true && isNodeShadowHost(event.target)) {\n        return event.composedPath()[0];\n    }\n    return event.target;\n}\n//# sourceMappingURL=eventsUtils.js.map","/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25;\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport) {\n    return (Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n        Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE);\n}\nexport const convertMouseEventToLayoutCoordinates = (clientX, clientY) => {\n    const visualViewport = window.visualViewport;\n    const normalized = {\n        layoutViewportX: clientX,\n        layoutViewportY: clientY,\n        visualViewportX: clientX,\n        visualViewportY: clientY,\n    };\n    if (!visualViewport) {\n        // On old browsers, we cannot normalize, so fallback to clientX/Y\n        return normalized;\n    }\n    else if (isVisualViewportFactoredIn(visualViewport)) {\n        // Typically Mobile Devices\n        normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft);\n        normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop);\n    }\n    else {\n        // Typically Desktop Devices\n        normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft);\n        normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop);\n    }\n    return normalized;\n};\nexport const getVisualViewport = (visualViewport) => ({\n    scale: visualViewport.scale,\n    offsetLeft: visualViewport.offsetLeft,\n    offsetTop: visualViewport.offsetTop,\n    pageLeft: visualViewport.pageLeft,\n    pageTop: visualViewport.pageTop,\n    height: visualViewport.height,\n    width: visualViewport.width,\n});\n//# sourceMappingURL=viewports.js.map","import { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nexport function assembleIncrementalSnapshot(source, data) {\n    return {\n        data: {\n            source,\n            ...data,\n        },\n        type: RecordType.IncrementalSnapshot,\n        timestamp: timeStampNow(),\n    };\n}\n//# sourceMappingURL=assembly.js.map","import { addEventListeners, addTelemetryDebug, throttle } from '@datadog/browser-core';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget, isTouchEvent } from '../eventsUtils';\nimport { convertMouseEventToLayoutCoordinates } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50;\nexport function trackMove(configuration, moveCb) {\n    const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {\n        const target = getEventTarget(event);\n        if (hasSerializedNode(target)) {\n            const coordinates = tryToComputeCoordinates(event);\n            if (!coordinates) {\n                return;\n            }\n            const position = {\n                id: getSerializedNodeId(target),\n                timeOffset: 0,\n                x: coordinates.x,\n                y: coordinates.y,\n            };\n            moveCb(assembleIncrementalSnapshot(isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove, { positions: [position] }));\n        }\n    }, MOUSE_MOVE_OBSERVER_THRESHOLD, {\n        trailing: false,\n    });\n    const { stop: removeListener } = addEventListeners(configuration, document, [\"mousemove\" /* DOM_EVENT.MOUSE_MOVE */, \"touchmove\" /* DOM_EVENT.TOUCH_MOVE */], updatePosition, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\nexport function tryToComputeCoordinates(event) {\n    let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event;\n    if (window.visualViewport) {\n        const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y);\n        x = visualViewportX;\n        y = visualViewportY;\n    }\n    if (!Number.isFinite(x) || !Number.isFinite(y)) {\n        if (event.isTrusted) {\n            addTelemetryDebug('mouse/touch event without x/y');\n        }\n        return undefined;\n    }\n    return { x, y };\n}\n//# sourceMappingURL=trackMove.js.map","import { addEventListeners } from '@datadog/browser-core';\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MouseInteractionType } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { tryToComputeCoordinates } from './trackMove';\nconst eventTypeToMouseInteraction = {\n    // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n    // allows to reference such records from Frustration records.\n    //\n    // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n    // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n    // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n    // convey such interaction. This would cleanly solve the issue since we would have\n    // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n    [\"pointerup\" /* DOM_EVENT.POINTER_UP */]: MouseInteractionType.MouseUp,\n    [\"mousedown\" /* DOM_EVENT.MOUSE_DOWN */]: MouseInteractionType.MouseDown,\n    [\"click\" /* DOM_EVENT.CLICK */]: MouseInteractionType.Click,\n    [\"contextmenu\" /* DOM_EVENT.CONTEXT_MENU */]: MouseInteractionType.ContextMenu,\n    [\"dblclick\" /* DOM_EVENT.DBL_CLICK */]: MouseInteractionType.DblClick,\n    [\"focus\" /* DOM_EVENT.FOCUS */]: MouseInteractionType.Focus,\n    [\"blur\" /* DOM_EVENT.BLUR */]: MouseInteractionType.Blur,\n    [\"touchstart\" /* DOM_EVENT.TOUCH_START */]: MouseInteractionType.TouchStart,\n    [\"touchend\" /* DOM_EVENT.TOUCH_END */]: MouseInteractionType.TouchEnd,\n};\nexport function trackMouseInteraction(configuration, mouseInteractionCb, recordIds) {\n    const handler = (event) => {\n        const target = getEventTarget(event);\n        if (getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        const id = getSerializedNodeId(target);\n        const type = eventTypeToMouseInteraction[event.type];\n        let interaction;\n        if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n            const coordinates = tryToComputeCoordinates(event);\n            if (!coordinates) {\n                return;\n            }\n            interaction = { id, type, x: coordinates.x, y: coordinates.y };\n        }\n        else {\n            interaction = { id, type };\n        }\n        const record = {\n            id: recordIds.getIdForEvent(event),\n            ...assembleIncrementalSnapshot(IncrementalSource.MouseInteraction, interaction),\n        };\n        mouseInteractionCb(record);\n    };\n    return addEventListeners(configuration, document, Object.keys(eventTypeToMouseInteraction), handler, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMouseInteraction.js.map","import { throttle, addEventListener } from '@datadog/browser-core';\nimport { getScrollX, getScrollY, getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { IncrementalSource } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst SCROLL_OBSERVER_THRESHOLD = 100;\nexport function trackScroll(configuration, scrollCb, elementsScrollPositions, target = document) {\n    const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {\n        const target = getEventTarget(event);\n        if (!target ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        const id = getSerializedNodeId(target);\n        const scrollPositions = target === document\n            ? {\n                scrollTop: getScrollY(),\n                scrollLeft: getScrollX(),\n            }\n            : {\n                scrollTop: Math.round(target.scrollTop),\n                scrollLeft: Math.round(target.scrollLeft),\n            };\n        elementsScrollPositions.set(target, scrollPositions);\n        scrollCb(assembleIncrementalSnapshot(IncrementalSource.Scroll, {\n            id,\n            x: scrollPositions.scrollLeft,\n            y: scrollPositions.scrollTop,\n        }));\n    }, SCROLL_OBSERVER_THRESHOLD);\n    const { stop: removeListener } = addEventListener(configuration, target, \"scroll\" /* DOM_EVENT.SCROLL */, updatePosition, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackScroll.js.map","import { throttle, addEventListeners, timeStampNow, noop } from '@datadog/browser-core';\nimport { initViewportObservable } from '@datadog/browser-rum-core';\nimport { IncrementalSource, RecordType } from '../../../types';\nimport { getVisualViewport } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200;\nexport function trackViewportResize(configuration, viewportResizeCb) {\n    const viewportResizeSubscription = initViewportObservable(configuration).subscribe((data) => {\n        viewportResizeCb(assembleIncrementalSnapshot(IncrementalSource.ViewportResize, data));\n    });\n    return {\n        stop: () => {\n            viewportResizeSubscription.unsubscribe();\n        },\n    };\n}\nexport function trackVisualViewportResize(configuration, visualViewportResizeCb) {\n    const visualViewport = window.visualViewport;\n    if (!visualViewport) {\n        return { stop: noop };\n    }\n    const { throttled: updateDimension, cancel: cancelThrottle } = throttle(() => {\n        visualViewportResizeCb({\n            data: getVisualViewport(visualViewport),\n            type: RecordType.VisualViewport,\n            timestamp: timeStampNow(),\n        });\n    }, VISUAL_VIEWPORT_OBSERVER_THRESHOLD, {\n        trailing: false,\n    });\n    const { stop: removeListener } = addEventListeners(configuration, visualViewport, [\"resize\" /* DOM_EVENT.RESIZE */, \"scroll\" /* DOM_EVENT.SCROLL */], updateDimension, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackViewportResize.js.map","import { addEventListeners } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MediaInteractionType } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackMediaInteraction(configuration, mediaInteractionCb) {\n    return addEventListeners(configuration, document, [\"play\" /* DOM_EVENT.PLAY */, \"pause\" /* DOM_EVENT.PAUSE */], (event) => {\n        const target = getEventTarget(event);\n        if (!target ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        mediaInteractionCb(assembleIncrementalSnapshot(IncrementalSource.MediaInteraction, {\n            id: getSerializedNodeId(target),\n            type: event.type === \"play\" /* DOM_EVENT.PLAY */ ? MediaInteractionType.Play : MediaInteractionType.Pause,\n        }));\n    }, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMediaInteraction.js.map","import { instrumentMethod } from '@datadog/browser-core';\nimport { IncrementalSource } from '../../../types';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackStyleSheet(styleSheetCb) {\n    function checkStyleSheetAndCallback(styleSheet, callback) {\n        if (styleSheet && hasSerializedNode(styleSheet.ownerNode)) {\n            callback(getSerializedNodeId(styleSheet.ownerNode));\n        }\n    }\n    const instrumentationStoppers = [\n        instrumentMethod(CSSStyleSheet.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                id,\n                adds: [{ rule, index }],\n            })));\n        }),\n        instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                id,\n                removes: [{ index }],\n            })));\n        }),\n    ];\n    if (typeof CSSGroupingRule !== 'undefined') {\n        instrumentGroupingCSSRuleClass(CSSGroupingRule);\n    }\n    else {\n        instrumentGroupingCSSRuleClass(CSSMediaRule);\n        instrumentGroupingCSSRuleClass(CSSSupportsRule);\n    }\n    function instrumentGroupingCSSRuleClass(cls) {\n        instrumentationStoppers.push(instrumentMethod(cls.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n                const path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index || 0);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id,\n                        adds: [{ rule, index: path }],\n                    }));\n                }\n            });\n        }), instrumentMethod(cls.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n                const path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id,\n                        removes: [{ index: path }],\n                    }));\n                }\n            });\n        }));\n    }\n    return {\n        stop: () => {\n            instrumentationStoppers.forEach((stopper) => stopper.stop());\n        },\n    };\n}\nexport function getPathToNestedCSSRule(rule) {\n    const path = [];\n    let currentRule = rule;\n    while (currentRule.parentRule) {\n        const rules = Array.from(currentRule.parentRule.cssRules);\n        const index = rules.indexOf(currentRule);\n        path.unshift(index);\n        currentRule = currentRule.parentRule;\n    }\n    // A rule may not be attached to a stylesheet\n    if (!currentRule.parentStyleSheet) {\n        return;\n    }\n    const rules = Array.from(currentRule.parentStyleSheet.cssRules);\n    const index = rules.indexOf(currentRule);\n    path.unshift(index);\n    return path;\n}\n//# sourceMappingURL=trackStyleSheet.js.map","import { addEventListeners, timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackFocus(configuration, focusCb) {\n    return addEventListeners(configuration, window, [\"focus\" /* DOM_EVENT.FOCUS */, \"blur\" /* DOM_EVENT.BLUR */], () => {\n        focusCb({\n            data: { has_focus: document.hasFocus() },\n            type: RecordType.Focus,\n            timestamp: timeStampNow(),\n        });\n    });\n}\n//# sourceMappingURL=trackFocus.js.map","import { RecordType } from '../../../types';\nexport function trackFrustration(lifeCycle, frustrationCb, recordIds) {\n    const frustrationSubscription = lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, (data) => {\n        var _a, _b;\n        if (data.rawRumEvent.type === \"action\" /* RumEventType.ACTION */ &&\n            data.rawRumEvent.action.type === \"click\" /* ActionType.CLICK */ &&\n            ((_b = (_a = data.rawRumEvent.action.frustration) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.length) &&\n            'events' in data.domainContext &&\n            data.domainContext.events &&\n            data.domainContext.events.length) {\n            frustrationCb({\n                timestamp: data.rawRumEvent.date,\n                type: RecordType.FrustrationRecord,\n                data: {\n                    frustrationTypes: data.rawRumEvent.action.frustration.type,\n                    recordIds: data.domainContext.events.map((e) => recordIds.getIdForEvent(e)),\n                },\n            });\n        }\n    });\n    return {\n        stop: () => {\n            frustrationSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackFrustration.js.map","import { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackViewEnd(lifeCycle, viewEndCb) {\n    const viewEndSubscription = lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, () => {\n        viewEndCb({\n            timestamp: timeStampNow(),\n            type: RecordType.ViewEnd,\n        });\n    });\n    return {\n        stop: () => {\n            viewEndSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackViewEnd.js.map","import { instrumentSetter, addEventListeners, noop } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackInput(configuration, inputCb, target = document) {\n    const defaultPrivacyLevel = configuration.defaultPrivacyLevel;\n    const lastInputStateMap = new WeakMap();\n    const isShadowRoot = target !== document;\n    const { stop: stopEventListeners } = addEventListeners(configuration, target, \n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [\"change\" /* DOM_EVENT.CHANGE */] : [\"input\" /* DOM_EVENT.INPUT */, \"change\" /* DOM_EVENT.CHANGE */], (event) => {\n        const target = getEventTarget(event);\n        if (target instanceof HTMLInputElement ||\n            target instanceof HTMLTextAreaElement ||\n            target instanceof HTMLSelectElement) {\n            onElementChange(target);\n        }\n    }, {\n        capture: true,\n        passive: true,\n    });\n    let stopPropertySetterInstrumentation;\n    if (!isShadowRoot) {\n        const instrumentationStoppers = [\n            instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n        ];\n        stopPropertySetterInstrumentation = () => {\n            instrumentationStoppers.forEach((stopper) => stopper.stop());\n        };\n    }\n    else {\n        stopPropertySetterInstrumentation = noop;\n    }\n    return {\n        stop: () => {\n            stopPropertySetterInstrumentation();\n            stopEventListeners();\n        },\n    };\n    function onElementChange(target) {\n        const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel);\n        if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n            return;\n        }\n        const type = target.type;\n        let inputState;\n        if (type === 'radio' || type === 'checkbox') {\n            if (shouldMaskNode(target, nodePrivacyLevel)) {\n                return;\n            }\n            inputState = { isChecked: target.checked };\n        }\n        else {\n            const value = getElementInputValue(target, nodePrivacyLevel);\n            if (value === undefined) {\n                return;\n            }\n            inputState = { text: value };\n        }\n        // Can be multiple changes on the same node within the same batched mutation observation.\n        cbWithDedup(target, inputState);\n        // If a radio was checked, other radios with the same name attribute will be unchecked.\n        const name = target.name;\n        if (type === 'radio' && name && target.checked) {\n            document.querySelectorAll(`input[type=\"radio\"][name=\"${CSS.escape(name)}\"]`).forEach((el) => {\n                if (el !== target) {\n                    // TODO: Consider the privacy implications for various differing input privacy levels\n                    cbWithDedup(el, { isChecked: false });\n                }\n            });\n        }\n    }\n    /**\n     * There can be multiple changes on the same node within the same batched mutation observation.\n     */\n    function cbWithDedup(target, inputState) {\n        if (!hasSerializedNode(target)) {\n            return;\n        }\n        const lastInputState = lastInputStateMap.get(target);\n        if (!lastInputState ||\n            lastInputState.text !== inputState.text ||\n            lastInputState.isChecked !== inputState.isChecked) {\n            lastInputStateMap.set(target, inputState);\n            inputCb(assembleIncrementalSnapshot(IncrementalSource.Input, {\n                id: getSerializedNodeId(target),\n                ...inputState,\n            }));\n        }\n    }\n}\n//# sourceMappingURL=trackInput.js.map","import { monitor, noop } from '@datadog/browser-core';\nimport { isNodeShadowHost, getMutationObserverConstructor, getParentNode, forEachChildNodes, getNodePrivacyLevel, getTextContent, NodePrivacyLevel, } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode, nodeAndAncestorsHaveSerializedNode, serializeNodeWithId, serializeAttribute, } from '../serialization';\nimport { createMutationBatch } from '../mutationBatch';\nimport { assembleIncrementalSnapshot } from '../assembly';\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(mutationCallback, configuration, shadowRootsController, target) {\n    const MutationObserver = getMutationObserverConstructor();\n    if (!MutationObserver) {\n        return { stop: noop, flush: noop };\n    }\n    const mutationBatch = createMutationBatch((mutations) => {\n        processMutations(mutations.concat(observer.takeRecords()), mutationCallback, configuration, shadowRootsController);\n    });\n    const observer = new MutationObserver(monitor(mutationBatch.addMutations));\n    observer.observe(target, {\n        attributeOldValue: true,\n        attributes: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true,\n    });\n    return {\n        stop: () => {\n            observer.disconnect();\n            mutationBatch.stop();\n        },\n        flush: () => {\n            mutationBatch.flush();\n        },\n    };\n}\nfunction processMutations(mutations, mutationCallback, configuration, shadowRootsController) {\n    const nodePrivacyLevelCache = new Map();\n    mutations\n        .filter((mutation) => mutation.type === 'childList')\n        .forEach((mutation) => {\n        mutation.removedNodes.forEach((removedNode) => {\n            traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot);\n        });\n    });\n    // Discard any mutation with a 'target' node that:\n    // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n    // part of a mutation occurring in a parent Node\n    // * should be hidden or ignored\n    const filteredMutations = mutations.filter((mutation) => mutation.target.isConnected &&\n        nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n        getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !==\n            NodePrivacyLevel.HIDDEN);\n    const { adds, removes, hasBeenSerialized } = processChildListMutations(filteredMutations.filter((mutation) => mutation.type === 'childList'), configuration, shadowRootsController, nodePrivacyLevelCache);\n    const texts = processCharacterDataMutations(filteredMutations.filter((mutation) => mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)), configuration, nodePrivacyLevelCache);\n    const attributes = processAttributesMutations(filteredMutations.filter((mutation) => mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)), configuration, nodePrivacyLevelCache);\n    if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n        return;\n    }\n    mutationCallback(assembleIncrementalSnapshot(IncrementalSource.Mutation, { adds, removes, texts, attributes }));\n}\nfunction processChildListMutations(mutations, configuration, shadowRootsController, nodePrivacyLevelCache) {\n    // First, we iterate over mutations to collect:\n    //\n    // * nodes that have been added in the document and not removed by a subsequent mutation\n    // * nodes that have been removed from the document but were not added in a previous mutation\n    //\n    // For this second category, we also collect their previous parent (mutation.target) because we'll\n    // need it to emit a 'remove' mutation.\n    //\n    // Those two categories may overlap: if a node moved from a position to another, it is reported as\n    // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n    // the node will be in both sets.\n    const addedAndMovedNodes = new Set();\n    const removedNodes = new Map();\n    for (const mutation of mutations) {\n        mutation.addedNodes.forEach((node) => {\n            addedAndMovedNodes.add(node);\n        });\n        mutation.removedNodes.forEach((node) => {\n            if (!addedAndMovedNodes.has(node)) {\n                removedNodes.set(node, mutation.target);\n            }\n            addedAndMovedNodes.delete(node);\n        });\n    }\n    // Then, we sort nodes that are still in the document by topological order, for two reasons:\n    //\n    // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n    // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n    // a precedent node.\n    //\n    // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n    // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n    // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n    // already serialized and have an id.\n    const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);\n    sortAddedAndMovedNodes(sortedAddedAndMovedNodes);\n    // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n    // node ids in a set to be able to skip subsequent related mutations.\n    const serializedNodeIds = new Set();\n    const addedNodeMutations = [];\n    for (const node of sortedAddedAndMovedNodes) {\n        if (hasBeenSerialized(node)) {\n            continue;\n        }\n        const parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        const serializedNode = serializeNodeWithId(node, {\n            serializedNodeIds,\n            parentNodePrivacyLevel,\n            serializationContext: { status: 2 /* SerializationContextStatus.MUTATION */, shadowRootsController },\n            configuration,\n        });\n        if (!serializedNode) {\n            continue;\n        }\n        const parentNode = getParentNode(node);\n        addedNodeMutations.push({\n            nextId: getNextSibling(node),\n            parentId: getSerializedNodeId(parentNode),\n            node: serializedNode,\n        });\n    }\n    // Finally, we emit remove mutations.\n    const removedNodeMutations = [];\n    removedNodes.forEach((parent, node) => {\n        if (hasSerializedNode(node)) {\n            removedNodeMutations.push({\n                parentId: getSerializedNodeId(parent),\n                id: getSerializedNodeId(node),\n            });\n        }\n    });\n    return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized };\n    function hasBeenSerialized(node) {\n        return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node));\n    }\n    function getNextSibling(node) {\n        let nextSibling = node.nextSibling;\n        while (nextSibling) {\n            if (hasSerializedNode(nextSibling)) {\n                return getSerializedNodeId(nextSibling);\n            }\n            nextSibling = nextSibling.nextSibling;\n        }\n        return null;\n    }\n}\nfunction processCharacterDataMutations(mutations, configuration, nodePrivacyLevelCache) {\n    var _a;\n    const textMutations = [];\n    // Deduplicate mutations based on their target node\n    const handledNodes = new Set();\n    const filteredMutations = mutations.filter((mutation) => {\n        if (handledNodes.has(mutation.target)) {\n            return false;\n        }\n        handledNodes.add(mutation.target);\n        return true;\n    });\n    // Emit mutations\n    for (const mutation of filteredMutations) {\n        const value = mutation.target.textContent;\n        if (value === mutation.oldValue) {\n            continue;\n        }\n        const parentNodePrivacyLevel = getNodePrivacyLevel(getParentNode(mutation.target), configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        textMutations.push({\n            id: getSerializedNodeId(mutation.target),\n            // TODO: pass a valid \"ignoreWhiteSpace\" argument\n            value: (_a = getTextContent(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null,\n        });\n    }\n    return textMutations;\n}\nfunction processAttributesMutations(mutations, configuration, nodePrivacyLevelCache) {\n    const attributeMutations = [];\n    // Deduplicate mutations based on their target node and changed attribute\n    const handledElements = new Map();\n    const filteredMutations = mutations.filter((mutation) => {\n        const handledAttributes = handledElements.get(mutation.target);\n        if (handledAttributes && handledAttributes.has(mutation.attributeName)) {\n            return false;\n        }\n        if (!handledAttributes) {\n            handledElements.set(mutation.target, new Set([mutation.attributeName]));\n        }\n        else {\n            handledAttributes.add(mutation.attributeName);\n        }\n        return true;\n    });\n    // Emit mutations\n    const emittedMutations = new Map();\n    for (const mutation of filteredMutations) {\n        const uncensoredValue = mutation.target.getAttribute(mutation.attributeName);\n        if (uncensoredValue === mutation.oldValue) {\n            continue;\n        }\n        const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName, configuration);\n        let transformedValue;\n        if (mutation.attributeName === 'value') {\n            const inputValue = getElementInputValue(mutation.target, privacyLevel);\n            if (inputValue === undefined) {\n                continue;\n            }\n            transformedValue = inputValue;\n        }\n        else if (typeof attributeValue === 'string') {\n            transformedValue = attributeValue;\n        }\n        else {\n            transformedValue = null;\n        }\n        let emittedMutation = emittedMutations.get(mutation.target);\n        if (!emittedMutation) {\n            emittedMutation = {\n                id: getSerializedNodeId(mutation.target),\n                attributes: {},\n            };\n            attributeMutations.push(emittedMutation);\n            emittedMutations.set(mutation.target, emittedMutation);\n        }\n        emittedMutation.attributes[mutation.attributeName] = transformedValue;\n    }\n    return attributeMutations;\n}\nexport function sortAddedAndMovedNodes(nodes) {\n    nodes.sort((a, b) => {\n        const position = a.compareDocumentPosition(b);\n        /* eslint-disable no-bitwise */\n        if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return -1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n            return -1;\n        }\n        /* eslint-enable no-bitwise */\n        return 0;\n    });\n}\nfunction traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {\n    if (isNodeShadowHost(removedNode)) {\n        shadowDomRemovedCallback(removedNode.shadowRoot);\n    }\n    forEachChildNodes(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback));\n}\n//# sourceMappingURL=trackMutation.js.map","import { noop, throttle, requestIdleCallback } from '@datadog/browser-core';\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100;\n/**\n * Minimum duration to wait before processing mutations. This is used to batch mutations together\n * and be able to deduplicate them to save processing time and bandwidth.\n * 16ms is the duration of a frame at 60fps that ensure fluid UI.\n */\nexport const MUTATION_PROCESS_MIN_DELAY = 16;\nexport function createMutationBatch(processMutationBatch) {\n    let cancelScheduledFlush = noop;\n    let pendingMutations = [];\n    function flush() {\n        cancelScheduledFlush();\n        processMutationBatch(pendingMutations);\n        pendingMutations = [];\n    }\n    const { throttled: throttledFlush, cancel: cancelThrottle } = throttle(flush, MUTATION_PROCESS_MIN_DELAY, {\n        leading: false,\n    });\n    return {\n        addMutations: (mutations) => {\n            if (pendingMutations.length === 0) {\n                cancelScheduledFlush = requestIdleCallback(throttledFlush, { timeout: MUTATION_PROCESS_MAX_DELAY });\n            }\n            pendingMutations.push(...mutations);\n        },\n        flush,\n        stop: () => {\n            cancelScheduledFlush();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=mutationBatch.js.map","import { sendToExtension } from '@datadog/browser-core';\nimport * as replayStats from '../replayStats';\nimport { trackFocus, trackFrustration, trackInput, trackMediaInteraction, trackMouseInteraction, trackMove, trackMutation, trackScroll, trackStyleSheet, trackViewEnd, trackViewportResize, trackVisualViewportResize, } from './trackers';\nimport { createElementsScrollPositions } from './elementsScrollPositions';\nimport { initShadowRootsController } from './shadowRootsController';\nimport { startFullSnapshots } from './startFullSnapshots';\nimport { initRecordIds } from './recordIds';\nexport function record(options) {\n    const { emit, configuration, lifeCycle } = options;\n    // runtime checks for user options\n    if (!emit) {\n        throw new Error('emit function is required');\n    }\n    const emitAndComputeStats = (record) => {\n        emit(record);\n        sendToExtension('record', { record });\n        const view = options.viewHistory.findView();\n        replayStats.addRecord(view.id);\n    };\n    const elementsScrollPositions = createElementsScrollPositions();\n    const shadowRootsController = initShadowRootsController(configuration, emitAndComputeStats, elementsScrollPositions);\n    const { stop: stopFullSnapshots } = startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, (records) => records.forEach((record) => emitAndComputeStats(record)));\n    function flushMutations() {\n        shadowRootsController.flush();\n        mutationTracker.flush();\n    }\n    const recordIds = initRecordIds();\n    const mutationTracker = trackMutation(emitAndComputeStats, configuration, shadowRootsController, document);\n    const trackers = [\n        mutationTracker,\n        trackMove(configuration, emitAndComputeStats),\n        trackMouseInteraction(configuration, emitAndComputeStats, recordIds),\n        trackScroll(configuration, emitAndComputeStats, elementsScrollPositions, document),\n        trackViewportResize(configuration, emitAndComputeStats),\n        trackInput(configuration, emitAndComputeStats),\n        trackMediaInteraction(configuration, emitAndComputeStats),\n        trackStyleSheet(emitAndComputeStats),\n        trackFocus(configuration, emitAndComputeStats),\n        trackVisualViewportResize(configuration, emitAndComputeStats),\n        trackFrustration(lifeCycle, emitAndComputeStats, recordIds),\n        trackViewEnd(lifeCycle, (viewEndRecord) => {\n            flushMutations();\n            emitAndComputeStats(viewEndRecord);\n        }),\n    ];\n    return {\n        stop: () => {\n            shadowRootsController.stop();\n            trackers.forEach((tracker) => tracker.stop());\n            stopFullSnapshots();\n        },\n        flushMutations,\n        shadowRootsController,\n    };\n}\n//# sourceMappingURL=record.js.map","export function createElementsScrollPositions() {\n    const scrollPositionsByElement = new WeakMap();\n    return {\n        set(element, scrollPositions) {\n            if (element === document && !document.scrollingElement) {\n                // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n                // in some cases scrolling elements can not be defined, we don't support those for now\n                return;\n            }\n            scrollPositionsByElement.set(element === document ? document.scrollingElement : element, scrollPositions);\n        },\n        get(element) {\n            return scrollPositionsByElement.get(element);\n        },\n        has(element) {\n            return scrollPositionsByElement.has(element);\n        },\n    };\n}\n//# sourceMappingURL=elementsScrollPositions.js.map","import { trackInput, trackMutation, trackScroll } from './trackers';\nexport const initShadowRootsController = (configuration, callback, elementsScrollPositions) => {\n    const controllerByShadowRoot = new Map();\n    const shadowRootsController = {\n        addShadowRoot: (shadowRoot) => {\n            if (controllerByShadowRoot.has(shadowRoot)) {\n                return;\n            }\n            const mutationTracker = trackMutation(callback, configuration, shadowRootsController, shadowRoot);\n            // The change event does not bubble up across the shadow root, we have to listen on the shadow root\n            const inputTracker = trackInput(configuration, callback, shadowRoot);\n            // The scroll event does not bubble up across the shadow root, we have to listen on the shadow root\n            const scrollTracker = trackScroll(configuration, callback, elementsScrollPositions, shadowRoot);\n            controllerByShadowRoot.set(shadowRoot, {\n                flush: () => mutationTracker.flush(),\n                stop: () => {\n                    mutationTracker.stop();\n                    inputTracker.stop();\n                    scrollTracker.stop();\n                },\n            });\n        },\n        removeShadowRoot: (shadowRoot) => {\n            const entry = controllerByShadowRoot.get(shadowRoot);\n            if (!entry) {\n                // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n                return;\n            }\n            entry.stop();\n            controllerByShadowRoot.delete(shadowRoot);\n        },\n        stop: () => {\n            controllerByShadowRoot.forEach(({ stop }) => stop());\n        },\n        flush: () => {\n            controllerByShadowRoot.forEach(({ flush }) => flush());\n        },\n    };\n    return shadowRootsController;\n};\n//# sourceMappingURL=shadowRootsController.js.map","import { getScrollX, getScrollY, getViewportDimension } from '@datadog/browser-rum-core';\nimport { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport { serializeDocument } from './serialization';\nimport { getVisualViewport } from './viewports';\nexport function startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, fullSnapshotCallback) {\n    const takeFullSnapshot = (timestamp = timeStampNow(), serializationContext = {\n        status: 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */,\n        elementsScrollPositions,\n        shadowRootsController,\n    }) => {\n        const { width, height } = getViewportDimension();\n        const records = [\n            {\n                data: {\n                    height,\n                    href: window.location.href,\n                    width,\n                },\n                type: RecordType.Meta,\n                timestamp,\n            },\n            {\n                data: {\n                    has_focus: document.hasFocus(),\n                },\n                type: RecordType.Focus,\n                timestamp,\n            },\n            {\n                data: {\n                    node: serializeDocument(document, configuration, serializationContext),\n                    initialOffset: {\n                        left: getScrollX(),\n                        top: getScrollY(),\n                    },\n                },\n                type: RecordType.FullSnapshot,\n                timestamp,\n            },\n        ];\n        if (window.visualViewport) {\n            records.push({\n                data: getVisualViewport(window.visualViewport),\n                type: RecordType.VisualViewport,\n                timestamp,\n            });\n        }\n        return records;\n    };\n    fullSnapshotCallback(takeFullSnapshot());\n    const { unsubscribe } = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, (view) => {\n        flushMutations();\n        fullSnapshotCallback(takeFullSnapshot(view.startClocks.timeStamp, {\n            shadowRootsController,\n            status: 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */,\n            elementsScrollPositions,\n        }));\n    });\n    return {\n        stop: unsubscribe,\n    };\n}\n//# sourceMappingURL=startFullSnapshots.js.map","export function initRecordIds() {\n    const recordIds = new WeakMap();\n    let nextId = 1;\n    return {\n        getIdForEvent(event) {\n            if (!recordIds.has(event)) {\n                recordIds.set(event, nextId++);\n            }\n            return recordIds.get(event);\n        },\n    };\n}\n//# sourceMappingURL=recordIds.js.map","import { RecordType } from '../../types';\nimport * as replayStats from '../replayStats';\nexport function createSegment({ context, creationReason, encoder, }) {\n    let encodedBytesCount = 0;\n    const viewId = context.view.id;\n    const metadata = {\n        start: Infinity,\n        end: -Infinity,\n        creation_reason: creationReason,\n        records_count: 0,\n        has_full_snapshot: false,\n        index_in_view: replayStats.getSegmentsCount(viewId),\n        source: 'browser',\n        ...context,\n    };\n    replayStats.addSegment(viewId);\n    function addRecord(record, callback) {\n        metadata.start = Math.min(metadata.start, record.timestamp);\n        metadata.end = Math.max(metadata.end, record.timestamp);\n        metadata.records_count += 1;\n        metadata.has_full_snapshot || (metadata.has_full_snapshot = record.type === RecordType.FullSnapshot);\n        const prefix = encoder.isEmpty ? '{\"records\":[' : ',';\n        encoder.write(prefix + JSON.stringify(record), (additionalEncodedBytesCount) => {\n            encodedBytesCount += additionalEncodedBytesCount;\n            callback(encodedBytesCount);\n        });\n    }\n    function flush(callback) {\n        if (encoder.isEmpty) {\n            throw new Error('Empty segment flushed');\n        }\n        encoder.write(`],${JSON.stringify(metadata).slice(1)}\\n`);\n        encoder.finish((encoderResult) => {\n            replayStats.addWroteData(metadata.view.id, encoderResult.rawBytesCount);\n            callback(metadata, encoderResult);\n        });\n    }\n    return { addRecord, flush };\n}\n//# sourceMappingURL=segment.js.map","import { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core';\nimport { buildReplayPayload } from './buildReplayPayload';\nimport { createSegment } from './segment';\nexport const SEGMENT_DURATION_LIMIT = 5 * ONE_SECOND;\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60000;\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\nexport function startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, httpRequest, encoder) {\n    return doStartSegmentCollection(lifeCycle, () => computeSegmentContext(configuration.applicationId, sessionManager, viewHistory), httpRequest, encoder);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, encoder) {\n    let state = {\n        status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n        nextSegmentCreationReason: 'init',\n    };\n    const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, () => {\n        flushSegment('view_change');\n    });\n    const { unsubscribe: unsubscribePageExited } = lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_EXITED */, (pageExitEvent) => {\n        flushSegment(pageExitEvent.reason);\n    });\n    function flushSegment(flushReason) {\n        if (state.status === 1 /* SegmentCollectionStatus.SegmentPending */) {\n            state.segment.flush((metadata, encoderResult) => {\n                const payload = buildReplayPayload(encoderResult.output, metadata, encoderResult.rawBytesCount);\n                if (isPageExitReason(flushReason)) {\n                    httpRequest.sendOnExit(payload);\n                }\n                else {\n                    httpRequest.send(payload);\n                }\n            });\n            clearTimeout(state.expirationTimeoutId);\n        }\n        if (flushReason !== 'stop') {\n            state = {\n                status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n                nextSegmentCreationReason: flushReason,\n            };\n        }\n        else {\n            state = {\n                status: 2 /* SegmentCollectionStatus.Stopped */,\n            };\n        }\n    }\n    return {\n        addRecord: (record) => {\n            if (state.status === 2 /* SegmentCollectionStatus.Stopped */) {\n                return;\n            }\n            if (state.status === 0 /* SegmentCollectionStatus.WaitingForInitialRecord */) {\n                const context = getSegmentContext();\n                if (!context) {\n                    return;\n                }\n                state = {\n                    status: 1 /* SegmentCollectionStatus.SegmentPending */,\n                    segment: createSegment({ encoder, context, creationReason: state.nextSegmentCreationReason }),\n                    expirationTimeoutId: setTimeout(() => {\n                        flushSegment('segment_duration_limit');\n                    }, SEGMENT_DURATION_LIMIT),\n                };\n            }\n            state.segment.addRecord(record, (encodedBytesCount) => {\n                if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n                    flushSegment('segment_bytes_limit');\n                }\n            });\n        },\n        stop: () => {\n            flushSegment('stop');\n            unsubscribeViewCreated();\n            unsubscribePageExited();\n        },\n    };\n}\nexport function computeSegmentContext(applicationId, sessionManager, viewHistory) {\n    const session = sessionManager.findTrackedSession();\n    const viewContext = viewHistory.findView();\n    if (!session || !viewContext) {\n        return undefined;\n    }\n    return {\n        application: {\n            id: applicationId,\n        },\n        session: {\n            id: session.id,\n        },\n        view: {\n            id: viewContext.id,\n        },\n    };\n}\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60000) {\n    SEGMENT_BYTES_LIMIT = newSegmentBytesLimit;\n}\n//# sourceMappingURL=segmentCollection.js.map","export function buildReplayPayload(data, metadata, rawSegmentBytesCount) {\n    const formData = new FormData();\n    formData.append('segment', new Blob([data], {\n        type: 'application/octet-stream',\n    }), `${metadata.session.id}-${metadata.start}`);\n    const metadataAndSegmentSizes = {\n        raw_segment_size: rawSegmentBytesCount,\n        compressed_segment_size: data.byteLength,\n        ...metadata,\n    };\n    const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes);\n    formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }));\n    return { data: formData, bytesCount: data.byteLength };\n}\n//# sourceMappingURL=buildReplayPayload.js.map","import { createHttpRequest, addTelemetryDebug, canUseEventBridge } from '@datadog/browser-core';\nimport { record } from '../domain/record';\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT } from '../domain/segmentCollection';\nimport { startRecordBridge } from '../domain/startRecordBridge';\nexport function startRecording(lifeCycle, configuration, sessionManager, viewHistory, encoder, httpRequest) {\n    const cleanupTasks = [];\n    const reportError = (error) => {\n        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });\n        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });\n    };\n    const replayRequest = httpRequest || createHttpRequest(configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError);\n    let addRecord;\n    if (!canUseEventBridge()) {\n        const segmentCollection = startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, replayRequest, encoder);\n        addRecord = segmentCollection.addRecord;\n        cleanupTasks.push(segmentCollection.stop);\n    }\n    else {\n        ;\n        ({ addRecord } = startRecordBridge(viewHistory));\n    }\n    const { stop: stopRecording } = record({\n        emit: addRecord,\n        configuration,\n        lifeCycle,\n        viewHistory,\n    });\n    cleanupTasks.push(stopRecording);\n    return {\n        stop: () => {\n            cleanupTasks.forEach((task) => task());\n        },\n    };\n}\n//# sourceMappingURL=startRecording.js.map","import { getEventBridge } from '@datadog/browser-core';\nexport function startRecordBridge(viewHistory) {\n    const bridge = getEventBridge();\n    return {\n        addRecord: (record) => {\n            // Get the current active view, not at the time of the record, aligning with the segment logic.\n            // This approach could potentially associate the record to an incorrect view, in case the record date is in the past (e.g. frustration records).\n            // However the risk is minimal. We could address the issue when potential negative impact are identified.\n            const view = viewHistory.findView();\n            bridge.send('record', record, view.id);\n        },\n    };\n}\n//# sourceMappingURL=startRecordBridge.js.map"],"file":"assets/vendor-DdpTwOUg.js"}